<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小丁的个人博客</title>
  
  <subtitle>世间所有的相遇，都是久别重逢</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tding.top/"/>
  <updated>2019-12-24T14:20:08.501Z</updated>
  <id>https://tding.top/</id>
  
  <author>
    <name>小丁</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Matplotlib系列之绘制双Y轴折线图和柱状图</title>
    <link href="https://tding.top/archives/9983dab2.html"/>
    <id>https://tding.top/archives/9983dab2.html</id>
    <published>2019-12-24T14:15:00.000Z</published>
    <updated>2019-12-24T14:20:08.501Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>为了有更明显的对比效果，有时候我们需要将两个不同的曲线放在同一张图中，一般来说，这两个曲线值是不太一样的，需要不同的刻度。这时候，我们可以用双Y轴进行表示。</p><p>本文主要介绍如何用matplotlib绘制双Y轴折线图和柱状图。</p><a id="more"></a><h2 id="绘制双Y轴折线图"><a href="#绘制双Y轴折线图" class="headerlink" title="绘制双Y轴折线图"></a>绘制双Y轴折线图</h2><p>这里的关键点在于：<code>ax2 = ax1.twinx()</code></p><ul><li><code>twinx</code>是添加y轴的坐标轴</li><li><code>twiny</code>是添加x轴的坐标轴</li></ul><p>同时，为了更加清晰，<strong>这里设置Y轴的刻度（tick）与标签（label）的颜色分别与其对应的曲线颜色相同</strong>，关键代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双Y轴标签颜色设置</span></span><br><span class="line">ax1.yaxis.label.set_color(line1.get_color())</span><br><span class="line">ax2.yaxis.label.set_color(line2.get_color())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双Y轴刻度颜色设置</span></span><br><span class="line">ax1.tick_params(axis = <span class="string">'y'</span>, colors = line1.get_color())</span><br><span class="line">ax2.tick_params(axis = <span class="string">'y'</span>, colors = line2.get_color())</span><br></pre></td></tr></table></figure><p>下面是全部的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig, ax1 = plt.subplots()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目平均金额折线图</span></span><br><span class="line">line1, = ax1.plot(df_year[<span class="string">'year_'</span>], df_year[<span class="string">'fund_mean'</span>],color = sns.xkcd_rgb[<span class="string">"pale red"</span>],linestyle = <span class="string">'-'</span>,label = <span class="string">'项目平均金额'</span>)</span><br><span class="line">p1 = ax1.scatter(df_year[<span class="string">'year_'</span>], df_year[<span class="string">'fund_mean'</span>],color = sns.xkcd_rgb[<span class="string">"pale red"</span>],marker = <span class="string">'v'</span>,s = <span class="number">30</span>,label = <span class="string">'项目平均金额'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目总金额折线图</span></span><br><span class="line">ax2 = ax1.twinx()</span><br><span class="line">line2, = ax2.plot(df_year[<span class="string">'year_'</span>], df_year[<span class="string">'fund_sum'</span>],color = sns.xkcd_rgb[<span class="string">"denim blue"</span>],linestyle = <span class="string">'-'</span>,label = <span class="string">'项目总金额'</span>)</span><br><span class="line">p2 = ax2.scatter(df_year[<span class="string">'year_'</span>], df_year[<span class="string">'fund_sum'</span>],color = sns.xkcd_rgb[<span class="string">"denim blue"</span>],marker = <span class="string">'o'</span>,s = <span class="number">30</span>,label = <span class="string">'项目总金额'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 坐标轴设置</span></span><br><span class="line">ax1.set_xlim([<span class="number">1985</span>,<span class="number">2020</span>])</span><br><span class="line">ax1.set_ylim([<span class="number">0</span>,<span class="number">75</span>])</span><br><span class="line">ax2.set_ylim([<span class="number">0</span>,<span class="number">2700000</span>])</span><br><span class="line"></span><br><span class="line">ax1.set_xlabel(<span class="string">"年份"</span>,fontsize = <span class="number">12</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">"项目平均金额/(万元)"</span>,fontsize = <span class="number">12</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">"项目总金额/(万元)"</span>,fontsize = <span class="number">12</span>)</span><br><span class="line">ax1.set_title(<span class="string">"资助项目年份统计"</span>,fontsize = <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双Y轴标签颜色设置</span></span><br><span class="line">ax1.yaxis.label.set_color(line1.get_color())</span><br><span class="line">ax2.yaxis.label.set_color(line2.get_color())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双Y轴刻度颜色设置</span></span><br><span class="line">ax1.tick_params(axis = <span class="string">'y'</span>, colors = line1.get_color())</span><br><span class="line">ax2.tick_params(axis = <span class="string">'y'</span>, colors = line2.get_color())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图例设置</span></span><br><span class="line">plt.legend(handles = [p1,p2])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/archives/9983dab2/双Y轴折线图.png" title="双Y轴折线图"><h2 id="绘制双Y轴柱状图"><a href="#绘制双Y轴柱状图" class="headerlink" title="绘制双Y轴柱状图"></a>绘制双Y轴柱状图</h2><p>双Y轴柱状图绘制的关键在于<strong>处理柱形的间隔<code>x1_list</code>(<code>[0,1,2…]</code>)、<code>x2_list</code>(<code>[0.4,1.4,2.4…]</code>)、<code>width</code>(<code>0.4</code>)的关系</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 柱形的宽度</span></span><br><span class="line">width = <span class="number">0.4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 柱形的间隔</span></span><br><span class="line">x1_list = []</span><br><span class="line">x2_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(df_nan_plot1)):</span><br><span class="line">    x1_list.append(i)</span><br><span class="line">    x2_list.append(i + width)</span><br></pre></td></tr></table></figure><p>双Y轴的其余设置与前面的双Y轴折线基本相同，唯一的不同点在于<strong>选取颜色的函数</strong>从<code>get_color()</code>变为了<code>get_facecolor()</code>。</p><p>下面是全部的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig, ax1 = plt.subplots()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 柱形的宽度</span></span><br><span class="line">width = <span class="number">0.4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 柱形的间隔</span></span><br><span class="line">x1_list = []</span><br><span class="line">x2_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(df_nan)):</span><br><span class="line">    x1_list.append(i)</span><br><span class="line">    x2_list.append(i + width)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制柱形图1</span></span><br><span class="line">b1 = ax1.bar(x1_list, df_nan[<span class="string">'项目数'</span>],width=width,label=<span class="string">'缺失项目数'</span>,color = sns.xkcd_rgb[<span class="string">"pale red"</span>],tick_label = df_nan[<span class="string">'学科'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制柱形图2---双Y轴</span></span><br><span class="line">ax2 = ax1.twinx()</span><br><span class="line">b2 = ax2.bar(x2_list, df[<span class="string">'项目数'</span>],width=width,label=<span class="string">'总项目数'</span>,color = sns.xkcd_rgb[<span class="string">"denim blue"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 坐标轴标签设置</span></span><br><span class="line">ax1.set_title(<span class="string">'资助金额字段缺失分析-学科'</span>,fontsize = <span class="number">14</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">'学科'</span>,fontsize=<span class="number">12</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">'缺失项目数'</span>,fontsize=<span class="number">12</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">'总项目数'</span>,fontsize=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x轴标签旋转</span></span><br><span class="line">ax1.set_xticklabels(ax1.get_xticklabels(),rotation = <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双Y轴标签颜色设置</span></span><br><span class="line">ax1.yaxis.label.set_color(b1[<span class="number">0</span>].get_facecolor())</span><br><span class="line">ax2.yaxis.label.set_color(b2[<span class="number">0</span>].get_facecolor())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双Y轴刻度颜色设置</span></span><br><span class="line">ax1.tick_params(axis = <span class="string">'y'</span>, colors = b1[<span class="number">0</span>].get_facecolor())</span><br><span class="line">ax2.tick_params(axis = <span class="string">'y'</span>, colors = b2[<span class="number">0</span>].get_facecolor())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图例设置</span></span><br><span class="line">plt.legend(handles = [b1,b2])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网格设置</span></span><br><span class="line">plt.grid(<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/archives/9983dab2/双Y轴柱状图.png" title="双Y轴柱状图"><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;为了有更明显的对比效果，有时候我们需要将两个不同的曲线放在同一张图中，一般来说，这两个曲线值是不太一样的，需要不同的刻度。这时候，我们可以用双Y轴进行表示。&lt;/p&gt;&lt;p&gt;本文主要介绍如何用matplotlib绘制双Y轴折线图和柱状图。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://tding.top/categories/Python/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/Python/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="Python" scheme="https://tding.top/tags/Python/"/>
    
      <category term="matplotlib" scheme="https://tding.top/tags/matplotlib/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Matplotlib系列之图例设置</title>
    <link href="https://tding.top/archives/f2256842.html"/>
    <id>https://tding.top/archives/f2256842.html</id>
    <published>2019-12-24T14:10:00.000Z</published>
    <updated>2019-12-24T14:20:08.494Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>当一张图中有多根曲线时，我们可以通过图例<code>legend</code>来对曲线进行注释区分。本文主要介绍matplotlib包的图例<code>legend</code>用法。</p><a id="more"></a><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><p>本文的示例数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">20</span>)</span><br><span class="line">y1 = <span class="number">2</span>*x+<span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">l1, = ax.plot(x, y1, color = sns.xkcd_rgb[<span class="string">"pale red"</span>], linestyle = <span class="string">'-'</span>, label = <span class="string">'2*x+1'</span>)</span><br><span class="line">l2, = ax.plot(x, y2, color = sns.xkcd_rgb[<span class="string">"denim blue"</span>], linestyle = <span class="string">'-'</span>, label = <span class="string">'x**2'</span>)</span><br><span class="line"></span><br><span class="line">ax.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/archives/f2256842/1.png" title="图1"><h2 id="图例位置"><a href="#图例位置" class="headerlink" title="图例位置"></a>图例位置</h2><h3 id="loc参数快速调整"><a href="#loc参数快速调整" class="headerlink" title="loc参数快速调整"></a>loc参数快速调整</h3><p>我们可以通过<code>loc</code>参数进行快速放置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.legend(loc = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><code>loc</code>不同的值代表不同的位置，具体对应表如下：</p><table><thead><tr><th>Location String</th><th>Location Code</th></tr></thead><tbody><tr><td>best</td><td>0</td></tr><tr><td>upper right</td><td>1</td></tr><tr><td>upper left</td><td>2</td></tr><tr><td>lower left</td><td>3</td></tr><tr><td>lower right</td><td>4</td></tr><tr><td>right</td><td>5</td></tr><tr><td>center left</td><td>6</td></tr><tr><td>center right</td><td>7</td></tr><tr><td>lower center</td><td>8</td></tr><tr><td>upper center</td><td>9</td></tr><tr><td>center</td><td>10</td></tr></tbody></table><h3 id="bbox-to-anchor参数手动控制"><a href="#bbox-to-anchor参数手动控制" class="headerlink" title="bbox_to_anchor参数手动控制"></a>bbox_to_anchor参数手动控制</h3><p>不过<code>loc</code>没有选项可以直接将<code>legend</code>放置到坐标轴外侧，这时候，我们可以用<code>bbox_to_anchor</code>参数来手动控制。</p><p><strong>注意：直接将图例放置到坐标轴之外也会直接放置到绘图区外了，因而我们需要先调整坐标轴在绘图区的位置</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先调整坐标轴在绘图区的位置  </span></span><br><span class="line">ax.set_position([<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.6</span>,<span class="number">0.9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图例放置 </span></span><br><span class="line">ax.legend(bbox_to_anchor=(<span class="number">1.05</span>,<span class="number">0.8</span>))</span><br></pre></td></tr></table></figure><p>全部代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">20</span>)</span><br><span class="line">y1 = <span class="number">2</span>*x+<span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先调整坐标轴在绘图区的位置  </span></span><br><span class="line">ax.set_position([<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.6</span>,<span class="number">0.9</span>])</span><br><span class="line"></span><br><span class="line">l1, = ax.plot(x, y1, color = sns.xkcd_rgb[<span class="string">"pale red"</span>], linestyle = <span class="string">'-'</span>, label = <span class="string">'2*x+1'</span>)</span><br><span class="line">l2, = ax.plot(x, y2, color = sns.xkcd_rgb[<span class="string">"denim blue"</span>], linestyle = <span class="string">'-'</span>, label = <span class="string">'x**2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图例放置 </span></span><br><span class="line">ax.legend(bbox_to_anchor=(<span class="number">1.05</span>,<span class="number">0.8</span>))  </span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/archives/f2256842/2.png" title="图2"><p>我们可以通过<code>ncol</code>这个参数来调整图例的<strong>列数</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.legend(bbox_to_anchor=(<span class="number">0.8</span>,<span class="number">1.2</span>), ncol = <span class="number">2</span>)</span><br></pre></td></tr></table></figure><img src="/archives/f2256842/3.png" title="图3"><h2 id="实现多个图例"><a href="#实现多个图例" class="headerlink" title="实现多个图例"></a>实现多个图例</h2><p>不带参数调用<code>legend()</code>会自动获取图例句柄及其相关标签。此函数等同于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">handles, labels = ax.get_legend_handles_labels()</span><br><span class="line">ax.legend(handles, labels)</span><br></pre></td></tr></table></figure><p>因此，如果我们想要实现多个图例，我们可以手动控制<code>handles</code>参数。</p><p>首先，我试试直接采用多次调用<code>legend()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">20</span>)</span><br><span class="line">y1 = <span class="number">2</span>*x+<span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">l1, = ax.plot(x, y1, color = sns.xkcd_rgb[<span class="string">"pale red"</span>], linestyle = <span class="string">'-'</span>, label = <span class="string">'2*x+1'</span>)</span><br><span class="line">l2, = ax.plot(x, y2, color = sns.xkcd_rgb[<span class="string">"denim blue"</span>], linestyle = <span class="string">'-'</span>, label = <span class="string">'x**2'</span>)</span><br><span class="line"></span><br><span class="line">ax.legend(handles = [l1], loc = <span class="number">1</span>)</span><br><span class="line">ax.legend(handles = [l2], loc = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/archives/f2256842/4.png" title="图4"><p>我们发现轴域上只存在一个图例。这样做是为了可以重复调用<code>legend()</code>，将图例更新为轴域上的最新句柄。因此，如果我们要保留旧的图例实例，必须将它们手动添加到轴域中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">20</span>)</span><br><span class="line">y1 = <span class="number">2</span>*x+<span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">l1, = ax.plot(x, y1, color = sns.xkcd_rgb[<span class="string">"pale red"</span>], linestyle = <span class="string">'-'</span>, label = <span class="string">'2*x+1'</span>)</span><br><span class="line">l2, = ax.plot(x, y2, color = sns.xkcd_rgb[<span class="string">"denim blue"</span>], linestyle = <span class="string">'-'</span>, label = <span class="string">'x**2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个线条创建图例</span></span><br><span class="line">first_legend = plt.legend(handles=[l1], loc=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 手动将图例添加到当前轴域</span></span><br><span class="line">ax = plt.gca().add_artist(first_legend)</span><br><span class="line"><span class="comment"># 第二个线条创建另一个图例</span></span><br><span class="line">plt.legend(handles=[l2], loc=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/archives/f2256842/5.png" title="图5"><h2 id="图例边框和背景设置"><a href="#图例边框和背景设置" class="headerlink" title="图例边框和背景设置"></a>图例边框和背景设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 去掉图例边框</span></span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>,frameon=<span class="keyword">False</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图例边框颜色</span></span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>,edgecolor=<span class="string">'blue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图例背景颜色,若无边框,参数无效  </span></span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>,facecolor=<span class="string">'blue'</span>)</span><br></pre></td></tr></table></figure><p>一个去掉图例边框的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">20</span>)</span><br><span class="line">y1 = <span class="number">2</span>*x+<span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line">l1, = ax.plot(x, y1, color = sns.xkcd_rgb[<span class="string">"pale red"</span>], linestyle = <span class="string">'-'</span>, label = <span class="string">'2*x+1'</span>)</span><br><span class="line">l2, = ax.plot(x, y2, color = sns.xkcd_rgb[<span class="string">"denim blue"</span>], linestyle = <span class="string">'-'</span>, label = <span class="string">'x**2'</span>)</span><br><span class="line"></span><br><span class="line">ax.legend(frameon=<span class="keyword">False</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/archives/f2256842/6.png" title="图6"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://wizardforcel.gitbooks.io/matplotlib-user-guide/content/3.6.html" rel="external nofollow noopener noreferrer" target="_blank">图例指南</a></li><li><a href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.legend.html" rel="external nofollow noopener noreferrer" target="_blank">matplotlib.pyplot.legend</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;当一张图中有多根曲线时，我们可以通过图例&lt;code&gt;legend&lt;/code&gt;来对曲线进行注释区分。本文主要介绍matplotlib包的图例&lt;code&gt;legend&lt;/code&gt;用法。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://tding.top/categories/Python/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/Python/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="Python" scheme="https://tding.top/tags/Python/"/>
    
      <category term="matplotlib" scheme="https://tding.top/tags/matplotlib/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客展示GitHub Chart</title>
    <link href="https://tding.top/archives/90b9ba07.html"/>
    <id>https://tding.top/archives/90b9ba07.html</id>
    <published>2019-12-23T14:40:30.000Z</published>
    <updated>2019-12-23T14:54:47.879Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>本文主要介绍如何在个人博客中展示GitHub Chart。其实GitHub上已经有人开源了一个工具，并且提供了API，我们只需要调用一下就可以了。</p><ul><li>工具地址：<a href="https://ghchart.rshah.org/" rel="external nofollow noopener noreferrer" target="_blank">Github Chart API</a></li></ul><a id="more"></a><p>这个工具可以实时的将<code>GitHub Chart</code>信息<strong>转化成一张图片</strong>，如下图所示，然后我们就可以把它插入到自己的博客进行展示了。</p><p><img src="https://ghchart.rshah.org/dta0502" alt></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>我们只需要在<code>https://ghchart.rshah.org/</code>这个地址后加上自己的<strong>GitHub用户名</strong>即可构造GitHub Chart图片的URL。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ghchart.rshah.org/dta0502</span><br></pre></td></tr></table></figure><h3 id="HTML引入图片"><a href="#HTML引入图片" class="headerlink" title="HTML引入图片"></a>HTML引入图片</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://ghchart.rshah.org/dta0502"</span> <span class="attr">alt</span>=<span class="string">"dta0502's Github chart"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Markdown引入图片"><a href="#Markdown引入图片" class="headerlink" title="Markdown引入图片"></a>Markdown引入图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">dta0502's Github chart</span>](<span class="link">https://ghchart.rshah.org/dta0502</span>)</span><br></pre></td></tr></table></figure><h2 id="自定义颜色"><a href="#自定义颜色" class="headerlink" title="自定义颜色"></a>自定义颜色</h2><p>这个工具还支持自定义配色方案，我们可以提供任何基本颜色来为图表添加阴影。</p><p>我们只需访问<code>https://ghchart.rshah.org/&lt;HEX-COLOR&gt;/2016rshah</code>，然后将<code>&lt;HEX-COLOR&gt;</code>替换为我们想要设置的十六进制颜色代码（不包括开头的标签）就可以了。</p><p>例如，如果我们想要一个的蓝色主题图表（<code>＃409ba5</code>），那么我们可以构造链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://ghchart.rshah.org/409ba5/dta0502"</span> <span class="attr">alt</span>=<span class="string">"dta0502's Blue Github Chart"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://ghchart.rshah.org/409ba5/dta0502" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/2016rshah/githubchart-api" rel="external nofollow noopener noreferrer" target="_blank">Github Chart API</a></li><li><a href="https://mogeko.me/2019/067/" rel="external nofollow noopener noreferrer" target="_blank">在博客中展示 GitHub Chart</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;本文主要介绍如何在个人博客中展示GitHub Chart。其实GitHub上已经有人开源了一个工具，并且提供了API，我们只需要调用一下就可以了。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;工具地址：&lt;a href=&quot;https://ghchart.rshah.org/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Github Chart API&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
      <category term="Hexo" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://tding.top/tags/Hexo/"/>
    
      <category term="GitHub Chart" scheme="https://tding.top/tags/GitHub-Chart/"/>
    
  </entry>
  
  <entry>
    <title>ggplot2柱状图按数值大小排序</title>
    <link href="https://tding.top/archives/c363755b.html"/>
    <id>https://tding.top/archives/c363755b.html</id>
    <published>2019-12-22T14:30:00.000Z</published>
    <updated>2019-12-22T14:34:32.607Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>ggplot2柱状图按照数值大小进行排序是比较困难的。<strong>这是因为ggplot2考虑的是因子级别的顺序，而不是数据框中观察到的顺序</strong>。我们可以使用<code>sort()</code>或<code>arrange()</code>对输入数据框进行排序，但是这不会对ggplot2输出产生任何影响（柱状图依旧按照因子的顺序排列）。</p><p>本文主要介绍如何让ggplot2的柱状图按照数值大小排序。</p><a id="more"></a><h2 id="本文用到的数据集"><a href="#本文用到的数据集" class="headerlink" title="本文用到的数据集"></a>本文用到的数据集</h2><p>数据集1——自己定义的：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data &lt;- data.frame(</span><br><span class="line">  name = c(<span class="string">"north"</span>,<span class="string">"south"</span>,<span class="string">"south-east"</span>,<span class="string">"north-west"</span>,<span class="string">"south-west"</span>,<span class="string">"north-east"</span>,<span class="string">"west"</span>,<span class="string">"east"</span>),</span><br><span class="line">  val=sample(seq(<span class="number">1</span>,<span class="number">10</span>), <span class="number">8</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>数据集2——ggplot2包自带的mpg数据集。</p><h2 id="forecats包实现"><a href="#forecats包实现" class="headerlink" title="forecats包实现"></a>forecats包实现</h2><p><code>forecats</code>库是<code>tidyverse</code>中的一个库，专门用于处理R中的因子，它提供了一组有用的工具来解决因子的常见问题。<strong>其中<code>fact_reorder()</code>函数允许通过另一列<code>data$val</code>的值对因子<code>data$name</code>进行重新排序</strong>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line"><span class="keyword">library</span>(dplyr)</span><br><span class="line"><span class="keyword">library</span>(forcats)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过另一列的值来对因子重新排序（升序）</span></span><br><span class="line">data %&gt;%</span><br><span class="line">  mutate(name = fct_reorder(name, val)) %&gt;%</span><br><span class="line">  ggplot(aes(x=name, y=val)) +</span><br><span class="line">    geom_bar(stat=<span class="string">"identity"</span>, fill=<span class="string">"#f68060"</span>, alpha=<span class="number">.6</span>, width=<span class="number">.4</span>) +</span><br><span class="line">    coord_flip() +</span><br><span class="line">    xlab(<span class="string">""</span>) +</span><br><span class="line">    theme_bw()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过另一列的值来对因子重新排序（降序）</span></span><br><span class="line">data %&gt;%</span><br><span class="line">  mutate(name = fct_reorder(name, desc(val))) %&gt;%</span><br><span class="line">  ggplot(aes(x=name, y=val)) +</span><br><span class="line">    geom_bar(stat=<span class="string">"identity"</span>, fill=<span class="string">"#f68060"</span>, alpha=<span class="number">.6</span>, width=<span class="number">.4</span>) +</span><br><span class="line">    coord_flip() +</span><br><span class="line">    xlab(<span class="string">""</span>) +</span><br><span class="line">    theme_bw()</span><br></pre></td></tr></table></figure><img src="/archives/c363755b/1.png" title="图1"><p>我们可以指定用哪个函数<code>.fun</code>来确定顺序。默认值是使用中位数，我们也可以使用每组的数据点数来排序：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中位数（默认）</span></span><br><span class="line">mpg %&gt;%</span><br><span class="line">  mutate(class = fct_reorder(class, hwy, .fun=<span class="string">'median'</span>)) %&gt;%</span><br><span class="line">  ggplot(aes(x=class, y=hwy, fill=class)) + </span><br><span class="line">    geom_boxplot() +</span><br><span class="line">    xlab(<span class="string">"class"</span>) +</span><br><span class="line">    theme(legend.position=<span class="string">"none"</span>) +</span><br><span class="line">    xlab(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据点数</span></span><br><span class="line">mpg %&gt;%</span><br><span class="line">  mutate(class = fct_reorder(class, hwy, .fun=<span class="string">'length'</span>)) %&gt;%</span><br><span class="line">  ggplot(aes(x=class, y=hwy, fill=class)) + </span><br><span class="line">    geom_boxplot() +</span><br><span class="line">    xlab(<span class="string">"class"</span>) +</span><br><span class="line">    theme(legend.position=<span class="string">"none"</span>) +</span><br><span class="line">    xlab(<span class="string">""</span>)</span><br></pre></td></tr></table></figure><img src="/archives/c363755b/2.png" title="图2"><p>当然我们也可以自己指定因子的顺序：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data %&gt;%</span><br><span class="line">  mutate(name = fct_relevel(name, </span><br><span class="line">            <span class="string">"north"</span>, <span class="string">"north-east"</span>, <span class="string">"east"</span>, </span><br><span class="line">            <span class="string">"south-east"</span>, <span class="string">"south"</span>, <span class="string">"south-west"</span>, </span><br><span class="line">            <span class="string">"west"</span>, <span class="string">"north-west"</span>)) %&gt;%</span><br><span class="line">  ggplot( aes(x=name, y=val)) +</span><br><span class="line">    geom_bar(stat=<span class="string">"identity"</span>) +</span><br><span class="line">    xlab(<span class="string">""</span>)</span><br></pre></td></tr></table></figure><img src="/archives/c363755b/3.png" title="图3"><h2 id="dplyr包实现"><a href="#dplyr包实现" class="headerlink" title="dplyr包实现"></a>dplyr包实现</h2><p><code>dplyr</code>的<code>mutate()</code>函数允许创建新变量或修改现有变量，我们可以用它来重新创建具有特定顺序的因子。下面是两个例子：</p><ul><li>采用<code>arrange()</code>对数据框进行排序，然后按照这个顺序对因子进行重新排序。</li><li>自定义因子顺序。</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用arrange()对数据框排序，然后按照这个顺序对因子进行重新排序</span></span><br><span class="line">data %&gt;%</span><br><span class="line">  <span class="comment"># 按照val进行排序，但是这只对数据框进行了排序而没有对因子进行排序</span></span><br><span class="line">  arrange(val) %&gt;%</span><br><span class="line">  <span class="comment"># 通过下面这个小技巧可以直接更新因子</span></span><br><span class="line">  mutate(name=factor(name, levels=name)) %&gt;%</span><br><span class="line">  ggplot(aes(x=name, y=val)) +</span><br><span class="line">    geom_segment(aes(xend=name, yend=<span class="number">0</span>)) +</span><br><span class="line">    geom_point(size=<span class="number">4</span>, color=<span class="string">"orange"</span>) +</span><br><span class="line">    coord_flip() +</span><br><span class="line">    theme_bw() +</span><br><span class="line">    xlab(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义因子顺序</span></span><br><span class="line">data %&gt;%</span><br><span class="line">  arrange(val) %&gt;%</span><br><span class="line">  mutate(name = factor(name, levels=c(<span class="string">"north"</span>, <span class="string">"north-east"</span>, <span class="string">"east"</span>, <span class="string">"south-east"</span>, <span class="string">"south"</span>, <span class="string">"south-west"</span>, <span class="string">"west"</span>, <span class="string">"north-west"</span>))) %&gt;%</span><br><span class="line">  ggplot(aes(x=name, y=val)) +</span><br><span class="line">    geom_segment(aes(xend=name, yend=<span class="number">0</span>)) +</span><br><span class="line">    geom_point(size=<span class="number">4</span>, color=<span class="string">"orange"</span>) +</span><br><span class="line">    theme_bw() +</span><br><span class="line">    xlab(<span class="string">""</span>)</span><br></pre></td></tr></table></figure><img src="/archives/c363755b/4.png" title="图4"><h2 id="base包的reorder-函数实现"><a href="#base包的reorder-函数实现" class="headerlink" title="base包的reorder()函数实现"></a>base包的reorder()函数实现</h2><p><code>reorder()</code>函数用法：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reorder(x, X, FUN = mean, <span class="keyword">...</span>, order = is.ordered(x))</span><br></pre></td></tr></table></figure><ul><li><code>x</code>：因子型向量</li><li><code>X</code>：用来排序的数值型向量</li><li><code>FUN</code>：汇总数据的函数</li><li><code>...</code>：<code>FUN</code>的参数（可选）</li><li><code>order</code>：我们可以通过这个参数直接指定因子型向量的顺序</li></ul><p>按照x对X进行分组，对每一组组成的向量计算后面的函数，最后根据计算结果从小到大指定x中元素的顺序。</p><p>下面是一个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mpg$class = with(mpg, reorder(class, hwy, median))</span><br><span class="line"></span><br><span class="line">p &lt;- mpg %&gt;%</span><br><span class="line">  ggplot( aes(x=class, y=hwy, fill=class)) + </span><br><span class="line">    geom_violin() +</span><br><span class="line">    xlab(<span class="string">"class"</span>) +</span><br><span class="line">    theme(legend.position=<span class="string">"none"</span>) +</span><br><span class="line">    xlab(<span class="string">""</span>)</span><br></pre></td></tr></table></figure><img src="/archives/c363755b/5.png" title="图5"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.r-graph-gallery.com/267-reorder-a-variable-in-ggplot2.html" rel="external nofollow noopener noreferrer" target="_blank">Reorder a variable with ggplot2</a></li><li><a href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/reorder.factor.html" rel="external nofollow noopener noreferrer" target="_blank">Reorder Levels of a Factor</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;ggplot2柱状图按照数值大小进行排序是比较困难的。&lt;strong&gt;这是因为ggplot2考虑的是因子级别的顺序，而不是数据框中观察到的顺序&lt;/strong&gt;。我们可以使用&lt;code&gt;sort()&lt;/code&gt;或&lt;code&gt;arrange()&lt;/code&gt;对输入数据框进行排序，但是这不会对ggplot2输出产生任何影响（柱状图依旧按照因子的顺序排列）。&lt;/p&gt;&lt;p&gt;本文主要介绍如何让ggplot2的柱状图按照数值大小排序。&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
      <category term="柱状图" scheme="https://tding.top/tags/%E6%9F%B1%E7%8A%B6%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Win10清理C盘方法</title>
    <link href="https://tding.top/archives/df0b3807.html"/>
    <id>https://tding.top/archives/df0b3807.html</id>
    <published>2019-12-22T14:20:00.000Z</published>
    <updated>2019-12-23T15:00:50.834Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>本文主要介绍了几个Win10系统C盘空间清理的小技巧。</p><a id="more"></a><h2 id="清理Windows日志文件"><a href="#清理Windows日志文件" class="headerlink" title="清理Windows日志文件"></a>清理Windows日志文件</h2><p>系统使用时间长的，日志文件甚至会超过数G。</p><p>我们可以通过<code>计算机管理—事件查看器—Windows日志—系统（右键）--清除日志</code>。</p><h2 id="索引文件转移"><a href="#索引文件转移" class="headerlink" title="索引文件转移"></a>索引文件转移</h2><p>索引文件来加快搜索速度的，电脑硬盘越大，安装的文件越多，索引文件越大。索引文件默认在C盘。</p><p>默认的索引文件在<code>C:\ProgramData\Microsoft\Search\Data\Applications\Windows</code>文件夹下的<code>Windows.edb</code>文件。</p><p>我们可以通过<code>控制面板—索引选项—高级—索引设置—选择新位置</code>来把索引文件转移到非系统盘：</p><ol><li>控制面板窗口中，我们需要点击右上角的“大图标”菜单项，这样就会打开Win10的所有控制面板项窗口，然后点击窗口中的“索引选项”图标：</li></ol><img src="/archives/df0b3807/索引文件转移-1.png" title="索引文件转移-1"> <img src="/archives/df0b3807/索引文件转移-2.png" title="索引文件转移-2"><ol start="2"><li>选择新位置</li></ol><img src="/archives/df0b3807/索引文件转移-3.png" title="索引文件转移-3"><h2 id="缩小休眠文件"><a href="#缩小休眠文件" class="headerlink" title="缩小休眠文件"></a>缩小休眠文件</h2><p>默认情况下，休眠文件或休眠文件（<code>C:\hiberfil.sys</code>）是Windows 10计算机上安装的RAM总量的75％。快速启动需要启用休眠模式。如果您只想使用快速启动而又不打算使用休眠功能，则可以将<code>hiberfile</code>类型指定为减小的类型，以将休眠文件的大小（<code>hiberfil.sys</code>）减小到其完整大小的一半。</p><p>Hibernate文件有两种类型：</p><ul><li><p><strong>完整-Full</strong>：完整的hiberfile类型可以启用休眠模式并打开快速启动（hiberboot）。它约占可用RAM总量的75％。默认大小是物理内存的40％。它支持休眠，混合睡眠，快速启动。</p></li><li><p><strong>精简-Reduced</strong>：这种类型的hiberfile无需休眠即可开启快速启动（hiberboot）。减少的文件类型将<code>C:\hiberfil.sys</code>的大小减小到其完整大小的大约50％。此命令将从电源菜单中删除休眠模式。<strong>默认大小是物理内存的20％</strong>。它支持快速启动。</p></li></ul><p>我们可以通过下面的命令（<strong>管理员身份运行cmd</strong>）来将Hiberfile类型指定为“精简”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powercfg /h /<span class="built_in">type</span> reduced</span><br></pre></td></tr></table></figure><p>注意：如果将休眠文件设置为大于40％的自定义大小，则命令将返回“参数错误”错误。 您必须先使用命令<code>powercfg /h /size 0</code>将文件的大小设置为零，然后重新运行休眠文件类型“ reduced”命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;powercfg /h /size 0</span><br><span class="line">        已将休眠文件大小设置为: 3320750080 字节。</span><br><span class="line"></span><br><span class="line">C:\WINDOWS\system32&gt;powercfg /h /<span class="built_in">type</span> reduced</span><br><span class="line">        已将休眠文件大小设置为: 1660375040 字节。</span><br></pre></td></tr></table></figure><h2 id="过期驱动文件清理"><a href="#过期驱动文件清理" class="headerlink" title="过期驱动文件清理"></a>过期驱动文件清理</h2><p>Windows系统对于驱动文件，有这样的一个机制。系统会把第三方的驱动都放入到<code>C:\Windows\System32\DriverStore</code>目录中，当你安装新驱动的时候，新的驱动也会安装到这个目录。然而，用户安装新驱动的同时，系统并不会清理掉之前的老驱动，而是保留老驱动的文件，方便出问题的时候恢复。</p><p><strong>注意：直接删DriverStore目录的文件很容易出问题</strong>。</p><p>其实Windows一直都有一个自带的命令行工具 <code>pnputil.exe</code> ，用这个可以列出DriverStore中的驱动，还可以删除，但是，命令行的工具比较难用，因而，我们可以用<a href="https://github.com/lostindark/DriverStoreExplorer" rel="external nofollow noopener noreferrer" target="_blank">Driver Store Explorer</a>来删除老驱动。<code>Driver Store Explorer</code>就是给<code>pnputil</code>做了个简单的图形界面。</p><p>使用方法：用管理员权限启动后，右键点击不要的选择删除即可。正常情况下在用的驱动是无法删除的，当然，点击<code>Force deletion</code>除外。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/32220500" rel="external nofollow noopener noreferrer" target="_blank">Win10清理系统盘空间实用攻略</a></li><li><a href="https://zhuanlan.zhihu.com/p/28639474" rel="external nofollow noopener noreferrer" target="_blank">Windows快速启动背后的功臣：休眠</a></li><li><a href="http://www.microwin10.com/wenzhang/jiaocheng/2019-10-31/14856.html" rel="external nofollow noopener noreferrer" target="_blank">如何在Win10中将Hiberfile类型指定为完全或精简</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;本文主要介绍了几个Win10系统C盘空间清理的小技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
      <category term="Windows" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Windows/"/>
    
    
      <category term="Windows" scheme="https://tding.top/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>微信聊天记录解密并导出</title>
    <link href="https://tding.top/archives/e872e04.html"/>
    <id>https://tding.top/archives/e872e04.html</id>
    <published>2019-12-18T15:30:00.000Z</published>
    <updated>2019-12-19T15:55:37.603Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>我们知道，微信的聊天记录是加密的，因而我们不能从文件中直接查看、导出。本文主要介绍如何把聊天记录解密、导出成SQL或csv文件。</p><a id="more"></a><h2 id="手机微信数据库导出"><a href="#手机微信数据库导出" class="headerlink" title="手机微信数据库导出"></a>手机微信数据库导出</h2><h3 id="方法1——某些手机无需root即可备份"><a href="#方法1——某些手机无需root即可备份" class="headerlink" title="方法1——某些手机无需root即可备份"></a>方法1——某些手机无需root即可备份</h3><p>某些手机（比如某米、某为）通过官方的APP（无需root）即可把微信手机端的应用数据备份到电脑或者SD卡上。</p><p>但是我在实际操作的时候碰到了困难，我用的是某为手机，在电脑端和手机端均安装了官方提供的手机助手软件以后，正准备备份微信这个应用的数据，<strong>竟然一定要我输入密码进行加密</strong>，备份数据加密后就无法进行后续的操作了。我只好放弃了这个办法。</p><h3 id="方法2——root"><a href="#方法2——root" class="headerlink" title="方法2——root"></a>方法2——root</h3><p>如果你的手机已经root，那么你可以直接使用<code>adb</code>将<code>/data/data/com.tencent.mm</code>复制即可。</p><blockquote><p><code>/data/data/&lt;package_name&gt;</code>目录是app的私有目录，本身可以访问，外部程序没有访问权限，一些不想让用户看到的文件可以放在这里。此目录在程序卸载后将被删除，对应的是设置中的“数据”一项，如果清空数据，这个目录将会被清空。app自身对此目录的读写不需要额外的权限。<strong>注意：没root过的手机是看不到这个目录的</strong>。</p></blockquote><p>考虑到安全因素，我没有选择这种方法。</p><h3 id="方法3——安卓模拟器"><a href="#方法3——安卓模拟器" class="headerlink" title="方法3——安卓模拟器"></a>方法3——安卓模拟器</h3><p>我们可以在电脑上安装一款安卓模拟器，然后里面下载手机微信并登录，<strong>然后将手机端聊天记录备份到电脑端微信，再将电脑端聊天记录恢复到安卓虚拟器里的微信</strong>。现在对安卓虚拟器进行root，然后我就可以进入<code>/data/data/&lt;package_name&gt;</code>目录，从而把数据库复制到电脑上了。</p><p>下面我简单讲一下整个步骤：</p><ol><li>我选择了蓝叠这个安卓模拟器。首先在模拟器上下载了微信APP，然后我把自己手机微信上的聊天数据备份到电脑微信中，然后退出手机微信，在模拟器上登录微信，再把数据恢复到模拟器上的微信中。</li><li>在模拟器右上角的设置中打开root权限。</li><li>打开文件浏览器，找到数据库文件，它在<code>/data/data/com.tencent.mm/MicroMsg/[weixin_name]/EnMicroMsg.db</code>。<strong>其中文件夹 <code>[weixin_name]</code> 的名字为32位的md5值，如 <code>85794836981744a4472f69d89aeb2152</code>，一个微信号对应一个文件夹</strong>。如果有多个 <code>[weixin_name]</code>，那么此微信肯定登录过多个微信号。</li><li>把数据库文件拷贝到<code>/sdcard/windows/BstSharedFolder</code>这个共享文件夹中，这个文件夹在Windows上就是<code>BluestacksCN/Engine/ProgramData/Engine/UserData/SharedFolder</code>，当我们在模拟器中拷贝完数据后，在Windows上就能看到了。注意：数据是互通的。</li></ol><h2 id="破解数据库密码"><a href="#破解数据库密码" class="headerlink" title="破解数据库密码"></a>破解数据库密码</h2><p>根据前人的分析，微信数据库 <code>EnMicroMsg.db</code> 的密码是由 <code>MD5(IMEI + uin).substring(0, 7)</code> 生成的。因此，我们需要找到<code>IMEI</code>和<code>uin</code>值。</p><h3 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>我通过在模拟器上安装这个工具：<a href="https://apkpure.com/find-imei/com.imeino" rel="external nofollow noopener noreferrer" target="_blank">Find IMEI</a>来查看<code>IMEI</code>。</p><p>下载apk，然后把apk放入到<code>BluestacksCN/Engine/ProgramData/Engine/UserData/SharedFolder</code>这个文件夹中，我们就可以在模拟器的<code>/sdcard/windows/BstSharedFolder</code>文件夹中找到了，然后直接安装，打开就直接显示出<code>IMEI</code>了。</p><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>我们也可以在<code>/data/data/com.tencent.mm/shared_prefs/DENGTA_META.xml</code>中查找名为 <code>IMEI_DENGTA</code> 的值。</p><h3 id="uin"><a href="#uin" class="headerlink" title="uin"></a>uin</h3><p><code>uin</code>（<code>unique identifier</code>）是唯一标识符（整数类型），微信分配每个用户的唯一标识符，它具有不可重复性，也就是说这个世界上没有两个 <code>uin</code> 相同的微信号。</p><h4 id="方法1-1"><a href="#方法1-1" class="headerlink" title="方法1"></a>方法1</h4><p>我们可以在<code>/data/data/com.tencent.mm/shared_prefs/system_config_prefs.xml</code>找到<code>default_uin</code>，后面的数字就是我们要找的<code>uin</code>了。</p><h4 id="方法2-1"><a href="#方法2-1" class="headerlink" title="方法2"></a>方法2</h4><p>我们也可以登录 web 微信，按 F12 打开网页调试工具，然后 <code>ctrl+F</code> 搜索 <code>uin</code>，可以找到一串长长的 URL，里面的 <code>uin</code> 就是当前登录的微信的 <code>uin</code>。</p><h3 id="计算密码"><a href="#计算密码" class="headerlink" title="计算密码"></a>计算密码</h3><p>注意：</p><ul><li><code>IMEI</code>中的字母必须为<strong>大写</strong></li><li><code>MD5</code>中的字母必须为<strong>小写</strong></li></ul><p>我们可以使用：<a href="http://emn178.github.io/online-tools/md5.html" rel="external nofollow noopener noreferrer" target="_blank">MD5在线计算</a>来计算MD5值，<strong>密码即为32位的前7位（小写）</strong>。</p><h2 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h2><p>微信使用了<code>sqlcipher</code>加密了数据库，因此，我们也可以使用<code>sqlcipher</code>进行解密。</p><blockquote><p>SQLCipher是一个在SQLite基础之上进行扩展的开源数据库，它主要是在SQLite的基础之上增加了数据加密功能，如果我们在项目中使用它来存储数据的话，就可以大大提高程序的安全性。</p></blockquote><h3 id="Windows下打开"><a href="#Windows下打开" class="headerlink" title="Windows下打开"></a>Windows下打开</h3><p>Windows用户可以直接使用 <code>sqlcipher.exe</code> 打开 <code>com.tencent.mm/MicroMsg/[weixin_name]/EnMicroMsg.db</code>，在弹出的窗口输入刚刚生成的7位密码。</p><blockquote><p><code>sqlcipher.exe</code>其实是SQLite Database Browser软件再嵌套了解密功能。</p></blockquote><p><strong>注意：sqlcipher不同版本使用的加密方式不同，如果解密用<code>sqlcipher</code>版本和加密用的<code>sqlcipher</code>版本不一样，会提示<code>file is not a database</code>，实际错误是解密失败。目前发现<code>2.1</code>版本的sqlcipher可以正常解密</strong>。</p><p>然后我们可以在 <code>Browse Data</code> 菜单栏处查看数据中各个数据表。</p><p>我们可以点击菜单栏的<code>File-Export-Table as CSV file</code>，选择message表，导出成<code>csv</code>文件。如果直接用Excel打开这个表格，可能会显示乱码。所以我们新建一个Excel表格，点击数据-来自文本，然后导入这个<code>.csv</code>文件。在弹出的第一个下拉框中选择<code>GB2312</code>，然后载入就不会出现乱码。</p><h3 id="Ubuntu下打开"><a href="#Ubuntu下打开" class="headerlink" title="Ubuntu下打开"></a>Ubuntu下打开</h3><p>安装sqlicipher：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sqlcipher</span><br></pre></td></tr></table></figure><p>解密数据库文件，这里我们要输入前面得到的密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlcipher EnMicroMsg.db <span class="string">'PRAGMA key = "yourkey"; PRAGMA cipher_use_hmac = off; PRAGMA kdf_iter = 4000; ATTACH DATABASE "decrypted_database.db" AS decrypted_database KEY "";SELECT sqlcipher_export("decrypted_database");DETACH DATABASE decrypted_database;'</span></span><br></pre></td></tr></table></figure><p>然后我们就得到了解密的数据库<code>decrypted_database.db</code>，我们可以用自己熟悉的数据库软件打开。</p><h3 id="了解数据表"><a href="#了解数据表" class="headerlink" title="了解数据表"></a>了解数据表</h3><p>我们主要使用以下三个表：</p><ul><li><code>rcontact</code>：通讯录表</li><li><code>chatroom</code>：群聊表</li><li><code>message</code>：聊天记录表</li></ul><p>微信文字聊天记录在数据表<code>message</code>中。我们可以根据<code>talker</code>这个字段来筛选出特定用户的聊天记录。如果为群聊，那么<code>message.talker = chatroom.chatroomname</code>。<code>message.content</code>中存储形式为：<code>群成员wxid:\n内容</code>。</p><p>比如，我们可以查询与某人的聊天记录，下面是SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> datetime(<span class="keyword">subStr</span>(<span class="keyword">cast</span>(m.createTime <span class="keyword">as</span> <span class="built_in">text</span>),<span class="number">1</span>,<span class="number">10</span>),<span class="string">'unixepoch'</span>, <span class="string">'localtime'</span>) <span class="keyword">as</span> theTime,</span><br><span class="line"><span class="keyword">case</span> m.isSend </span><br><span class="line">    <span class="keyword">when</span> <span class="number">0</span> <span class="keyword">then</span> r.nickname </span><br><span class="line">    <span class="keyword">when</span> <span class="number">1</span> <span class="keyword">then</span> <span class="string">'我'</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">as</span> person, m.content </span><br><span class="line"><span class="keyword">from</span> message m <span class="keyword">inner</span> <span class="keyword">join</span> rcontact r </span><br><span class="line"><span class="keyword">on</span> m.talker = r.username </span><br><span class="line"><span class="keyword">where</span> m.type = <span class="number">1</span> <span class="keyword">and</span> r.nickname = <span class="string">'对方微信昵称'</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> theTime;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.imwxz.com/guide/134.html" rel="external nofollow noopener noreferrer" target="_blank">免root提取微信聊天记录数据库</a></li><li><a href="https://www.shixuen.com/android/weixin.html" rel="external nofollow noopener noreferrer" target="_blank">手机微信聊天记录的解密与恢复</a></li><li><a href="https://godweiyang.com/2019/08/09/wechat-explore/" rel="external nofollow noopener noreferrer" target="_blank">微信聊天记录导出为电脑txt文件教程</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;我们知道，微信的聊天记录是加密的，因而我们不能从文件中直接查看、导出。本文主要介绍如何把聊天记录解密、导出成SQL或csv文件。&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
      <category term="软件" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="微信" scheme="https://tding.top/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="sqlcipher" scheme="https://tding.top/tags/sqlcipher/"/>
    
      <category term="Android" scheme="https://tding.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Python requests在HTTP2.0下的问题</title>
    <link href="https://tding.top/archives/9bd92731.html"/>
    <id>https://tding.top/archives/9bd92731.html</id>
    <published>2019-12-17T14:32:15.000Z</published>
    <updated>2019-12-17T14:38:43.234Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>今天在用Python中的requests包爬数据时，发现了一个很特殊的请求头，其中有<code>:authority</code>、<code>:method</code>、<code>:path</code>、<code>:scheme</code>这几个参数，这些参数说明这个网站用了HTTP2.0。然后我发现我们不能用requests包直接构造请求头进行爬取了。本文简单分析并解决这个问题。</p><a id="more"></a><blockquote><p>HTTP2.0：请求/响应首部的定义基本没有改变，只是所有首部键必须全部小写，而且请求行要独立为<code>:method</code>、<code>:scheme</code>、<code>:host</code>、<code>:path</code>这些键值对。</p></blockquote><p>如果我们按照以前的设置构造headers进行爬取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">"https://xxxxxx.com/tag/xxxx/page/1.html"</span></span><br><span class="line">headers = &#123;<span class="string">':authority'</span>: <span class="string">'xxxxxx.com'</span>,</span><br><span class="line">           <span class="string">':method'</span>: <span class="string">'GET'</span>,</span><br><span class="line">           <span class="string">':path'</span>: <span class="string">'/tag/xxxx/page/1'</span>,</span><br><span class="line">           <span class="string">':scheme'</span>: <span class="string">'https'</span>,</span><br><span class="line">           <span class="string">'accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'</span>,</span><br><span class="line">           <span class="string">'accept-encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">           <span class="string">'accept-language'</span>: <span class="string">'zh-CN,zh;q=0.9,en;q=0.8'</span>,</span><br><span class="line">           <span class="string">'Sec-Fetch-Mode'</span>:<span class="string">'navigate'</span>,</span><br><span class="line">           <span class="string">'Sec-Fetch-Site'</span>:<span class="string">'none'</span>,</span><br><span class="line">           <span class="string">'Sec-Fetch-User'</span>:<span class="string">'?1'</span>,</span><br><span class="line">           <span class="string">'Upgrade-Insecure-Requests'</span>:<span class="string">'1'</span>,</span><br><span class="line">           <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'</span>&#125;</span><br><span class="line"></span><br><span class="line">requests.get(url = url, headers = headers)</span><br></pre></td></tr></table></figure><p>会报出以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: Invalid header name b&apos;:authority&apos;</span><br></pre></td></tr></table></figure><p>这是因为HTTP的请求头不能以分号开头。源码不能解析这样的请求头，具体可以见<a href="https://github.com/python/cpython/blob/master/Lib/http/client.py#L1196" rel="external nofollow noopener noreferrer" target="_blank">源码</a>。</p><p>我们可以使用hyper这个第三方包来解决这个问题，我们将代码改写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hyper.contrib <span class="keyword">import</span> HTTP20Adapter</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://xxxxxx.com/tag/xxxx/page/1.html"</span></span><br><span class="line">headers = &#123;<span class="string">':authority'</span>: <span class="string">'xxxxxx.com'</span>,</span><br><span class="line">           <span class="string">':method'</span>: <span class="string">'GET'</span>,</span><br><span class="line">           <span class="string">':path'</span>: <span class="string">'/tag/xxxx/page/1'</span>,</span><br><span class="line">           <span class="string">':scheme'</span>: <span class="string">'https'</span>,</span><br><span class="line">           <span class="string">'accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'</span>,</span><br><span class="line">           <span class="string">'accept-encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">           <span class="string">'accept-language'</span>: <span class="string">'zh-CN,zh;q=0.9,en;q=0.8'</span>,</span><br><span class="line">           <span class="string">'Sec-Fetch-Mode'</span>:<span class="string">'navigate'</span>,</span><br><span class="line">           <span class="string">'Sec-Fetch-Site'</span>:<span class="string">'none'</span>,</span><br><span class="line">           <span class="string">'Sec-Fetch-User'</span>:<span class="string">'?1'</span>,</span><br><span class="line">           <span class="string">'Upgrade-Insecure-Requests'</span>:<span class="string">'1'</span>,</span><br><span class="line">           <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'</span>&#125;</span><br><span class="line"></span><br><span class="line">sessions = requests.session()</span><br><span class="line">sessions.mount(<span class="string">'https://xxxx.com'</span>, HTTP20Adapter())</span><br><span class="line">response = sessions.get(url = url,headers = headers)</span><br></pre></td></tr></table></figure><p>OK，问题解决！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://stackoverflow.com/questions/51630571/http-headers-requests-python" rel="external nofollow noopener noreferrer" target="_blank">HTTP headers - Requests - Python</a></li><li><a href="https://www.jianshu.com/p/1335a518151f" rel="external nofollow noopener noreferrer" target="_blank">Python 请求头header在http/http2下的问题</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;今天在用Python中的requests包爬数据时，发现了一个很特殊的请求头，其中有&lt;code&gt;:authority&lt;/code&gt;、&lt;code&gt;:method&lt;/code&gt;、&lt;code&gt;:path&lt;/code&gt;、&lt;code&gt;:scheme&lt;/code&gt;这几个参数，这些参数说明这个网站用了HTTP2.0。然后我发现我们不能用requests包直接构造请求头进行爬取了。本文简单分析并解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://tding.top/categories/%E7%88%AC%E8%99%AB/"/>
    
      <category term="问题" scheme="https://tding.top/categories/%E7%88%AC%E8%99%AB/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="Python" scheme="https://tding.top/tags/Python/"/>
    
      <category term="爬虫" scheme="https://tding.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="requests" scheme="https://tding.top/tags/requests/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu内置的Python3.5安装pip模块</title>
    <link href="https://tding.top/archives/399c2726.html"/>
    <id>https://tding.top/archives/399c2726.html</id>
    <published>2019-12-16T14:55:30.000Z</published>
    <updated>2019-12-17T14:38:43.245Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>本文首先介绍了如何给Ubuntu16.04内置的Python3.5安装pip模块，然后扩展介绍了多版本Python安装对应pip以及对pip对应Python版本进行管理的方法。</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>当我想通过Ubuntu16.04内置的Python3.5的pip安装第三方包时，出现如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@VPS:/home<span class="comment"># python3 -m pip install numpy</span></span><br><span class="line">/usr/bin/python3: No module named pip</span><br></pre></td></tr></table></figure><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>从错误描述来看，pip包不存在。</p><p>我们知道：</p><ul><li>Debian软件管理器（<code>sudo apt-get install</code>）安装的package存放在 <code>/usr/lib/python2.7/dist-packages</code>目录中</li><li>Python软件管理器（<code>easy_install</code>和<code>pip</code>）安装的package存放在<code>/usr/local/lib/python2.7/dist-packages</code>目录中</li><li>手动从源代码安装的package会直接使用目录<code>site-packages</code></li></ul><p>然后我进入到以下目录，看下是否存在pip文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@VPS:/home<span class="comment"># cd /usr/local/lib/python3.5/dist-packages/</span></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.5/dist-packages<span class="comment"># ll</span></span><br><span class="line">total 8</span><br><span class="line">drwxrwsr-x 2 root staff 4096 Nov 14 08:10 ./</span><br><span class="line">drwxrwsr-x 3 root staff 4096 Nov 14 08:10 ../</span><br></pre></td></tr></table></figure><p>发现当前目录是空的，并没有pip，说明并没有装上pip，因此，我们需要<strong>手动安装pip</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">sudo python3.5 get-pip.py</span><br></pre></td></tr></table></figure><p><strong>注意：这里的Python3.5根据你Python的版本进行替换</strong>。</p><p>然后查看一下是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip -V</span><br></pre></td></tr></table></figure><p>显示下面说明安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip 19.3.1 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)</span><br></pre></td></tr></table></figure><p>然后我们就可以使用pip来安装别的包了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install XXX</span><br></pre></td></tr></table></figure><h2 id="pip版本管理"><a href="#pip版本管理" class="headerlink" title="pip版本管理"></a>pip版本管理</h2><p>首先我通过上面的方法安装了Python2.7的pip，此时查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python2.7/dist-packages<span class="comment"># pip -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/pip (python 2.7)</span><br><span class="line"></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python2.7/dist-packages<span class="comment"># pip2 -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/pip (python 2.7)</span><br></pre></td></tr></table></figure><p>然后我用同样的方法安装了Python3.5的pip，此时查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.5/dist-packages<span class="comment"># pip -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python3.5/dist-packages/pip (python 3.5)</span><br><span class="line"></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.5/dist-packages<span class="comment"># pip3 -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python3.5/dist-packages/pip (python 3.5)</span><br><span class="line"></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.5/dist-packages<span class="comment"># pip3.5 -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python3.5/dist-packages/pip (python 3.5)</span><br></pre></td></tr></table></figure><p>然后我用同样的方法安装了Python3.6的pip，此时查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.6/dist-packages<span class="comment"># pip -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python3.6/dist-packages/pip (python 3.6)</span><br><span class="line"></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.6/dist-packages<span class="comment"># pip3 -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python3.6/dist-packages/pip (python 3.6)</span><br><span class="line"></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.6/dist-packages<span class="comment"># pip3.5 -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python3.5/dist-packages/pip (python 3.5)</span><br><span class="line"></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.6/dist-packages<span class="comment"># pip3.6 -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python3.6/dist-packages/pip (python 3.6)</span><br></pre></td></tr></table></figure><p>我们发现，<strong>每次安装pip，它都会把默认pip对应的Python修改，导致pip对应版本混乱</strong>。</p><p>现在系统中安装了Python2.7、Python3.5、Python3.6。各个pip对应的Python版本如下：</p><ul><li><code>pip</code>对应<code>Python3.6</code></li><li><code>pip2</code>对应<code>Python2.7</code></li><li><code>pip3</code>对应<code>Python3.6</code></li><li><code>pip3.5</code>对应<code>Python3.5</code></li><li><code>pip3.6</code>对应<code>Python3.6</code></li></ul><p><strong>现在我们想要让<code>pip</code>对应<code>Python2.7</code>，让<code>pip3</code>对应<code>Python3.5</code></strong>。</p><p>然后我们进入到<code>/usr/local/bin</code>，发现里面有很多<code>pip</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@VPS:/usr/<span class="built_in">local</span>/lib/python3.6/dist-packages<span class="comment"># cd /usr/local/bin/</span></span><br><span class="line">root@VPS:/usr/<span class="built_in">local</span>/bin<span class="comment"># ll</span></span><br><span class="line">total 52</span><br><span class="line">drwxr-xr-x  2 root root 4096 Dec 15 03:37 ./</span><br><span class="line">drwxr-xr-x 10 root root 4096 Nov 14 08:09 ../</span><br><span class="line">-rwxr-xr-x  1 root root  232 Dec 15 03:37 easy_install*</span><br><span class="line">-rwxr-xr-x  1 root root  232 Dec 15 03:19 easy_install-2.7*</span><br><span class="line">-rwxr-xr-x  1 root root  232 Dec 15 03:20 easy_install-3.5*</span><br><span class="line">-rwxr-xr-x  1 root root  232 Dec 15 03:37 easy_install-3.6*</span><br><span class="line">-rwxr-xr-x  1 root root  219 Dec 15 03:37 pip*</span><br><span class="line">-rwxr-xr-x  1 root root  219 Dec 15 03:19 pip2*</span><br><span class="line">-rwxr-xr-x  1 root root  219 Dec 15 03:19 pip2.7*</span><br><span class="line">-rwxr-xr-x  1 root root  219 Dec 15 03:37 pip3*</span><br><span class="line">-rwxr-xr-x  1 root root  219 Dec 15 03:20 pip3.5*</span><br><span class="line">-rwxr-xr-x  1 root root  219 Dec 15 03:37 pip3.6*</span><br><span class="line">-rwxr-xr-x  1 root root  210 Dec 15 03:37 wheel*</span><br></pre></td></tr></table></figure><p>这些pip文件其实是Python脚本文件，我们可以用vim打开<code>pip</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3.6</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pip._internal.main <span class="keyword">import</span> main</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sys.argv[<span class="number">0</span>] = re.sub(<span class="string">r'(-script\.pyw|\.exe)?$'</span>, <span class="string">''</span>, sys.argv[<span class="number">0</span>])</span><br><span class="line">    sys.exit(main())</span><br></pre></td></tr></table></figure><p><strong>这个文件的第一行指定了这个脚本对应的Python版本，如果想把pip对应的Python版本改为2.7的，只需修改Python3.6为Python2.7即可</strong>。修改保存后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@VPS:/usr/<span class="built_in">local</span>/bin<span class="comment"># pip -V</span></span><br><span class="line">pip 19.3.1 from /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/pip (python 2.7)</span><br></pre></td></tr></table></figure><p>我们已经成功的把pip对应的Python版本改为了2.7，同理也可以修改pip3对应的版本。</p><p>注意：<strong>不同版本的pip对应的这个脚本文件的内容不同</strong>，上面显示的是<code>pip 19.3.1</code>版本的，其它版本的脚本文件内容可能与之不同。直接改这个脚本文件来修改pip对应的Python版本的前提是：当前脚本文件对应的Python版本与要修改对应的Python版本的pip包版本最好一致，不一致很可能出错。<strong>最简单的解决办法是都升级为最新的pip版本</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://stackoverflow.com/questions/9387928/whats-the-difference-between-dist-packages-and-site-packages" rel="external nofollow noopener noreferrer" target="_blank">What’s the difference between dist-packages and site-packages?</a></li><li><a href="https://zhuanlan.zhihu.com/p/37473690" rel="external nofollow noopener noreferrer" target="_blank">多版本Python安装pip及pip版本管理终极教程</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;本文首先介绍了如何给Ubuntu16.04内置的Python3.5安装pip模块，然后扩展介绍了多版本Python安装对应pip以及对pip对应Python版本进行管理的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://tding.top/categories/Python/"/>
    
      <category term="pip" scheme="https://tding.top/categories/Python/pip/"/>
    
    
      <category term="Python" scheme="https://tding.top/tags/Python/"/>
    
      <category term="pip" scheme="https://tding.top/tags/pip/"/>
    
      <category term="Ubuntu" scheme="https://tding.top/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Hexo配置Cloudflare免费CDN</title>
    <link href="https://tding.top/archives/12c6c559.html"/>
    <id>https://tding.top/archives/12c6c559.html</id>
    <published>2019-12-14T13:56:00.000Z</published>
    <updated>2019-12-14T12:44:33.880Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>由于 GitHub Pages 的服务器在国外，国内访问速度可能会非常慢。目前有以下几种解决方案：</p><ul><li>博客双线部署在GitHub Pages和Coding Pages上，其中国内流量解析到Coding Pages，国外流量解析到GitHub Pages<ul><li>优势：无需购买VPS、速度比较快、不用备案</li><li>劣势：Coding Pages的服务并不是那么稳定，近期出现多次不能正常部署或访问Pages的问题</li></ul></li><li>博客部署到国内的VPS<ul><li>优势：速度快</li><li>劣势：需要购买VPS、需要备案</li></ul></li><li>博客部署在GitHub Pages上并采用CDN加速<ul><li>优势：速度快、无需备案、稳定</li><li>劣势：CDN比较贵，hhh</li></ul></li></ul><p>本文主要介绍Hexo博客部署在GitHub Pages上并且配置CDN进行加速的方法。</p><p>这里我们假设博客已经部署在GitHub Pages并启用了个性域名。如果你还没有绑定个性域名，可以参考这篇教程：<a href="https://tding.top/archives/b48e2719.html">GitHub Pages 绑定域名</a>，其中域名服务器修改到DNSPod这部分可以不看，因为这里我们会用Cloudflare来完成域名解析。</p><a id="more"></a><h2 id="CDN介绍"><a href="#CDN介绍" class="headerlink" title="CDN介绍"></a>CDN介绍</h2><blockquote><p>内容分发网络（Content delivery network或Content distribution network，缩写：CDN）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p></blockquote><p>简单来说，CDN 就是部署在世界各地的缓存服务器，它们会提前缓存网站上的资源，然后当用户想要访问相关资源时，直接从 CDN 服务器上取就可以了。这样不仅可以增加访问速度减少访问延迟，还可以减缓网站服务器上的压力。</p><h2 id="为什么选择Cloudflare？"><a href="#为什么选择Cloudflare？" class="headerlink" title="为什么选择Cloudflare？"></a>为什么选择Cloudflare？</h2><p>国内的CDN服务提供商有不少，但是基本都需要备案，因此我转向了Cloudflare这个国外的CDN服务提供商。</p><p>Cloudflare 是全球最大的 DNS 服务提供商之一。除此之外他们还提供CDN、SSL证书、DDos保护等服务，并且 Cloudflare 与百度有合作，在国内也部署有大量的节点，还能顺便解决百度爬无法抓取 GitHub Pages 的问题。</p><h2 id="CDN配置"><a href="#CDN配置" class="headerlink" title="CDN配置"></a>CDN配置</h2><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><ol><li><p>首先要去 Cloudflare 注册一个帐号。<strong>注意：我们需要的是国际版的 CloudFlare，而不是 CloudFlare 与百度合作的百度云加速</strong>。</p></li><li><p>注册好后点击 <code>Add site</code> 添加你的网站个性化域名。</p></li><li><p>添加好后选择免费的那个计划（Plan），有钱也可以选择收费的，提供的服务更多。</p></li><li><p>然后点击 <code>Scan DNS Records</code>，等待扫描完成。即使没有扫到 DNS 记录也没有关系，我们可以在后面自己添加，我们只需要添加下图框起来的那两条：</p></li></ol><img src="/archives/12c6c559/DNS设置.png" title="DNS设置"><ol start="5"><li>然后 Cloudflare 会要你把你的 DNS 服务器替换成他提供的，我们只需要去域名商那里设置一下即可。<strong>CloudFlare 既是一个 CDN 服务商，同样也是一个 DNS 服务商</strong>。DNS修改完成后可以点击 <code>Recheck Nameservers</code> 来复查 NS 记录是否正确设置。</li></ol><p>然后过个几分钟，显示 <code>Great news! Cloudflare is now protecting your site</code> 就说明设置成功。</p><h3 id="Cloudflare设置详解"><a href="#Cloudflare设置详解" class="headerlink" title="Cloudflare设置详解"></a>Cloudflare设置详解</h3><h4 id="Overview菜单设置"><a href="#Overview菜单设置" class="headerlink" title="Overview菜单设置"></a>Overview菜单设置</h4><p>主要关注下面两个快捷设置：</p><ul><li><code>under attack mode</code>：当你的网站被攻击的时候打开它，这样可以阻止攻击。</li><li><code>development mode</code>：由于cloudflare采用了缓存技术，当你更新了网站的内容，不一定能马上在前台看到更新的内容。这个时候你只要打开development mode就可以马上看到网站更新的内容。当然，正常情况下还是关掉比较好。</li></ul><img src="/archives/12c6c559/Overview菜单设置.png" title="Overview菜单设置"><h4 id="Analytics菜单设置"><a href="#Analytics菜单设置" class="headerlink" title="Analytics菜单设置"></a>Analytics菜单设置</h4><p>这里主要是看网站使用cloudflare之后的一些分析数据，Analytics下面包含几个子菜单：Traffic、security、Performance、DNS。</p><ul><li>Traffic子菜单：主要是网站在过去某一个时间段的请求、带宽、访客情况。</li><li>Security子菜单：主要是某一段时间内受到的威胁数据，包括威胁次数、来自哪些国家、威胁的类型等等。</li><li>Performance子菜单：付费功能。</li><li>DNS子菜单：主要是DNS查询的数据。</li></ul><h4 id="DNS菜单设置"><a href="#DNS菜单设置" class="headerlink" title="DNS菜单设置"></a>DNS菜单设置</h4><p>在DNS菜单里面，你可以随意添加或删除所有DNS记录，也可以选择使用或不使用cloudflare的CDN服务。</p><p>注意：只有A记录和CNAME记录才可以设置使用CDN服务，我们只需要点亮<code>Proxy status</code>处的云彩小图标即可切换成使用CDN的状态。</p><h4 id="SSL-TLS菜单设置"><a href="#SSL-TLS菜单设置" class="headerlink" title="SSL/TLS菜单设置"></a>SSL/TLS菜单设置</h4><p>这里面主要是网站加密的设置。</p><ul><li><code>SSL</code>设置：如果你本来的网站有SSL证书，这里选择full即可，即浏览器到Cloudflare和Cloudflare到服务器都是加密的。</li><li><strong><code>Always Use HTTPS</code>设置：这个打开，一直使用https链接</strong>。</li><li><code>Authenticated Origin Pulls</code> &amp; <code>Opportunistic Encryption</code> &amp; <code>Onion Routing</code>设置：这些设置都打开</li><li><code>Minimum TLS Version</code>设置：选择1.1即可，如果选择太高可能导致网站打不开。</li></ul><h4 id="Firewall菜单设置"><a href="#Firewall菜单设置" class="headerlink" title="Firewall菜单设置"></a>Firewall菜单设置</h4><p>Firewall菜单里面可以对网站安全进一步设置，限制某些IP或地区的用户访问等。</p><ul><li>Events子菜单：这里面可以查看防火墙的一些小事件，比如屏蔽的一些访问。</li><li>Managed Rules子菜单：付费功能。</li><li>Firewall Rules子菜单：这里可以设置限制其他人访问你的网站的规则，每个账户只能设置5个限制规则。</li><li>TOOLS子菜单：这里的功能是firewall rules功能的补充，都是对用户访问你的网站的一些设置。<ul><li><code>IP Access Rules</code>：主要是针对IP、IP范围及国家和ASN设置一些规则。</li><li><code>User Agent Blocking</code>：对用户使用的代理设置规则，比如浏览器类型、CPU、操作系统。</li></ul></li><li>Settting子菜单：<ul><li><code>Security Level</code>：这个设置low即可，如果设置太高，就会过于敏感，导致很多用户受影响。</li><li><code>Challenge Passage</code>：这是验证的有效期，可以设置久一点，比如<code>1 hour</code>。</li><li><code>Browser Integrity Check</code> 和 <code>Privacy Pass Support</code>：全部打开。</li></ul></li></ul><h4 id="Speed菜单设置"><a href="#Speed菜单设置" class="headerlink" title="Speed菜单设置"></a>Speed菜单设置</h4><ul><li><code>Auto Minify</code>：网页最小化处理，把Javascript, css html前面都打勾即可。</li><li><code>Brotli</code>：这是一种比gzip更好的网页压缩方式，打开即可。</li><li><code>Rocket Loader</code>：这个需要测试决定是否需要打开，没有固定的答案，你可以打开之后，然后在不同的浏览器上面查看网页的效果，如果出现网页排版等问题，那就将它关闭。</li></ul><h4 id="Caching菜单设置"><a href="#Caching菜单设置" class="headerlink" title="Caching菜单设置"></a>Caching菜单设置</h4><ul><li><code>Purge Cache</code>：这个设置是清除缓存，其中：<ul><li><code>Custom Purge</code>：清除指定页面的缓存，我们可以点击<code>custom purge</code>, 然后在框里面输入要清除的链接，再点击<code>purge</code>即可。</li><li><code>Purge Everything</code>：清除整个网站的缓存。</li></ul></li><li><code>Caching Level</code>：缓存水平设置，决定缓存哪些内容，这里选择standard即可。</li><li><code>Browser Cache TTL</code>：即浏览器缓存过期时间，决定浏览器多久向网站获取一次新缓存。</li></ul><h4 id="Page-Rules菜单设置"><a href="#Page-Rules菜单设置" class="headerlink" title="Page Rules菜单设置"></a>Page Rules菜单设置</h4><p>免费版本可以设置3个页面的规则。</p><p>这里我们可以设置forwarding，也就是301跳转，比如我想要让<code>tding.me</code>整个站都跳转到<code>tding.top</code>，具体设置如下图：</p><img src="/archives/12c6c559/跳转设置.png" title="跳转设置"><p>注意：如果<code>Forwarding URL</code>设置为<code>https://tding.top</code>，当我们访问<code>tding.me/about.html</code>时会跳转到<code>https://tding.top</code>而不是我们期望的<code>https://tding.top/about.html</code>。解决办法就是使用<strong>变量</strong>，每个通配符对应于可在转发地址中引用的变量。变量用 <code>$</code> 后跟一个数字表示，如果要引用第一个通配符，我们可以使用 <code>$1</code>，如果要引用第二个通配符，我们可以使用 <code>$2</code>，依此类推。<strong>因此，<code>Forwarding URL</code>应该设置成<code>https://tding.top/$1</code></strong>。</p><h2 id="测速"><a href="#测速" class="headerlink" title="测速"></a>测速</h2><p>下面是Cloudflare CDN加速后（左图）于GitHub Pages本身（右图）的速度对比：</p><img src="/archives/12c6c559/测速.png" title="测速"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mogeko.me/2019/056/" rel="external nofollow noopener noreferrer" target="_blank">为博客添加免费的 CDN (Cloudflare)</a></li><li><a href="https://www.imhunk.com/cloudflare-tutorials/" rel="external nofollow noopener noreferrer" target="_blank">如何用CDN加速你的网站 – Cloudflare免费版详细使用教程</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;由于 GitHub Pages 的服务器在国外，国内访问速度可能会非常慢。目前有以下几种解决方案：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;博客双线部署在GitHub Pages和Coding Pages上，其中国内流量解析到Coding Pages，国外流量解析到GitHub Pages&lt;ul&gt;&lt;li&gt;优势：无需购买VPS、速度比较快、不用备案&lt;/li&gt;&lt;li&gt;劣势：Coding Pages的服务并不是那么稳定，近期出现多次不能正常部署或访问Pages的问题&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;博客部署到国内的VPS&lt;ul&gt;&lt;li&gt;优势：速度快&lt;/li&gt;&lt;li&gt;劣势：需要购买VPS、需要备案&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;博客部署在GitHub Pages上并采用CDN加速&lt;ul&gt;&lt;li&gt;优势：速度快、无需备案、稳定&lt;/li&gt;&lt;li&gt;劣势：CDN比较贵，hhh&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;本文主要介绍Hexo博客部署在GitHub Pages上并且配置CDN进行加速的方法。&lt;/p&gt;&lt;p&gt;这里我们假设博客已经部署在GitHub Pages并启用了个性域名。如果你还没有绑定个性域名，可以参考这篇教程：&lt;a href=&quot;https://tding.top/archives/b48e2719.html&quot;&gt;GitHub Pages 绑定域名&lt;/a&gt;，其中域名服务器修改到DNSPod这部分可以不看，因为这里我们会用Cloudflare来完成域名解析。&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
      <category term="Hexo" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://tding.top/tags/Hexo/"/>
    
      <category term="GitHub Pages" scheme="https://tding.top/tags/GitHub-Pages/"/>
    
      <category term="CDN" scheme="https://tding.top/tags/CDN/"/>
    
      <category term="Cloudflare" scheme="https://tding.top/tags/Cloudflare/"/>
    
  </entry>
  
  <entry>
    <title>R数据可视化-相关矩阵热力图</title>
    <link href="https://tding.top/archives/7fa1138e.html"/>
    <id>https://tding.top/archives/7fa1138e.html</id>
    <published>2019-12-12T15:30:00.000Z</published>
    <updated>2019-12-12T15:39:02.981Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>在数据分析时，我们经常需要看变量之间的相关性，一般采用相关矩阵热力图进行可视化，而ggplot2本身不能直接绘制热图，因此我们需要做数据变换把相关矩阵转换为一个3列的数据框（变量名Var1、变量名Var2、数值value），然后再分别映射给x、y和fill参数，绘制出热力图。</p><a id="more"></a><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><p>这里我用的是ggplot2内置的mtcars数据集：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- mtcars[, c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)]</span><br><span class="line">head(df)</span><br></pre></td></tr></table></figure><p>这个数据前6行为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                   mpg disp  hp drat    wt  qsec</span><br><span class="line">Mazda RX4         21.0  160 110 3.90 2.620 16.46</span><br><span class="line">Mazda RX4 Wag     21.0  160 110 3.90 2.875 17.02</span><br><span class="line">Datsun 710        22.8  108  93 3.85 2.320 18.61</span><br><span class="line">Hornet 4 Drive    21.4  258 110 3.08 3.215 19.44</span><br><span class="line">Hornet Sportabout 18.7  360 175 3.15 3.440 17.02</span><br><span class="line">Valiant           18.1  225 105 2.76 3.460 20.22</span><br></pre></td></tr></table></figure><p>然后计算相关矩阵：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">round(cor(df), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       mpg  disp    hp  drat    wt  qsec</span><br><span class="line">mpg   1.00 -0.85 -0.78  0.68 -0.87  0.42</span><br><span class="line">disp -0.85  1.00  0.79 -0.71  0.89 -0.43</span><br><span class="line">hp   -0.78  0.79  1.00 -0.45  0.66 -0.71</span><br><span class="line">drat  0.68 -0.71 -0.45  1.00 -0.71  0.09</span><br><span class="line">wt   -0.87  0.89  0.66 -0.71  1.00 -0.17</span><br><span class="line">qsec  0.42 -0.43 -0.71  0.09 -0.17  1.00</span><br></pre></td></tr></table></figure><p>然后我用reshape2包中的<code>melt()</code>函数将这个相关矩阵转换为3列的数据框格式：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_cor &lt;- round(cor(df), <span class="number">2</span>)</span><br><span class="line">melt(df_cor)</span><br></pre></td></tr></table></figure><p>下面是输出的前6行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  Var1 Var2 value</span><br><span class="line">1  mpg  mpg  1.00</span><br><span class="line">2 disp  mpg -0.85</span><br><span class="line">3   hp  mpg -0.78</span><br><span class="line">4 drat  mpg  0.68</span><br><span class="line">5   wt  mpg -0.87</span><br><span class="line">6 qsec  mpg  0.42</span><br></pre></td></tr></table></figure><h2 id="相关矩阵热力图绘制"><a href="#相关矩阵热力图绘制" class="headerlink" title="相关矩阵热力图绘制"></a>相关矩阵热力图绘制</h2><h3 id="基本相关矩阵热力图绘制"><a href="#基本相关矩阵热力图绘制" class="headerlink" title="基本相关矩阵热力图绘制"></a>基本相关矩阵热力图绘制</h3><p>前面我们已经得到了3列的数据框（变量名Var1、变量名Var2、数值value），现在我们只需要将它们分别映射给x、y和fill参数，就能够绘制出热力图。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df_cor &lt;- round(cor(df), <span class="number">2</span>) </span><br><span class="line">df_cor %&gt;%</span><br><span class="line">    melt() %&gt;%</span><br><span class="line">    ggplot(aes(x = Var1, y = Var2, fill = value)) + </span><br><span class="line">    geom_tile()</span><br></pre></td></tr></table></figure><img src="/archives/7fa1138e/1.png" title="图1"><p>默认的绘图样式比较丑，也不太直观。</p><h3 id="相关矩阵的下三角绘制热力图"><a href="#相关矩阵的下三角绘制热力图" class="headerlink" title="相关矩阵的下三角绘制热力图"></a>相关矩阵的下三角绘制热力图</h3><p>相关矩阵具有冗余信息，因此，我们可以将其中的上三角部分设置为NA：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_cor &lt;- round(cor(df), <span class="number">2</span>)</span><br><span class="line">df_cor[upper.tri(df_cor)] &lt;- <span class="literal">NA</span></span><br></pre></td></tr></table></figure><p>下面是<code>df_cor</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       mpg  disp    hp  drat    wt  qsec</span><br><span class="line">mpg   1.00    NA    NA    NA    NA    NA</span><br><span class="line">disp -0.85  1.00    NA    NA    NA    NA</span><br><span class="line">hp   -0.78  0.79  1.00    NA    NA    NA</span><br><span class="line">drat  0.68 -0.71 -0.45  1.00    NA    NA</span><br><span class="line">wt   -0.87  0.89  0.66 -0.71  1.00    NA</span><br><span class="line">qsec  0.42 -0.43 -0.71  0.09 -0.17  1.00</span><br></pre></td></tr></table></figure><p>下面绘制热力图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相关矩阵的上三角-左图</span></span><br><span class="line">df_cor %&gt;% </span><br><span class="line">    melt(na.rm = <span class="literal">TRUE</span>) %&gt;%</span><br><span class="line">    ggplot(aes(x = Var1, y = Var2, fill = value)) + </span><br><span class="line">    geom_tile()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相关矩阵的上三角+颜色标度+样式美化-右图</span></span><br><span class="line">df_cor %&gt;% </span><br><span class="line">    melt(na.rm = <span class="literal">TRUE</span>) %&gt;%</span><br><span class="line">    ggplot(aes(x = Var1, y = Var2, fill = value)) + </span><br><span class="line">    geom_tile() + </span><br><span class="line">    scale_fill_gradient2(low = <span class="string">"blue"</span>, high = <span class="string">"red"</span>, mid = <span class="string">"white"</span>, midpoint = <span class="number">0</span>, limit = c(-<span class="number">1</span>,<span class="number">1</span>), space = <span class="string">"Lab"</span>, name=<span class="string">"Pearson\nCorrelation"</span>) + </span><br><span class="line">    coord_fixed()</span><br></pre></td></tr></table></figure><img src="/archives/7fa1138e/2.png" title="图2"><ul><li><code>coord_fixed()</code>：使得x轴上的一个单位与y轴上的一个单位的长度相同。</li></ul><h3 id="相关矩阵重新排序"><a href="#相关矩阵重新排序" class="headerlink" title="相关矩阵重新排序"></a>相关矩阵重新排序</h3><p>我们可以根据相关系数对相关矩阵进行重新排序，这样可以更容易地识别矩阵中的隐藏模式。</p><p>下面我们用分层聚类<code>hclust()</code>函数对相关矩阵进行重新排序：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">df_cor &lt;- round(cor(df), <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 根据距离重新排序</span></span><br><span class="line">dd &lt;- as.dist((<span class="number">1</span> - df_cor)/<span class="number">2</span>)</span><br><span class="line">hc &lt;- hclust(dd)</span><br><span class="line">df_cor &lt;- df_cor[hc$order, hc$order]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上三角部分设置为NA</span></span><br><span class="line">df_cor[upper.tri(df_cor)] &lt;- <span class="literal">NA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 热力图绘制</span></span><br><span class="line">heatmap_1 &lt;- df_cor %&gt;% </span><br><span class="line">    melt(na.rm = <span class="literal">TRUE</span>) %&gt;%</span><br><span class="line">    ggplot(aes(x = Var1, y = Var2, fill = value)) + </span><br><span class="line">    geom_tile() + </span><br><span class="line">    scale_fill_gradient2(low = <span class="string">"blue"</span>, high = <span class="string">"red"</span>, mid = <span class="string">"white"</span>, midpoint = <span class="number">0</span>, limit = c(-<span class="number">1</span>,<span class="number">1</span>), space = <span class="string">"Lab"</span>, name=<span class="string">"Pearson\nCorrelation"</span>) + </span><br><span class="line">    coord_fixed()</span><br></pre></td></tr></table></figure><p>下面左图是相关矩阵未排序的热力图，右图是相关矩阵排序后的热力图：</p><img src="/archives/7fa1138e/3.png" title="图3"><h3 id="热力图上显示相关系数值"><a href="#热力图上显示相关系数值" class="headerlink" title="热力图上显示相关系数值"></a>热力图上显示相关系数值</h3><p>我们可以用<code>geom_text()</code>函数在热力图上<strong>添加相关系数值</strong>，这样更加直观。然后我可以把主题<code>theme()</code>设置为<strong>空白主题（删除轴标签、轴刻度、面板网格、背景）</strong>，最后改变图例位置。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 热力图上显示相关系数值-左图</span></span><br><span class="line">heatmap_1 + </span><br><span class="line">    geom_text(aes(Var1, Var2, label = value), color = <span class="string">"black"</span>, size = <span class="number">4</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 热力图上显示相关系数值+主题、图例美化-右图</span></span><br><span class="line">heatmap_1 + </span><br><span class="line">    geom_text(aes(Var1, Var2, label = value), color = <span class="string">"black"</span>, size = <span class="number">4</span>)  + </span><br><span class="line">    theme(</span><br><span class="line">        axis.title.x = element_blank(),</span><br><span class="line">        axis.title.y = element_blank(),</span><br><span class="line">        panel.grid.major = element_blank(),</span><br><span class="line">        panel.border = element_blank(),</span><br><span class="line">        panel.background = element_blank(),</span><br><span class="line">        axis.ticks = element_blank(),</span><br><span class="line">        legend.justification = c(<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">        legend.position = c(<span class="number">0.6</span>, <span class="number">0.7</span>),</span><br><span class="line">        legend.direction = <span class="string">"horizontal"</span></span><br><span class="line">    ) +</span><br><span class="line">    guides(fill = guide_colorbar(barwidth = <span class="number">7</span>, barheight = <span class="number">1</span>, title.position = <span class="string">"top"</span>, title.hjust = <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure><img src="/archives/7fa1138e/4.png" title="图4"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/zhouhucheng00/article/details/86143828" rel="external nofollow noopener noreferrer" target="_blank">数据可视化——R语言ggplot2包绘制相关矩阵为热图</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在数据分析时，我们经常需要看变量之间的相关性，一般采用相关矩阵热力图进行可视化，而ggplot2本身不能直接绘制热图，因此我们需要做数据变换把相关矩阵转换为一个3列的数据框（变量名Var1、变量名Var2、数值value），然后再分别映射给x、y和fill参数，绘制出热力图。&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
      <category term="热力图" scheme="https://tding.top/tags/%E7%83%AD%E5%8A%9B%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>ggplot2去除箱型图中的离群点</title>
    <link href="https://tding.top/archives/67c7ad2c.html"/>
    <id>https://tding.top/archives/67c7ad2c.html</id>
    <published>2019-12-12T06:30:00.000Z</published>
    <updated>2019-12-12T15:39:02.988Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>我们在用ggplot2的箱型图<code>boxplot()</code>可视化时会发现，部分特别异常的离群点导致箱型图自身被压缩的很扁，而我们一般更关注箱型图本身。因此，我们需要<strong>在不影响箱型图自身的分布的同时去除这些离群点</strong>。</p><a id="more"></a><h2 id="方法1——通过geom-boxplot-中的参数设置"><a href="#方法1——通过geom-boxplot-中的参数设置" class="headerlink" title="方法1——通过geom_boxplot()中的参数设置"></a>方法1——通过<code>geom_boxplot()</code>中的参数设置</h2><p>我们可以通过箱型图函数<code>geom_boxplot()</code>中的参数设置来不显示这些离群点：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geom_boxplot(outlier.shape = <span class="literal">NA</span>)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geom_boxplot(outlier.colour = <span class="literal">NA</span>)</span><br></pre></td></tr></table></figure><img src="/archives/67c7ad2c/1.png" title="图1"><p>但是这个方法不能满足我们的需求，这里虽然离群点都不再显示了，但是箱型图本身却没有被放大，没有达到我们的目的。</p><h2 id="方法2——通过位置标度设置"><a href="#方法2——通过位置标度设置" class="headerlink" title="方法2——通过位置标度设置"></a>方法2——通过位置标度设置</h2><p>我们可以通过位置标度函数<code>scale_y_continuous()</code>来改变y轴范围：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scale_y_continuous(limits = c(<span class="number">0</span>,<span class="number">2e+8</span>))</span><br></pre></td></tr></table></figure><img src="/archives/67c7ad2c/2.png" title="图2"><p>这个方法把处于范围外的数据点也删除了，然后在新设置的范围内重新计算绘图，这很可能会改变最后绘制的箱型图。这个方法也不能达到我们的目的。</p><h2 id="方法3——笛卡尔坐标系变换"><a href="#方法3——笛卡尔坐标系变换" class="headerlink" title="方法3——笛卡尔坐标系变换"></a>方法3——笛卡尔坐标系变换</h2><p>我们可以用笛卡尔坐标系变换函数<code>coord_trans()</code>对图进行放大：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coord_trans(x = <span class="string">"identity"</span>, y = <span class="string">"identity"</span>, limx = <span class="literal">NULL</span>, limy = c(<span class="number">0</span>,<span class="number">2e+8</span>))</span><br></pre></td></tr></table></figure><img src="/archives/67c7ad2c/3.png" title="图3"><p>这个方法比较完美的解决了我的问题。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;我们在用ggplot2的箱型图&lt;code&gt;boxplot()&lt;/code&gt;可视化时会发现，部分特别异常的离群点导致箱型图自身被压缩的很扁，而我们一般更关注箱型图本身。因此，我们需要&lt;strong&gt;在不影响箱型图自身的分布的同时去除这些离群点&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
      <category term="箱型图" scheme="https://tding.top/tags/%E7%AE%B1%E5%9E%8B%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>VPS上自建临时邮箱</title>
    <link href="https://tding.top/archives/73a8979d.html"/>
    <id>https://tding.top/archives/73a8979d.html</id>
    <published>2019-12-11T15:55:00.000Z</published>
    <updated>2019-12-11T16:04:30.278Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>当我们不想使用自己的真实邮箱，或者想批量注册账号的时候，就可以用<strong>临时搭建的即用即毁的邮箱系统</strong>。当我们通过IP或者域名访问这个临时邮箱系统时，系统会自动分配随机邮箱，收到新邮件后页面会自动刷新，页面关闭后邮件即丢失。</p><p>本文介绍的临时邮箱是<a href="https://github.com/denghongcai/forsaken-mail" rel="external nofollow noopener noreferrer" target="_blank">Forsaken Mail</a>，使用的是node.js。</p><a id="more"></a><h2 id="nodejs安装"><a href="#nodejs安装" class="headerlink" title="nodejs安装"></a>nodejs安装</h2><ul><li>系统版本：Ubuntu 16.04</li></ul><p>nodejs官方推荐安装方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure><p>确认nodejs版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><h2 id="安装Forsaken-Mail"><a href="#安装Forsaken-Mail" class="headerlink" title="安装Forsaken Mail"></a>安装Forsaken Mail</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>从GitHub下载Forsaken Mail源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/malaohu/forsaken-mail/archive/master.zip</span><br></pre></td></tr></table></figure><p>解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip master.zip</span><br></pre></td></tr></table></figure><p>下面我们用npm安装Forsaken Mail：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> forsaken-mail-master</span><br><span class="line">npm install &amp;&amp; npm start</span><br></pre></td></tr></table></figure><p>如果没有报错，服务器已经开启了。我们可以访问<code>VPS IP:3000</code>，看看是否正常工作。</p><h3 id="Forsaken-Mail在后台运行"><a href="#Forsaken-Mail在后台运行" class="headerlink" title="Forsaken Mail在后台运行"></a>Forsaken Mail在后台运行</h3><p>当我们关闭ssh窗口后，终端会收到 HUP（hangup）信号从而关闭其所有子进程，导致nodejs进程被关闭。下面我使用screen让nodejs在后台运行：</p><ol><li>启动一个名字为<code>mail</code>的screen：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S mail</span><br></pre></td></tr></table></figure><ol start="2"><li>启动Forsaken Mail</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><ol start="3"><li>回到前一个screen，当时在当前screen运行的程序不会停止</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + a + d</span><br></pre></td></tr></table></figure><ol start="4"><li>列出所有的screen</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -ls</span><br></pre></td></tr></table></figure><ol start="5"><li>回到我们建的名为mail的screen</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r mail</span><br></pre></td></tr></table></figure><p>screen的使用教程可以看：</p><ul><li><a href="https://tding.top/archives/97c310a3.html">Linux screen 使用技巧</a></li></ul><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>除了通过IP地址访问，还可以自定义邮箱域名，我们只需要在域名服务商的域名设置里面添加以下两条域名解析记录即可：</p><ul><li>添加MX记录：MX记录指向到自定义二级域名<code>mail.tding.top.</code>，其中主机记录设置为<code>@</code>，优先级设置10</li><li>添加A记录：A记录指向到服务器ip地址，其中主机记录设置为<code>mail</code></li></ul><p>域名解析设置见下图：</p><img src="/archives/73a8979d/域名解析.png" title="域名解析"><p>说明：<strong>MX记录的记录值的最后有一个点</strong>，代表主机名结束。在有些域名服务商网站设置的时候不会自动帮您加上，如果漏掉的话 DNS 服务器在解析的时候，会自动并上你的域名，这样会引起解析错误。</p><p>这样，我们可以通过<code>http://自定义域名:3000/</code>来访问临时邮箱了。</p><blockquote><p><strong>最后，欢迎大家用我搭建的临时邮箱来测试：<a href="http://mail.tding.top:3000" rel="external nofollow noopener noreferrer" target="_blank">邮箱地址</a></strong></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;当我们不想使用自己的真实邮箱，或者想批量注册账号的时候，就可以用&lt;strong&gt;临时搭建的即用即毁的邮箱系统&lt;/strong&gt;。当我们通过IP或者域名访问这个临时邮箱系统时，系统会自动分配随机邮箱，收到新邮件后页面会自动刷新，页面关闭后邮件即丢失。&lt;/p&gt;&lt;p&gt;本文介绍的临时邮箱是&lt;a href=&quot;https://github.com/denghongcai/forsaken-mail&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Forsaken Mail&lt;/a&gt;，使用的是node.js。&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
      <category term="软件" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="VPS" scheme="https://tding.top/tags/VPS/"/>
    
      <category term="临时邮箱" scheme="https://tding.top/tags/%E4%B8%B4%E6%97%B6%E9%82%AE%E7%AE%B1/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的KMS服务器激活Windows&amp;Office</title>
    <link href="https://tding.top/archives/1df8b972.html"/>
    <id>https://tding.top/archives/1df8b972.html</id>
    <published>2019-12-10T15:37:00.000Z</published>
    <updated>2019-12-11T16:04:12.873Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>KMS全称Key Management Service ，这个功能是在Windows Vista之后的产品中的一种新型产品激活机制，目的是为了Microsoft更好的遏制非法软件授权行为(盗版)。</p><p>我们知道，Windows XP和Server 2003要想避开激活机制的最好办法就是去下载VOL版或者MSDN的操作系统，只要输入正确的序列号，甚至有的根本不需要序列号，安装完以后也根本不用激活，并且只要运行一个脚本程序，一个免费的正版Windows就诞生了。为什么我们能这么容易的下载到MSDN或VOL版的XP和2003？其实Windows XP系列系统的MSDN版是Microsoft内部使用的系统，而VOL版是企业版，所以都不需要激活。然而这些版本最终被泄露，导致XP的盗版风无法停住，即使WGA也无能为力。但是从Windows Vista之后，Microsoft已吸取了这个教训，取消了Windows Vista及之后版本的VOL版，取而代之提供给批量激活的是利用KMS机制的Windows VL版本，遏制了不经微软激活服务器就进行激活的非法授权(盗版)行为。</p><p>由于Windows VL都是为批量激活而诞生，所以在一个激活单位中肯定会有很多台配置相等的计算机，并用一个服务器建立起一个局域网（LAN），而KMS正好利用这一点，它要求局域网中必须有一台KMS服务器，KMS服务器的作用是给局域网中的所有计算机的操作系统定周期(一般是180天)提供一个随机的激活ID(不同于产品激活密钥)，然后计算机里面的KMS服务就会自动将系统激活，实现正常的系统软件服务与操作。所以计算机必须保持与KMS服务器的定期连接，以便KMS激活服务的自动检查实现激活的自动续期，这样就实现了限制于公司域内的激活范围，避免了对于外界计算机的非法授权，当非法激活者离开公司域后，由于客户端KMS服务不能连接位于域内的KMS激活服务器，让它提供一个新的序列号，超过180天以后就会因为激活ID过期而重新回到试用版本状态，而合法授权者则能够定期获得ID更新，保持一直正确的激活状态。</p><a id="more"></a><h2 id="VPS安装KMS服务器"><a href="#VPS安装KMS服务器" class="headerlink" title="VPS安装KMS服务器"></a>VPS安装KMS服务器</h2><p>这里，我使用秋水逸冰开发的适用于三大 Linux 发行版的一键安装 KMS 服务的脚本在VPS上安装KMS服务器。</p><h3 id="本脚本适用环境"><a href="#本脚本适用环境" class="headerlink" title="本脚本适用环境"></a>本脚本适用环境</h3><ul><li>系统支持：CentOS 6+，Debian 7+，Ubuntu 12+</li><li>虚拟技术：任意</li><li>内存要求：≥128M</li></ul><h3 id="关于本脚本"><a href="#关于本脚本" class="headerlink" title="关于本脚本"></a>关于本脚本</h3><ol><li>本脚本适用于三大 Linux 发行版，其他版本则不支持。</li><li>KMS 服务安装完成后会加入开机自启动。</li><li>默认记录日志，其日志位于 <code>/var/log/vlmcsd.log</code>。</li></ol><h3 id="一键脚本安装方法"><a href="#一键脚本安装方法" class="headerlink" title="一键脚本安装方法"></a>一键脚本安装方法</h3><p>使用root用户登录，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/kms.sh &amp;&amp; chmod +x kms.sh &amp;&amp; ./kms.sh</span><br></pre></td></tr></table></figure><p>安装完成后，输入以下命令查看端口号 1688 的监听情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nxtlp | grep 1688</span><br></pre></td></tr></table></figure><p>返回值类似于如下这样就表示OK了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp        0      0 0.0.0.0:1688                0.0.0.0:*                   LISTEN      3200/vlmcsd         </span><br><span class="line">tcp        0      0 :::1688                     :::*                        LISTEN      3200/vlmcsd</span><br></pre></td></tr></table></figure><h3 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h3><ul><li>启动：<code>/etc/init.d/kms start</code></li><li>停止：<code>/etc/init.d/kms stop</code></li><li>重启：<code>/etc/init.d/kms restart</code></li><li>状态：<code>/etc/init.d/kms status</code></li></ul><h3 id="卸载方法"><a href="#卸载方法" class="headerlink" title="卸载方法"></a>卸载方法</h3><p>使用 root 用户登录，进入到<code>kms.sh</code>所在的目录下，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kms.sh uninstall</span><br></pre></td></tr></table></figure><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><h3 id="激活Windows"><a href="#激活Windows" class="headerlink" title="激活Windows"></a>激活Windows</h3><p>KMS 激活服务只能激活批量授权版 Windows (VOL 版)，无法激活零售版 Windows (Retail 版)。</p><p>以 Windows 10 Pro 为例 想要激活 VOL 版 Windows 10 pro，只需要用<strong>管理员权限</strong>打开一个 cmd，然后依次执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slmgr -upk</span><br><span class="line">slmgr -ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</span><br><span class="line">slmgr -skms IP:PORT</span><br><span class="line">slmgr -ato</span><br><span class="line">slmgr -dlv</span><br></pre></td></tr></table></figure><p>激活 Windows 8、Windows 7类似，只需要把上面的 KEY 替换一下即可。</p><p>注意：VOL 版本的镜像一般内置 GVLK key，用于 KMS 激活。如果你手动输过其他 key，那么这个内置的 key 就会被替换掉，这个时候如果你想用 KMS，那么就需要把 GVLK key 输回去。具体的KEY见后面的附录。</p><p>如果不知道自己的系统是什么版本，可以运行以下命令查看系统版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic os get caption</span><br></pre></td></tr></table></figure><p>我们得到对应key之后，使用管理员权限运行cmd执行安装key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slmgr -ipk xxxxx-xxxxx-xxxxx-xxxxx</span><br></pre></td></tr></table></figure><h3 id="激活Office"><a href="#激活Office" class="headerlink" title="激活Office"></a>激活Office</h3><p>KMS 激活服务只能激活 VOL 版的 Office，不过零售版的 Office 可以通过脚本转换为 VOL 版。</p><p>如果不知道自己安装的是什么版本的 Office，可以使用这个方法查看：</p><blockquote><p><strong>判断你安装的 Office 是哪个版本</strong>：</p><p>以<strong>管理员权限</strong>打开一个 cmd，<strong>进入Office的安装目录</strong>，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cscript ospp.vbs /dstatus</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果输出的信息中包含下面这句话说明你安装的是零售版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; LICENSE DESCRIPTION: Office 15, RETAIL(Grace) channel</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果输出的信息中包含下面这句话说明你安装的是批量授权版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; LICENSE DESCRIPTION: Office 15, VOLUME_KMSCLIENT channel</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>激活 Office 的关键在于找到 <code>ospp.vbs</code> 这个文件。<code>ospp.vbs</code> 一般在 Office 的安装目录里。 Office 2016 的默认安装目录是：<code>C:\Program Files\Microsoft Office\Office16</code>。 以<strong>管理员权限</strong>打开一个cmd，然后执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">"C:\Program Files\Microsoft Office\Office16"</span></span><br></pre></td></tr></table></figure><p>如果你系统是 64 位的但 Office 安装的是 32 位的，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">"C:\Program Files (x86)\Microsoft Office\Office16"</span></span><br></pre></td></tr></table></figure><p>这样我们就进入到Office的安装目录，然后输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cscript ospp.vbs /sethst:IP:PORT</span><br><span class="line">cscript ospp.vbs /act</span><br></pre></td></tr></table></figure><h2 id="附录-Office-Visio-Project下载"><a href="#附录-Office-Visio-Project下载" class="headerlink" title="附录-Office_Visio_Project下载"></a>附录-Office_Visio_Project下载</h2><blockquote><p>下载地址：链接: <a href="https://pan.baidu.com/s/1i6Tx4DB" rel="external nofollow noopener noreferrer" target="_blank">https://pan.baidu.com/s/1i6Tx4DB</a> 密码: 5t1i</p></blockquote><p>本光盘集成了以下程序：</p><ul><li>Microsoft Office 专业增强版 2016 （简体中文）</li><li>Microsoft Project Professional 2016 （简体中文）</li><li>Microsoft Visio 专业版 2016 （简体中文）</li></ul><p>以上程序均为VL版本。</p><p>下载后务必校验镜像hash，否则可能会造成你的安装出错：</p><p>64位版本：<a href="mailto:`X64_OVP@03K.OR" rel="external nofollow noopener noreferrer" target="_blank">`X64_OVP@03K.OR</a>G_17.11.iso`</p><ul><li>大小：3.03 GB</li><li>CRC-32: e86507f9</li><li>MD4: 7f920801005b2fbca6bc3eee9518cac4</li><li>MD5: a5b85d589a949b4d0e419424d14e1be2</li><li>SHA-1: 8e991e451fcc4c31c1515cd2c5470bfaf2380317</li></ul><p>32位版本：<a href="mailto:`X86_OVP@03K.OR" rel="external nofollow noopener noreferrer" target="_blank">`X86_OVP@03K.OR</a>G_17.11.iso`</p><ul><li>大小：1.54 GB</li><li>CRC-32: 4ed2dadd</li><li>MD4: 9d74cc7dc2cd4363b30a4390d884eca4</li><li>MD5: f1bee496870a071692b231418f55848e</li><li>SHA-1: 3167a81e2fb16262bd10506d234e40ab494fd970</li></ul><blockquote><p>Hash校验插件：</p><ul><li><a href="http://implbits.com/products/hashtab/" rel="external nofollow noopener noreferrer" target="_blank">HashTab</a></li><li><a href="http://code.kliu.org/hashcheck/" rel="external nofollow noopener noreferrer" target="_blank">HashCheck Shell Extension</a></li></ul><p>这两款插件安装即可使用，只需要选中一个或多个文件，然后右键查看属性，其中就会有“Hashtab”、“文件校验”标签，非常方便。</p></blockquote><h2 id="附录-KEY"><a href="#附录-KEY" class="headerlink" title="附录-KEY"></a>附录-KEY</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h4 id="Windows-10-版本-1803"><a href="#Windows-10-版本-1803" class="headerlink" title="Windows 10 版本 1803"></a>Windows 10 版本 1803</h4><table><thead><tr><th>操作系统版本</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Windows 10 教育版</td><td>NW6C2-QMPVW-D7KKK-3GKT6-VCFB2</td></tr><tr><td>Windows 10 教育版 N</td><td>2WH4N-8QGBV-H22JP-CT43Q-MDWWJ</td></tr><tr><td>Windows 10 企业版</td><td>NPPR9-FWDCX-D2C8J-H872K-2YT43</td></tr><tr><td>Windows 10 企业版 G</td><td>YYVX9-NTFWV-6MDM3-9PT4T-4M68B</td></tr><tr><td>Windows 10 企业版 G N</td><td>44RPN-FTY23-9VTTB-MP9BX-T84FV</td></tr><tr><td>Windows 10 企业版 N</td><td>DPH2V-TTNVB-4X9Q3-TJR4H-KHJW4</td></tr><tr><td>Windows 10 专业版</td><td>W269N-WFGWX-YVC9B-4J6C9-T83GX</td></tr><tr><td>Windows 10 专业教育版</td><td>6TP4R-GNPTD-KYYHQ-7B7DP-J447Y</td></tr><tr><td>Windows 10 专业教育版 N</td><td>YVWGF-BXNMC-HTQYQ-CPQ99-66QFC</td></tr><tr><td>Windows 10 专业版 N</td><td>MH37W-N47XK-V7XM9-C7227-GCQG9</td></tr><tr><td>Windows 10 Professional Workstation</td><td>NRG8B-VKK3Q-CXVCJ-9G2XF-6Q84J</td></tr><tr><td>Windows 10 Professional Workstation N</td><td>9FNHH-K3HBT-3W4TD-6383H-6XYWF</td></tr></tbody></table><h4 id="Windows-10-版本-1709"><a href="#Windows-10-版本-1709" class="headerlink" title="Windows 10 版本 1709"></a>Windows 10 版本 1709</h4><table><thead><tr><th>操作系统版本</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Windows 10 Professional Workstation</td><td>NRG8B-VKK3Q-CXVCJ-9G2XF-6Q84J</td></tr><tr><td>Windows 10 Professional Workstation N</td><td>9FNHH-K3HBT-3W4TD-6383H-6XYWF</td></tr></tbody></table><h4 id="Windows-10"><a href="#Windows-10" class="headerlink" title="Windows 10"></a>Windows 10</h4><table><thead><tr><th>操作系统版本</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Windows 10 专业版</td><td>W269N-WFGWX-YVC9B-4J6C9-T83GX</td></tr><tr><td>Windows 10 专业版 N</td><td>MH37W-N47XK-V7XM9-C7227-GCQG9</td></tr><tr><td>Windows 10 企业版</td><td>NPPR9-FWDCX-D2C8J-H872K-2YT43</td></tr><tr><td>Windows 10 企业版 N</td><td>DPH2V-TTNVB-4X9Q3-TJR4H-KHJW4</td></tr><tr><td>Windows 10 教育版</td><td>NW6C2-QMPVW-D7KKK-3GKT6-VCFB2</td></tr><tr><td>Windows 10 教育版 N</td><td>2WH4N-8QGBV-H22JP-CT43Q-MDWWJ</td></tr><tr><td>Windows 10 企业版 2015 长期服务</td><td>WNMTR-4C88C-JK8YV-HQ7T2-76DF9</td></tr><tr><td>Windows 10 企业版 2015 长期服务 N</td><td>2F77B-TNFGY-69QQF-B8YKP-D69TJ</td></tr><tr><td>Windows 10 企业版 2016 长期服务</td><td>DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJ</td></tr><tr><td>Windows 10 企业版 2016 长期服务 N</td><td>QFFDN-GRT3P-VKWWX-X7T3R-8B639</td></tr></tbody></table><h4 id="Windows-7-和-Windows-Server-2008-R2"><a href="#Windows-7-和-Windows-Server-2008-R2" class="headerlink" title="Windows 7 和 Windows Server 2008 R2"></a>Windows 7 和 Windows Server 2008 R2</h4><table><thead><tr><th>操作系统版本</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Windows 7 专业版</td><td>FJ82H-XT6CR-J8D7P-XQJJ2-GPDD4</td></tr><tr><td>Windows 7 专业版 N</td><td>MRPKT-YTG23-K7D7T-X2JMM-QY7MG</td></tr><tr><td>Windows 7 专业版 E</td><td>W82YF-2Q76Y-63HXB-FGJG9-GF7QX</td></tr><tr><td>Windows7 企业版</td><td>33PXH-7Y6KF-2VJC9-XBBR8-HVTHH</td></tr><tr><td>Windows 7 企业版 N</td><td>YDRBP-3D83W-TY26F-D46B2-XCKRJ</td></tr><tr><td>Windows 7 企业版 E</td><td>C29WB-22CC8-VJ326-GHFJW-H9DH4</td></tr><tr><td>Windows Server 2008 R2 Web 版</td><td>6TPJF-RBVHG-WBW2R-86QPH-6RTM4</td></tr><tr><td>Windows Server 2008 R2 HPC 版</td><td>TT8MH-CG224-D3D7Q-498W2-9QCTX</td></tr><tr><td>WindowsServer 2008 R2 Standard</td><td>YC6KT-GKW9T-YTKYR-T4X34-R7VHC</td></tr><tr><td>WindowsServer 2008 R2 企业版</td><td>489J6-VHDMP-X63PK-3K798-CPX3Y</td></tr><tr><td>WindowsServer 2008 R2 Datacenter</td><td>74YFP-3QFB3-KQT8W-PMXWJ-7M648</td></tr><tr><td>面向基于 Itanium 系统的 Windows Server 2008 R2</td><td>GT63C-RJFQ3-4GMB6-BRFB9-CB83V</td></tr></tbody></table><h3 id="Office"><a href="#Office" class="headerlink" title="Office"></a>Office</h3><h4 id="Office-2016"><a href="#Office-2016" class="headerlink" title="Office 2016"></a>Office 2016</h4><table><thead><tr><th>产品</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Office Professional Plus 2016</td><td>XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99</td></tr><tr><td>Office Standard 2016</td><td>JNRGM-WHDWX-FJJG3-K47QV-DRTFM</td></tr><tr><td>Project Professional 2016</td><td>YG9NW-3K39V-2T3HJ-93F3Q-G83KT</td></tr><tr><td>Project Standard 2016</td><td>GNFHQ-F6YQM-KQDGJ-327XX-KQBVC</td></tr><tr><td>Visio Professional 2016</td><td>PD3PC-RHNGV-FXJ29-8JK7D-RJRJK</td></tr><tr><td>Visio Standard 2016</td><td>7WHWN-4T7MP-G96JF-G33KR-W8GF4</td></tr><tr><td>Access 2016</td><td>GNH9Y-D2J4T-FJHGG-QRVH7-QPFDW</td></tr><tr><td>Excel 2016</td><td>9C2PK-NWTVB-JMPW8-BFT28-7FTBF</td></tr><tr><td>OneNote 2016</td><td>DR92N-9HTF2-97XKM-XW2WJ-XW3J6</td></tr><tr><td>Outlook 2016</td><td>R69KK-NTPKF-7M3Q4-QYBHW-6MT9B</td></tr><tr><td>PowerPoint 2016</td><td>J7MQP-HNJ4Y-WJ7YM-PFYGF-BY6C6</td></tr><tr><td>Publisher 2016</td><td>F47MM-N3XJP-TQXJ9-BP99D-8837K</td></tr><tr><td>Skype for Business 2016</td><td>869NQ-FJ69K-466HW-QYCP2-DDBV6</td></tr><tr><td>Word 2016</td><td>WXY84-JN2Q9-RBCCQ-3Q3J3-3PFJ6</td></tr></tbody></table><h4 id="Office-2013"><a href="#Office-2013" class="headerlink" title="Office 2013"></a>Office 2013</h4><table><thead><tr><th>产品</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Office 2013 Professional Plus</td><td>YC7DK-G2NP3-2QQC3-J6H88-GVGXT</td></tr><tr><td>Office 2013 Standard</td><td>KBKQT-2NMXY-JJWGP-M62JB-92CD4</td></tr><tr><td>Project 2013 Professional</td><td>FN8TT-7WMH6-2D4X9-M337T-2342K</td></tr><tr><td>Project 2013 Standard</td><td>6NTH3-CW976-3G3Y2-JK3TX-8QHTT</td></tr><tr><td>Visio 2013 Professional</td><td>C2FG9-N6J68-H8BTJ-BW3QX-RM3B3</td></tr><tr><td>Visio 2013 Standard</td><td>J484Y-4NKBF-W2HMG-DBMJC-PGWR7</td></tr><tr><td>Access 2013</td><td>NG2JY-H4JBT-HQXYP-78QH9-4JM2D</td></tr><tr><td>Excel 2013</td><td>VGPNG-Y7HQW-9RHP7-TKPV3-BG7GB</td></tr><tr><td>InfoPath 2013</td><td>DKT8B-N7VXH-D963P-Q4PHY-F8894</td></tr><tr><td>Lync 2013</td><td>2MG3G-3BNTT-3MFW9-KDQW3-TCK7R</td></tr><tr><td>OneNote 2013</td><td>TGN6P-8MMBC-37P2F-XHXXK-P34VW</td></tr><tr><td>Outlook 2013</td><td>QPN8Q-BJBTJ-334K3-93TGY-2PMBT</td></tr><tr><td>PowerPoint 2013</td><td>4NT99-8RJFH-Q2VDH-KYG2C-4RD4F</td></tr><tr><td>Publisher 2013</td><td>PN2WF-29XG2-T9HJ7-JQPJR-FCXK4</td></tr><tr><td>Word 2013</td><td>6Q7VD-NX8JD-WJ2VH-88V73-4GBJ7</td></tr></tbody></table><h4 id="Office-2010"><a href="#Office-2010" class="headerlink" title="Office 2010"></a>Office 2010</h4><p>Office 套件：</p><table><thead><tr><th>产品</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Office Professional Plus 2010</td><td>VYBBJ-TRJPB-QFQRF-QFT4D-H3GVB</td></tr><tr><td>Office Standard 2010</td><td>V7QKV-4XVVR-XYV4D-F7DFM-8R6BM</td></tr><tr><td>Office Home and Business 2010</td><td>D6QFG-VBYP2-XQHM7-J97RH-VVRCK</td></tr></tbody></table><p>独立产品：</p><table><thead><tr><th>产品</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Access 2010</td><td>V7Y44-9T38C-R2VJK-666HK-T7DDX</td></tr><tr><td>Excel 2010</td><td>H62QG-HXVKF-PP4HP-66KMR-CW9BM</td></tr><tr><td>SharePoint Workspace 2010</td><td>QYYW6-QP4CB-MBV6G-HYMCJ-4T3J4</td></tr><tr><td>InfoPath 2010</td><td>K96W8-67RPQ-62T9Y-J8FQJ-BT37T</td></tr><tr><td>OneNote 2010</td><td>Q4Y4M-RHWJM-PY37F-MTKWH-D3XHX</td></tr><tr><td>Outlook 2010</td><td>7YDC2-CWM8M-RRTJC-8MDVC-X3DWQ</td></tr><tr><td>PowerPoint 2010</td><td>RC8FX-88JRY-3PF7C-X8P67-P4VTT</td></tr><tr><td>Project Professional 2010</td><td>YGX6F-PGV49-PGW3J-9BTGG-VHKC6</td></tr><tr><td>Project Standard 2010</td><td>4HP3K-88W3F-W2K3D-6677X-F9PGB</td></tr><tr><td>Publisher 2010</td><td>BFK7F-9MYHM-V68C7-DRQ66-83YTP</td></tr><tr><td>Word 2010</td><td>HVHB3-C6FV7-KQX9W-YQG79-CRY7T</td></tr></tbody></table><p>Visio：</p><table><thead><tr><th>产品</th><th>KMS 客户端安装密钥</th></tr></thead><tbody><tr><td>Visio Premium 2010</td><td>D9DWC-HPYVV-JGF4P-BTWQB-WX8BJ</td></tr><tr><td>Visio Professional 2010</td><td>7MCW8-VRQVK-G677T-PDJCM-Q8TCP</td></tr><tr><td>Visio Standard 2010</td><td>767HD-QGMWX-8QTDB-9G3R2-KHFGJ</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.keye.work/2018/07/24/kms.html" rel="external nofollow noopener noreferrer" target="_blank">KMS介绍</a></li><li><a href="https://mogeko.me/2018/017/" rel="external nofollow noopener noreferrer" target="_blank">本地搭建 KMS 激活服务</a></li><li><a href="https://teddysun.com/530.html" rel="external nofollow noopener noreferrer" target="_blank">一键安装KMS服务脚本</a></li><li><a href="https://03k.org/2016_ovp.html" rel="external nofollow noopener noreferrer" target="_blank">Office 2016_Visio_Project_VL多合一_集成补丁2017.11</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;KMS全称Key Management Service ，这个功能是在Windows Vista之后的产品中的一种新型产品激活机制，目的是为了Microsoft更好的遏制非法软件授权行为(盗版)。&lt;/p&gt;&lt;p&gt;我们知道，Windows XP和Server 2003要想避开激活机制的最好办法就是去下载VOL版或者MSDN的操作系统，只要输入正确的序列号，甚至有的根本不需要序列号，安装完以后也根本不用激活，并且只要运行一个脚本程序，一个免费的正版Windows就诞生了。为什么我们能这么容易的下载到MSDN或VOL版的XP和2003？其实Windows XP系列系统的MSDN版是Microsoft内部使用的系统，而VOL版是企业版，所以都不需要激活。然而这些版本最终被泄露，导致XP的盗版风无法停住，即使WGA也无能为力。但是从Windows Vista之后，Microsoft已吸取了这个教训，取消了Windows Vista及之后版本的VOL版，取而代之提供给批量激活的是利用KMS机制的Windows VL版本，遏制了不经微软激活服务器就进行激活的非法授权(盗版)行为。&lt;/p&gt;&lt;p&gt;由于Windows VL都是为批量激活而诞生，所以在一个激活单位中肯定会有很多台配置相等的计算机，并用一个服务器建立起一个局域网（LAN），而KMS正好利用这一点，它要求局域网中必须有一台KMS服务器，KMS服务器的作用是给局域网中的所有计算机的操作系统定周期(一般是180天)提供一个随机的激活ID(不同于产品激活密钥)，然后计算机里面的KMS服务就会自动将系统激活，实现正常的系统软件服务与操作。所以计算机必须保持与KMS服务器的定期连接，以便KMS激活服务的自动检查实现激活的自动续期，这样就实现了限制于公司域内的激活范围，避免了对于外界计算机的非法授权，当非法激活者离开公司域后，由于客户端KMS服务不能连接位于域内的KMS激活服务器，让它提供一个新的序列号，超过180天以后就会因为激活ID过期而重新回到试用版本状态，而合法授权者则能够定期获得ID更新，保持一直正确的激活状态。&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
      <category term="软件" scheme="https://tding.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Windows" scheme="https://tding.top/tags/Windows/"/>
    
      <category term="Office" scheme="https://tding.top/tags/Office/"/>
    
      <category term="KMS" scheme="https://tding.top/tags/KMS/"/>
    
  </entry>
  
  <entry>
    <title>R数据可视化-ggplot2的几何对象与统计变换</title>
    <link href="https://tding.top/archives/71d12648.html"/>
    <id>https://tding.top/archives/71d12648.html</id>
    <published>2019-12-10T04:30:00.000Z</published>
    <updated>2019-12-22T12:34:07.555Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><ul><li><strong>几何对象</strong>执行着图层的实际渲染，控制着生成的图像类型。<ul><li><code>geom_point()</code>将会生成散点图</li><li><code>geom_line()</code>将会生成折线图</li><li><code>geom_bar()</code>将会生成柱状图</li><li><code>geom_boxplot()</code>将会生成箱型图</li><li><code>geom_histogram()</code>将会生成直方图</li></ul></li><li><strong>统计变换</strong>通常以某种方式对数据信息进行汇总。<ul><li><code>stat_smooth()</code>添加光滑曲线</li></ul></li></ul><a id="more"></a><p><strong>任何一个ggplot2图层都包括stat和geom两部分，<code>stat_</code>和<code>geom_</code>是两种绘图方法这个说法是不对的</strong>，下面我们简单解释下。</p><p>举个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(rnorm(<span class="number">100</span>,<span class="number">14</span>,<span class="number">5</span>),rep(<span class="number">20</span>,<span class="number">20</span>)) </span><br><span class="line">y &lt;- c(rnorm(<span class="number">100</span>,<span class="number">14</span>,<span class="number">5</span>),rep(<span class="number">20</span>,<span class="number">20</span>))</span><br><span class="line">p &lt;- ggplot(data= <span class="literal">NULL</span>, aes(x = x, y = y))</span><br><span class="line">p &lt;- p + geom_point(color = <span class="string">"darkred"</span>)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/几何对象-1.png" title="几何对象-1"><p>我们查看码源会发现<code>geom_point()</code>这个几何对象的默认stat是<code>identity</code>，即不做任何统计变换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function (mapping = NULL, data = NULL, stat = &quot;identity&quot;, position = &quot;identity&quot;, </span><br><span class="line">    ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) </span><br><span class="line">&#123;</span><br><span class="line">    layer(data = data, mapping = mapping, stat = stat, geom = GeomPoint, </span><br><span class="line">        position = position, show.legend = show.legend, inherit.aes = inherit.aes, </span><br><span class="line">        params = list(na.rm = na.rm, ...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码我们可以发现，坐标<code>(20，20)</code>这个点的数据事实上有20个，但由于没做<strong>统计转换</strong>，<code>(20,20)</code>这个点被画了20次，因此我们看到的点其实是最后一次画的那个点。</p><p>因此，下面我们<strong>按照某一点出现的频率换算成大小</strong>（指定<code>stat = &quot;sum&quot;</code>）来作图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(rnorm(<span class="number">100</span>,<span class="number">14</span>,<span class="number">5</span>),rep(<span class="number">20</span>,<span class="number">20</span>)) </span><br><span class="line">y &lt;- c(rnorm(<span class="number">100</span>,<span class="number">14</span>,<span class="number">5</span>),rep(<span class="number">20</span>,<span class="number">20</span>))</span><br><span class="line">p &lt;- ggplot(data= <span class="literal">NULL</span>, aes(x = x, y = y))</span><br><span class="line">p &lt;- p + geom_point(color = <span class="string">"darkred"</span>,stat = <span class="string">"sum"</span>)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/几何对象-2.png" title="几何对象-2"><p>根据以上，我们可以发现一个单纯的<code>geom_point</code>里面也是带有<code>stat_</code>的，同样，我们也可以用<code>stat_sum</code>作为主函数来绘制这幅图，里面有参数<code>geom</code>，这里我们设置成<code>geom = “point”</code>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- c(rnorm(<span class="number">100</span>,<span class="number">14</span>,<span class="number">5</span>),rep(<span class="number">20</span>,<span class="number">20</span>)) </span><br><span class="line">y &lt;- c(rnorm(<span class="number">100</span>,<span class="number">14</span>,<span class="number">5</span>),rep(<span class="number">20</span>,<span class="number">20</span>))</span><br><span class="line">p &lt;- ggplot(data= <span class="literal">NULL</span>, aes(x = x, y = y))</span><br><span class="line">p &lt;- p + stat_sum(color = <span class="string">"darkred"</span>,geom = <span class="string">"point"</span>)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><p>画出来的图跟前面用<code>geom_point</code>函数是一样的。</p><p>因此，<strong>我们需要认识到<code>stat_</code>和<code>geom_</code>是两种绘图方法这个说法是不对的，其实它们是ggplot2每一个图层绘制都必须有的，是一个图层的一体两面</strong>。</p><p>下面简单介绍几个常用的绘图函数。</p><h2 id="geom-point-散点图"><a href="#geom-point-散点图" class="headerlink" title="geom_point()散点图"></a><code>geom_point()</code>散点图</h2><p>绘制散点图可以使用<code>geom_point()</code>函数，气泡图（bubble chart）也是一个散点图，只不过点的大小由一个变量（size）来控制。</p><p>散点图潜在的最大问题是过度绘图：当一个位置或相邻的位置上出现有多个点，就可能把点绘制在彼此之上，这会严重扭曲散点图的视觉外观，我们可以通过使点变得透明或者设置点的形状来解决该问题。</p><p><code>geom_point()</code>参数如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geom_point(mapping = <span class="literal">NULL</span>, data = <span class="literal">NULL</span>, stat = <span class="string">"identity"</span>, position = <span class="string">"identity"</span>, <span class="keyword">...</span>, na.rm = <span class="literal">FALSE</span>, show.legend = <span class="literal">NA</span>, inherit.aes = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p>这里我从数据集中随机选出了100个样本，作为一个小数据集：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让样本可重复</span></span><br><span class="line">set.seed(<span class="number">1410</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始数据的一个容量为100的随机样本</span></span><br><span class="line">dsmall &lt;- diamonds[sample(nrow(diamonds),<span class="number">100</span>),]</span><br></pre></td></tr></table></figure><p>下面是散点图的绘制：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = dsmall, mapping = aes(x = carat, y = price))</span><br><span class="line">p &lt;- p + geom_point(aes(color = color, size = cut), shape = <span class="number">19</span>, alpha = <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/散点图.png" title="散点图"><h2 id="geom-bar-柱状图"><a href="#geom-bar-柱状图" class="headerlink" title="geom_bar()柱状图"></a><code>geom_bar()</code>柱状图</h2><h3 id="离散单变量的柱状图"><a href="#离散单变量的柱状图" class="headerlink" title="离散单变量的柱状图"></a>离散单变量的柱状图</h3><p>明细数据集绘制柱状图-左图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = cut))</span><br><span class="line">p &lt;- p + geom_bar()</span><br></pre></td></tr></table></figure><p><code>geom_bar()</code>函数中的<code>stat</code>参数的默认值为<code>stat = &#39;count&#39;</code>，即观测数量，统计的是每个离散变量出现的频次。</p><p>汇总好的数据集绘制柱状图-右图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = cut, y = price))</span><br><span class="line">p &lt;- p + geom_bar(stat = <span class="string">"identity"</span>)</span><br></pre></td></tr></table></figure><p>我们只需要在<code>geom_bar()</code>中更改默认的<code>count</code>为<code>identity</code>就可以接受两个变量作图。</p><img src="/archives/71d12648/柱状图-离散单变量.png" title="柱状图-离散单变量"><h3 id="分组柱状图"><a href="#分组柱状图" class="headerlink" title="分组柱状图"></a>分组柱状图</h3><p>分组柱状图一共有三种展现形式，我们可以使用<code>position</code>参数调整：</p><ul><li>并排放置<code>position=&quot;dodge&quot;</code></li><li>堆叠<code>position=&quot;stack&quot;</code></li><li>填充比例<code>position=&quot;fill&quot;</code></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = cut,fill = color))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并排放置-左图</span></span><br><span class="line">p + geom_bar(position = <span class="string">"dodge"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆叠-中图</span></span><br><span class="line">p + geom_bar(position = <span class="string">"stack"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充比例-右图</span></span><br><span class="line">p + geom_bar(position = <span class="string">"fill"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/柱状图-分组柱状图.png" title="柱状图-分组柱状图"><h3 id="柱状图排序"><a href="#柱状图排序" class="headerlink" title="柱状图排序"></a>柱状图排序</h3><p>其实前面我们在画柱状图时，使用的变量并不规范，当横坐标是离散型变量时，<strong>x参数接的应该是一个因子型数据（factor）</strong>。</p><p>当x没有用因子型数据的时候，横轴可能会没有把所有的标签全标上，这表示把横轴当成连续性变量来看了，所以只标了一部分标签以表示大小关系。</p><p>同样的，fill也是作为离散分类变量，也应该接一个factor，我们可以看到不加时，图例是一个连续性渐变颜色的形式。</p><p>我们会发现，转化为因子型之后数据的排列方式，不是根据元素出现的前后顺序，而是<strong>按照首字母顺序</strong>。现在我们想让<strong>x轴按y轴数值大小排序</strong>。</p><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>我们可以自定义一个函数来实现柱子从高到低排列：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因子型数据，按照首字母排序-左图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = factor(cut)))</span><br><span class="line">p &lt;- p + geom_bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义函数</span></span><br><span class="line">reorder_size &lt;- <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  factor(x, levels = names(sort(table(x), decreasing = <span class="literal">TRUE</span>)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从高到低排序-右图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = reorder_size(cut)))</span><br><span class="line">p &lt;- p + geom_bar()</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/柱状图-排序.png" title="柱状图-排序"><h4 id="reorder-函数"><a href="#reorder-函数" class="headerlink" title="reorder()函数"></a>reorder()函数</h4><p><code>reorder()</code>函数用法：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reorder(x, X, FUN = mean, <span class="keyword">...</span>, order = is.ordered(x))</span><br></pre></td></tr></table></figure><ul><li><code>x</code>：因子型向量</li><li><code>X</code>：用来排序的数值型向量</li><li><code>FUN</code>：汇总数据的函数</li><li><code>...</code>：<code>FUN</code>的参数（可选）</li><li><code>order</code>：我们可以通过这个参数直接指定因子型向量的顺序</li></ul><p>按照x对X进行分组，对每一组组成的向量计算后面的函数，最后根据计算结果从小到大指定x中元素的顺序。</p><p>下面是<code>reorder()</code>实现柱子从高到低排列，结果和前面自定义函数是一样的：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(reorder(cut,rep(<span class="number">1</span>,length(cut)),sum)))</span><br><span class="line">p &lt;- p + geom_bar()</span><br></pre></td></tr></table></figure><p>我们可以根据cut对一个全是1的向量分组求和（相当于计算了cut中每一个元素出现的个数），再根据求和结果指定顺序。</p><h3 id="柱状图添加标签文字"><a href="#柱状图添加标签文字" class="headerlink" title="柱状图添加标签文字"></a>柱状图添加标签文字</h3><p>我们可以使用<code>geom_text()</code>为柱状图添加文本，显示柱状图的高度，并调整文本的位置和大小。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = factor(cut),fill = color))</span><br><span class="line">p &lt;- p + geom_bar(position = <span class="string">"fill"</span>)</span><br><span class="line">p &lt;- p + geom_text(stat = <span class="string">"count"</span>,mapping = aes(label = ..count..), size = <span class="number">5</span>, colour = <span class="string">'white'</span>, vjust = <span class="number">1</span>, hjust = <span class="number">.5</span>, position = position_fill(<span class="number">0.9</span>))</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/柱状图-标签文字.png" title="柱状图-标签文字"><ul><li>label设置<ul><li>当<code>stat=&quot;count&quot;</code>时，设置文本的标签需要使用一个特殊的变量 <code>aes(label=..count..)</code>， 表示的是变量值的数量</li><li>当<code>stat=&quot;identity&quot;</code>时，设置文本的标签需要设置y轴的值，<code>aes(label=price)</code>，表示的变量的值</li></ul></li><li>size设置：标签字体大小，默认值为5号</li><li>color设置：标签文字的颜色</li><li>vjust设置：调整标签位置，1为分界线，越大于1，标签越在柱状图上界下方，反之则越在柱状图上界上方</li><li>hjust设置：<code>hjust = 0.5</code>将标签水平居中放置</li><li>position设置：这里的图形位置与标签位置摆放必须一致，即图形位置<code>geom_bar()</code>函数设置为<code>position = &#39;fill&#39;</code>，那么标签位置<code>geom_text()</code>函数设置为<code>position = position_fill(0.9)</code>参数</li></ul><h3 id="正负柱状图"><a href="#正负柱状图" class="headerlink" title="正负柱状图"></a>正负柱状图</h3><p>只要数据是负数，就能画出往下方的柱状图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d &lt;- data.frame(a=letters[<span class="number">1</span>:<span class="number">7</span>], b=c(<span class="number">4</span>,-<span class="number">6</span>,<span class="number">5</span>,-<span class="number">4</span>,-<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>))</span><br><span class="line">p &lt;- ggplot(d,aes(a,b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 左图</span></span><br><span class="line">p1 &lt;- p + geom_bar(stat=<span class="string">"identity"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 右图</span></span><br><span class="line">p2 &lt;- p + geom_bar(aes(fill=factor((b&gt;<span class="number">0</span>)+<span class="number">1</span>)),stat=<span class="string">"identity"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/柱状图-正负柱状图.png" title="柱状图-正负柱状图"><h2 id="geom-boxplot-箱型图"><a href="#geom-boxplot-箱型图" class="headerlink" title="geom_boxplot()箱型图"></a><code>geom_boxplot()</code>箱型图</h2><p><code>geom_boxplot()</code>函数中有outlier开头的多个参数，用于修改离群点的属性：</p><ul><li><code>outlier.colour</code>：离群点的颜色</li><li><code>outlier.fill</code>：离群点的填充色</li><li><code>outlier.shape</code>：离群点的形状</li><li><code>outlier.size</code>：离群点的大小</li><li><code>outlier.alpha</code>：离群点的透明度</li></ul><p>箱形图可以用fill参数指定填充颜色，color参数指定边框颜色。</p><p>下面是一个示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = cut, y = price))</span><br><span class="line">p &lt;- p + geom_boxplot(fill = <span class="string">"white"</span>, color = <span class="string">"darkgreen"</span>, outlier.shape=<span class="number">21</span>, outlier.size=<span class="number">4</span>, outlier.stroke = <span class="number">1</span>, outlier.color = <span class="string">"gray"</span>, outlier.fill = <span class="string">"orange"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/箱型图.png" title="箱型图"><p>在添加有<strong>多分类变量</strong>时，箱线图默认使用的<code>position</code>参数是<code>dodge</code>，使用堆积方式<code>stack</code>、堆积百分比<code>fill</code>来呈现多维箱线图是会失败的。</p><h2 id="geom-histogram-直方图"><a href="#geom-histogram-直方图" class="headerlink" title="geom_histogram()直方图"></a><code>geom_histogram()</code>直方图</h2><p>直方图函数<code>geom_histogram()</code>与柱形图函数<code>geom_bar()</code>大致相同。</p><h3 id="直方图组距调整"><a href="#直方图组距调整" class="headerlink" title="直方图组距调整"></a>直方图组距调整</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认组距-左图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = price))</span><br><span class="line">p + geom_histogram()</span><br><span class="line"></span><br><span class="line"><span class="comment"># binwidth参数控制直方图组距大小-右图</span></span><br><span class="line">p + geom_histogram(binwidth = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/直方图-组距调整.png" title="直方图-组距调整"><h3 id="分组直方图"><a href="#分组直方图" class="headerlink" title="分组直方图"></a>分组直方图</h3><p>直方图参数中添加颜色映射来区分不同组，这时默认直方图输出为堆积直方图。我们也可以通过设置position参数对多序列柱形进行簇状、堆积百分比转换。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = price, fill = factor(cut)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认分组直方图（stack）-左上图</span></span><br><span class="line">p + geom_histogram()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不做任何转换（identity）-右上图</span></span><br><span class="line">p + geom_histogram(position = <span class="string">'identity'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 簇状分组柱状图（dodge）-左下图</span></span><br><span class="line">p + geom_histogram(position = <span class="string">'dodge'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆叠百分比分组柱状图（fill）-右下图</span></span><br><span class="line">p + geom_histogram(position = <span class="string">'fill'</span>)</span><br></pre></td></tr></table></figure><img src="/archives/71d12648/直方图-分组直方图.png" title="直方图-分组直方图"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.zhihu.com/question/24779017" rel="external nofollow noopener noreferrer" target="_blank">如何使用 ggplot2 ？</a></li><li><a href="https://zhuanlan.zhihu.com/p/27093478" rel="external nofollow noopener noreferrer" target="_blank">R|ggplot2(二)|覆盖柱状图各种需求</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;几何对象&lt;/strong&gt;执行着图层的实际渲染，控制着生成的图像类型。&lt;ul&gt;&lt;li&gt;&lt;code&gt;geom_point()&lt;/code&gt;将会生成散点图&lt;/li&gt;&lt;li&gt;&lt;code&gt;geom_line()&lt;/code&gt;将会生成折线图&lt;/li&gt;&lt;li&gt;&lt;code&gt;geom_bar()&lt;/code&gt;将会生成柱状图&lt;/li&gt;&lt;li&gt;&lt;code&gt;geom_boxplot()&lt;/code&gt;将会生成箱型图&lt;/li&gt;&lt;li&gt;&lt;code&gt;geom_histogram()&lt;/code&gt;将会生成直方图&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;统计变换&lt;/strong&gt;通常以某种方式对数据信息进行汇总。&lt;ul&gt;&lt;li&gt;&lt;code&gt;stat_smooth()&lt;/code&gt;添加光滑曲线&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
  </entry>
  
  <entry>
    <title>R数据可视化-ggplot2的标度</title>
    <link href="https://tding.top/archives/99c6f91.html"/>
    <id>https://tding.top/archives/99c6f91.html</id>
    <published>2019-12-08T15:30:00.000Z</published>
    <updated>2019-12-08T15:53:55.846Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>标度控制着<strong>数据到图形属性的映射</strong>，标度将我们的数据转化为视觉上可以感知的东西，如大小、颜色、位置和形状，所以通过标度可以修改坐标轴和图例的参数。</p><p>每一种图形属性都拥有一个默认的标度，此标度将在我们每次使用这个图形属性时被自动添加到图形中，这些标度列于下表中，默认属性粗体显示：</p><table><thead><tr><th>图形属性</th><th>离散型</th><th>连续型</th></tr></thead><tbody><tr><td>颜色和填充色</td><td>brewer grey <strong>hue</strong> identity manual</td><td><strong>gradient</strong> gradient2 gradientn</td></tr><tr><td>位置</td><td><strong>discrete</strong></td><td><strong>continuous</strong> date</td></tr><tr><td>形状</td><td><strong>shape</strong> identity manual</td><td></td></tr><tr><td>线条类型</td><td><strong>linetype</strong> identity manual</td><td></td></tr><tr><td>大小</td><td>identity manual</td><td><strong>size</strong></td></tr></tbody></table><p>如果要添加一个不同的标度或修改默认标度的某些特征，<strong>我们必须构建一个新的标度，然后使用<code>+</code>将其添加到图形上</strong>。所有的标度构建器（scale）都拥有一套通用的命名方案，它们以<code>scale_</code>开头，接下来是图形属性的名称（例如：<code>colour_</code>、<code>shape_</code>、<code>x_</code>）最后以标度的名称结尾（<code>gradient</code>、<code>hue</code>、<code>manual</code>）。</p><ul><li>离散图形的颜色属性采用默认标度：<code>scale_colour_hue()</code></li><li>离散图形的填充色属性采用ColorBrewer配色标度：<code>scale_fill_brewer()</code></li></ul><a id="more"></a><p>下面是一个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认标度-左图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整标度的参数-右图</span></span><br><span class="line">p + scale_colour_hue(<span class="string">"cut"</span>,breaks=c(<span class="string">"Fair"</span>,<span class="string">"Good"</span>,<span class="string">"Very Good"</span>),labels=c(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>))</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-示例.png" title="标度-示例"><h2 id="标度系列函数"><a href="#标度系列函数" class="headerlink" title="标度系列函数"></a>标度系列函数</h2><p>标度系列函数可以粗略的分为4类：</p><ul><li><strong>位置标度</strong>：用于将连续型、离散型和日期-时间型变量映射到绘图区域，以及构造对应的坐标轴</li><li><strong>颜色标度</strong>：用于将连续型和离散型变量映射到颜色</li><li><strong>手动离散型标度</strong>：用于将离散型变量映射到我们选择的符号大小、线条类型、形状或颜色，以及创建对应的图例</li><li><strong>同一型标度</strong>：用于直接将变量值绘制为图形属性，而不去映射他们</li></ul><h3 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h3><p>上面这些标度系列函数都会有一些参数，这些就是通用参数，下面简单介绍一下这些通用参数。</p><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p><strong>name：设置坐标轴或图例上出现的标签</strong>。可以使用三个辅助函数<code>xlab()</code>、<code>ylab()</code>、<code>labs()</code>来减少代码。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认-左上</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加x标签-右上</span></span><br><span class="line">p + scale_x_continuous(<span class="string">"Diamonds carat"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加x标签（使用xlab()这个辅助函数）</span></span><br><span class="line">p + xlab(<span class="string">"Diamonds carat"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时添加x、y及colour标度-左下</span></span><br><span class="line">p + labs(x = <span class="string">"Diamonds carat"</span>, y = <span class="string">"Diamonds price"</span>, colour = <span class="string">"Diamond Cut"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加x标度为表达式-右下</span></span><br><span class="line">p + xlab(expression(frac(carat,<span class="number">10</span>)))</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-name.png" title="标度-name"><h4 id="limits"><a href="#limits" class="headerlink" title="limits"></a>limits</h4><p><strong>limits：固定标度的定义域</strong>。</p><ul><li>连续型标度接受一个长度为2的数值型向量</li><li>离散型标度接受一个字符型向量</li></ul><p>我们可以通过设定limits来移除不想在图形上展示的数据，<strong>任何不在此范围内的数据将会被丢弃</strong>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定x轴的范围-左图</span></span><br><span class="line">p + scale_x_continuous(limits = c(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定colour的范围-右图</span></span><br><span class="line">p + scale_colour_hue(limits = <span class="string">"Fair"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-limits.png" title="标度-limits"><h4 id="breaks、labels"><a href="#breaks、labels" class="headerlink" title="breaks、labels"></a>breaks、labels</h4><ul><li>breaks表示在坐标轴/图例上哪些点的位置标标签</li><li>labels表示标什么标签，若设定labels，则必须同时指定breaks。</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定x轴的坐标轴的值-左图</span></span><br><span class="line">p + scale_x_continuous(breaks = c(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定图例上的值-右图</span></span><br><span class="line">p + scale_colour_hue(breaks = <span class="string">"Fair"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-breaks.png" title="标度-breaks"><h3 id="位置标度"><a href="#位置标度" class="headerlink" title="位置标度"></a>位置标度</h3><p>每幅图都一定拥有两个位置标度，一个指定水平位置（x标度），另外一个指定竖直位置（y标度）。ggplot2提供了连续型、离散型（针对因子型、字符型和逻辑型向量）以及日期型标度。</p><h4 id="连续型位置标度"><a href="#连续型位置标度" class="headerlink" title="连续型位置标度"></a>连续型位置标度</h4><p>最常用的连续型位置标度是<code>scale_x_continuous</code>和<code>scale_y_continuous</code>，它们均将数据映射到x轴和y轴。而最有趣的变式是通过变换来生成的，每一个连续型标度都可以接受一个trans 参数，允许指定若干种线性或非线性的变换。</p><p>下面是支持的变换：</p><table><thead><tr><th>名称</th><th>变换函数$f(x)$</th><th>逆变换函数$f^{−1}(x)$</th></tr></thead><tbody><tr><td>asn</td><td>$tanh^{−1}(x)$</td><td>$tanh(y)$</td></tr><tr><td>exp</td><td>$e^x$</td><td>$log(y)$</td></tr><tr><td>identity</td><td>$x$</td><td>$y$</td></tr><tr><td>log</td><td>$log(x)$</td><td>$e^y$</td></tr><tr><td>log10</td><td>$log_{10}(x)$</td><td>$10^y$</td></tr><tr><td>log2</td><td>$log_2(x)$</td><td>$2^y$</td></tr><tr><td>logit</td><td>$log(\frac{x}{1−x})$</td><td>$\frac{1}{1+e(y)}$</td></tr><tr><td>pow10</td><td>$10^x$</td><td>$log_{10}(y)$</td></tr><tr><td>probit</td><td>$\phi(x)$</td><td>$\phi^{−1}(y)$</td></tr><tr><td>recip</td><td>$x^{−1}$</td><td>$y^{−1}$</td></tr><tr><td>reverse</td><td>$−x$</td><td>$−y$</td></tr><tr><td>sqrt</td><td>$x^{\frac{1}{2}}$</td><td>$y^2$</td></tr></tbody></table><p><strong>对于连续型位置标度，变换有简写形式</strong>，比如<code>scale_x_continuous(trans = “log10”)</code>可以简写为<code>scale_x_log10()</code>。参数trans对任意连续型标度均有效，但只有位置标度有简写形式。</p><p>当然，可以直接对变量进行变换，而不使用标度变换。比如我们可以直接绘制<code>log10(x)</code>，而不去使用<code>scale_x_log10()</code>。</p><p><strong>这两种做法将在绘图区域生成完全相同的结果，但是坐标轴和刻度标签却是不同的</strong>。</p><p>下面是一个对比：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自行变换log10()-左图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = log10(carat), y = log10(price), color = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># scale_x_log10()变换-右图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line">p &lt;- p + scale_x_log10() + scale_y_log10()</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-位置-连续型.png" title="标度-位置-连续型"><h4 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h4><p>日期和时间值基本上属于连续型标度，但在标注坐标轴时有着特殊的处理方式。目前我们仅支持属于<code>date</code>类的日期值和属于<code>POSIXct</code>类的时间值。如果你的日期和时间值是其他格式的，则需要<code>as.Date()</code>或<code>as.POSIXct()</code>对其进行转换。</p><p>一共有三个参数可以控制坐标轴外观和刻度的位置：major、minor、format：</p><ul><li>major、minor：以时间的单位（即年月周日时分秒）来指定主要和次要断点的位置，并且允许以这些单位的倍数出现，比如，<code>major = &quot;2weeks&quot;</code>将在每隔两周的位置放置一个主刻度。如果未指定，日期刻度可以自动选出合适的默认值。</li><li>format：指定了刻度标签的格式。</li></ul><p>下面是一个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(scales)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间序列-左上</span></span><br><span class="line">p &lt;- ggplot(data = economics, mapping = aes(x = date, y = psavert))</span><br><span class="line">p &lt;- p + geom_line()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加水平线-右上</span></span><br><span class="line">p &lt;- p + geom_hline(xintercept = <span class="number">0</span>, yintercept = <span class="number">0</span>, colour = <span class="string">"gray50"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔10年为一个断点-左下</span></span><br><span class="line">p + scale_x_date(breaks = date_breaks(<span class="string">"10 years"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用年月日的格式仅显示在2004年内的图形-右下</span></span><br><span class="line">p + scale_x_date(limits = as.Date(c(<span class="string">"2004-01-01"</span>,<span class="string">"2005-01-01"</span>)), labels = date_format(<span class="string">"%Y-%m-%d"</span>))</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-位置-时间.png" title="标度-位置-时间"><h4 id="离散型位置标度"><a href="#离散型位置标度" class="headerlink" title="离散型位置标度"></a>离散型位置标度</h4><p>离散型位置标度<code>scale_x_discrete</code>、<code>scale_y_discrete</code>将输入中的各个水平映射为整数。结果的顺序可用参数breaks进行控制，不想要的水平可以使用limits（或xlim、ylim）进行丢弃。</p><p>由于我们经常也会在图形的非整点位置放置标签和标注，所以离散型位置标度也可以接受连续型的值。如果你尚未调整breaks或limits，某个因子水平的所在位置的数值表示可以使用<code>as.numeric()</code>进行计算：以从1开始的整数表示。</p><p>离散型位置标度的参数主要是前面提到的<strong>通用参数</strong>。</p><p>下面看一个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认方案-左图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(cut, price))</span><br><span class="line">p &lt;- p + geom_boxplot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改横轴标度-中图</span></span><br><span class="line">p + scale_x_discrete(labels = c(<span class="string">"Fair"</span> = <span class="string">"A"</span>,<span class="string">"Good"</span> = <span class="string">"B"</span>, <span class="string">"Very Good"</span> = <span class="string">"C"</span>,<span class="string">"Premium"</span> = <span class="string">"D"</span>,<span class="string">"Ideal"</span> = <span class="string">"E"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除不想展示的cut-右图</span></span><br><span class="line">p + scale_x_discrete(limits = c(<span class="string">"Fair"</span>,<span class="string">"Good"</span>))</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-位置-离散型.png" title="标度-位置-离散型"><h3 id="颜色标度"><a href="#颜色标度" class="headerlink" title="颜色标度"></a>颜色标度</h3><p>以下标度对<strong>边界色（colour）图形属性</strong>和<strong>填充色（fill）图形属性</strong>均有效。</p><h4 id="连续型颜色标度"><a href="#连续型颜色标度" class="headerlink" title="连续型颜色标度"></a>连续型颜色标度</h4><p>根据颜色梯度中的色彩数量划分，共有三类连续型颜色梯度（即渐变色）：</p><ul><li><strong><code>scale_colour_gradient()</code>、<code>scale_fill_gradient()</code>：双色梯度</strong>。参数low和high控制梯度两端的颜色</li><li><strong><code>scale_colour_gradient2()</code>、<code>scale_fill_gradient2()</code>：三色梯度</strong>。顺序为低-中-高，这两种标度还在中点处拥有一个中间色</li><li><strong><code>scale_colour_gradientn()</code>、<code>scale_fill_gradientn()</code>：自定义n色梯度</strong></li></ul><p><strong>颜色梯度常被用来展示一个二维表面的高度，用以描述第三维度，颜色的深浅代表着不同的值</strong>。例如描述地势高低时，地势的高低常常用颜色深浅来展现。</p><p>下面我们用R自带的一个向量数据集volcano，因为ggplot2只接受数据框格式，因此我们先把数据转换成数据框格式：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(reshape2)</span><br><span class="line"></span><br><span class="line">volcano3d &lt;- melt(volcano)</span><br><span class="line">names(volcano3d) &lt;- c(<span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>)</span><br></pre></td></tr></table></figure><p>下面展示双色梯度<code>scale_fill_gradient()</code>的用法：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认参数-左图</span></span><br><span class="line">p &lt;- ggplot(data = volcano3d,mapping = aes(x,y,fill=z))</span><br><span class="line">p &lt;- p + geom_tile()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制填充颜色的值范围-中图</span></span><br><span class="line">p + scale_fill_gradient(limits = c(<span class="number">120</span>,<span class="number">170</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过参数low与high，控制颜色在low与high之间渐变-右图</span></span><br><span class="line">p + scale_fill_gradient(low = <span class="string">"blue"</span>, high = <span class="string">"red"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-颜色-连续型-1.png" title="标度-颜色-连续型-1"><p>下面展示三色梯度<code>scale_fill_gradient2()</code>的用法：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认参数，即midpoint=0-左图</span></span><br><span class="line">p + scale_fill_gradient2(low = <span class="string">"blue"</span>, high = <span class="string">"red"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置midpoint=150-右图</span></span><br><span class="line">p + scale_fill_gradient2(low = <span class="string">"blue"</span>, high = <span class="string">"red"</span>, midpoint = <span class="number">150</span>)</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-颜色-连续型-2.png" title="标度-颜色-连续型-2"><p>以上两图都设定了颜色由 blue 到 red 渐变，但是左图使用默认参数 <code>midpoint=0</code>，右图使用参数<code>midpoint=150</code>，而 z 值的范围是 <code>94~195</code>，所有他们在图中实际渐变色为，<strong>左图：浅红-红，右图：蓝-白-红</strong>。</p><p>下面展示自定义n色梯度<code>scale_fill_gradientn()</code>的用法：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动设置颜色-左图</span></span><br><span class="line">p + scale_fill_gradientn(colours = c(<span class="string">"black"</span>,<span class="string">"blue"</span>,<span class="string">"red"</span>,<span class="string">"white"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用R语言预设的调色盘-右图</span></span><br><span class="line">p + scale_fill_gradientn(colours = topo.colors(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-颜色-连续型-3.png" title="标度-颜色-连续型-3"><h4 id="离散型颜色标度"><a href="#离散型颜色标度" class="headerlink" title="离散型颜色标度"></a>离散型颜色标度</h4><p>离散型数据有两种颜色标度。一种可以自动选择颜色，另一种可以手工从颜色集中选择颜色。</p><ul><li><p>默认的配色方案，即<code>scale_colour_hue()</code>、<code>scale_fill_hue()</code>，可通过沿着hcl色轮选取均匀分布的色相来生成颜色。这种方案对颜色较少时有比较好的效果，但对于更多不同的颜色就不好区分开来。</p></li><li><p>另一种可选的方案是<a href="http://colorbrewer.org" rel="external nofollow noopener noreferrer" target="_blank">ColorBrewer配色</a>。即<code>scale_colour_brewer()</code>、<code>scale_fill_brewer()</code>。要想了解所有的调色板，可以使用<code>RColorBrewer::display.brewer.all()</code>查看。我们可以用参数<code>palette=”调色板名称或者数字”</code>来使用。例如，使用第二个调色板时用<code>palette = 2</code>（等价于<code>palette = &#39;YIOrBr&#39;</code>）。</p></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认方案，即scale_colour_hue()-左上图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(cut, price, fill = color))</span><br><span class="line">p &lt;- p + geom_boxplot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用ColorBrewer配色-右上图</span></span><br><span class="line">p + scale_fill_brewer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用ColorBrewer配色中第二个调色板-左下图</span></span><br><span class="line">p + scale_fill_brewer(palette = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用ColorBrewer配色中'Spectral'调色板-右下图</span></span><br><span class="line">p + scale_fill_brewer(palette = <span class="string">"Spectral"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-颜色-离散型.png" title="标度-颜色-离散型"><h3 id="手动离散型标度"><a href="#手动离散型标度" class="headerlink" title="手动离散型标度"></a>手动离散型标度</h3><p>离散型标度<code>scale_linetype()</code>、<code>scale_colour_manual()</code>、<code>scale_size_discrete()</code>、<code>scale_shape()</code>是按一定的顺序将因子的水平映射到一系列取值中。<strong>如果想要定制这些标度，需要使用以下手动型标度创建新的标度</strong>：</p><ul><li><code>scale_linetype_manual()</code></li><li><code>scale_colour_manual()</code></li><li><code>scale_size_discrete()</code></li><li><code>scale_shape_manual()</code></li></ul><p>手动型标度拥有一个重要参数values，我们可以用它来指定这个标度应该生成的值。</p><p>下面是一个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认颜色-左上图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, color = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动改变颜色-右上图</span></span><br><span class="line">p + scale_colour_manual(values = c(<span class="string">"Fair"</span> = <span class="string">"red"</span>,<span class="string">"Good"</span> = <span class="string">"yellow"</span>,<span class="string">"Very Good"</span> = <span class="string">"green"</span>,<span class="string">"Premium"</span> = <span class="string">"blue"</span>,<span class="string">"Ideal"</span> = <span class="string">"black"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认大小-左下图</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, size = factor(cut)))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动改变大小-右下图</span></span><br><span class="line">p + scale_size_manual(values = c(<span class="number">10</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><img src="/archives/99c6f91/标度-手动离散型.png" title="标度-手动离散型"><h3 id="同一型标度"><a href="#同一型标度" class="headerlink" title="同一型标度"></a>同一型标度</h3><p>当你的数据能被R中的绘图函数理解时，即数据空间和图形属性空间相同时，可以使用同一性标度(identity scale)，这意味着此时无法仅从数据本身派生出有意义的图例，所以默认是不绘制图例。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/lantingg/p/7999251.html" rel="external nofollow noopener noreferrer" target="_blank">ggplot2入门与进阶（上）</a></li><li><a href="https://www.cnblogs.com/lizhilei-123/p/6808370.html" rel="external nofollow noopener noreferrer" target="_blank">R数据可视化—-ggplot2之标度、坐标轴和图例详解</a></li><li><a href="https://blog.csdn.net/songzhilian22/article/details/49388677" rel="external nofollow noopener noreferrer" target="_blank">ggplot2学习笔记之颜色标度</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;标度控制着&lt;strong&gt;数据到图形属性的映射&lt;/strong&gt;，标度将我们的数据转化为视觉上可以感知的东西，如大小、颜色、位置和形状，所以通过标度可以修改坐标轴和图例的参数。&lt;/p&gt;&lt;p&gt;每一种图形属性都拥有一个默认的标度，此标度将在我们每次使用这个图形属性时被自动添加到图形中，这些标度列于下表中，默认属性粗体显示：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;图形属性&lt;/th&gt;&lt;th&gt;离散型&lt;/th&gt;&lt;th&gt;连续型&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;颜色和填充色&lt;/td&gt;&lt;td&gt;brewer grey &lt;strong&gt;hue&lt;/strong&gt; identity manual&lt;/td&gt;&lt;td&gt;&lt;strong&gt;gradient&lt;/strong&gt; gradient2 gradientn&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;位置&lt;/td&gt;&lt;td&gt;&lt;strong&gt;discrete&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;continuous&lt;/strong&gt; date&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;形状&lt;/td&gt;&lt;td&gt;&lt;strong&gt;shape&lt;/strong&gt; identity manual&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;线条类型&lt;/td&gt;&lt;td&gt;&lt;strong&gt;linetype&lt;/strong&gt; identity manual&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;大小&lt;/td&gt;&lt;td&gt;identity manual&lt;/td&gt;&lt;td&gt;&lt;strong&gt;size&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果要添加一个不同的标度或修改默认标度的某些特征，&lt;strong&gt;我们必须构建一个新的标度，然后使用&lt;code&gt;+&lt;/code&gt;将其添加到图形上&lt;/strong&gt;。所有的标度构建器（scale）都拥有一套通用的命名方案，它们以&lt;code&gt;scale_&lt;/code&gt;开头，接下来是图形属性的名称（例如：&lt;code&gt;colour_&lt;/code&gt;、&lt;code&gt;shape_&lt;/code&gt;、&lt;code&gt;x_&lt;/code&gt;）最后以标度的名称结尾（&lt;code&gt;gradient&lt;/code&gt;、&lt;code&gt;hue&lt;/code&gt;、&lt;code&gt;manual&lt;/code&gt;）。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;离散图形的颜色属性采用默认标度：&lt;code&gt;scale_colour_hue()&lt;/code&gt;&lt;/li&gt;&lt;li&gt;离散图形的填充色属性采用ColorBrewer配色标度：&lt;code&gt;scale_fill_brewer()&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
  </entry>
  
  <entry>
    <title>R数据可视化-ggplot2的坐标系</title>
    <link href="https://tding.top/archives/16cc1f7e.html"/>
    <id>https://tding.top/archives/16cc1f7e.html</id>
    <published>2019-12-07T14:30:00.000Z</published>
    <updated>2019-12-08T13:13:32.081Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>在ggplot2中，为了得到更好的数据可视化效果，我们可能要用到一些坐标转换的操作。</p><p>ggplot2包含了6种不同的坐标系：</p><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>coord_cartesian</code></td><td style="text-align:center">笛卡尔坐标系</td></tr><tr><td style="text-align:center"><code>coord_equal</code></td><td style="text-align:center">同尺度笛卡尔坐标系</td></tr><tr><td style="text-align:center"><code>coord_flip</code></td><td style="text-align:center">翻转的笛卡尔坐标系</td></tr><tr><td style="text-align:center"><code>coord_trans</code></td><td style="text-align:center">变换的笛卡尔坐标系</td></tr><tr><td style="text-align:center"><code>coord_map</code></td><td style="text-align:center">地图射影</td></tr><tr><td style="text-align:center"><code>coord_polar</code></td><td style="text-align:center">极坐标系</td></tr></tbody></table><a id="more"></a><h2 id="笛卡尔坐标系"><a href="#笛卡尔坐标系" class="headerlink" title="笛卡尔坐标系"></a>笛卡尔坐标系</h2><p>笛卡尔坐标系参数说明：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coord_cartesian(xlim = <span class="literal">NULL</span>, ylim = <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>xlim、ylim参数用来限定x、y轴的范围。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整数据集-左</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p1 &lt;- p1 + geom_point()</span><br><span class="line">p1 &lt;- p1 + geom_smooth()</span><br><span class="line"></span><br><span class="line"><span class="comment"># x的标度范围设置-中</span></span><br><span class="line">p2 &lt;- p1 + scale_x_continuous(limits = c(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># x轴坐标系范围设置-右</span></span><br><span class="line">p3 &lt;- p1 + coord_cartesian(xlim = c(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">grid.arrange(p1,p2,p3,ncol=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="/archives/16cc1f7e/笛卡尔坐标系-1.png" title="笛卡尔坐标系-1"><p>左图是完整的数据集，中图为x的标度范围设置，右图为x轴坐标系范围设置。标度的范围设置是对数据取子集，然后再重新拟合曲线。<strong>坐标系的放缩就是图像的放缩</strong>。</p><p>上面的这个图看的不是很明显，下面看个更明显的例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整数据集-左</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p1 &lt;- p1 + stat_bin2d(bins = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x的标度范围设置-中</span></span><br><span class="line">p2 &lt;- p1 + scale_x_continuous(limits = c(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># x轴坐标系范围设置-右</span></span><br><span class="line">p3 &lt;- p1 + coord_cartesian(xlim = c(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">grid.arrange(p1,p2,p3,ncol=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="/archives/16cc1f7e/笛卡尔坐标系-2.png" title="笛卡尔坐标系-2"><p>这里我们可以通过方块的大小很直观的发现，当设定标度范围时，方块的数目还是相同的，只是覆盖了更少数的区域，当设定坐标系范围时，<strong>方块数目变少，但它们覆盖的区域没变</strong>。</p><h2 id="坐标轴翻转"><a href="#坐标轴翻转" class="headerlink" title="坐标轴翻转"></a>坐标轴翻转</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coord_flip()</span><br></pre></td></tr></table></figure><p>把x轴和y轴互换，没有特殊参数。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常数据集-左</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p1 &lt;- p1 + geom_point()</span><br><span class="line">p1 &lt;- p1 + geom_smooth()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 坐标轴属性改变-中</span></span><br><span class="line">p2 &lt;- ggplot(data = diamonds, mapping = aes(x = price, y = carat))</span><br><span class="line">p2 &lt;- p2 + geom_point()</span><br><span class="line">p2 &lt;- p2 + geom_smooth()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 坐标轴翻转-右</span></span><br><span class="line">p3 &lt;- p1 + coord_flip()</span><br><span class="line"></span><br><span class="line">grid.arrange(p1,p2,p3,ncol=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="/archives/16cc1f7e/坐标轴翻转.png" title="坐标轴翻转"><ul><li>左图是原散点图相应的平滑曲线</li><li>中图互换两个属性变量，平滑曲线拟合的是旋转后的变量</li><li>右图<code>coord_flip()</code>拟合原始数据，<strong>然后再翻转输出结果</strong>，就变成是以y为条件变量刻画x的曲线了</li></ul><h2 id="坐标轴变换"><a href="#坐标轴变换" class="headerlink" title="坐标轴变换"></a>坐标轴变换</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coord_trans(x = <span class="string">"identity"</span>, y = <span class="string">"identity"</span>, limx = <span class="literal">NULL</span>, limy = <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>坐标形式转换包括对数转换、平方根转换等，这里x和y的值可以是log10,log2或squal等，另外两个参数也是限定坐标范围。</p><p>这个坐标轴变换函数<code>coord_trans()</code>和<code>scale_x_log10()</code>这类函数是有区别的：</p><ul><li>坐标轴变换函数是其他处理优先，最后作图时再取对数</li><li>标度函数是先将数据取对数，然后再拿进来处理</li></ul><p>我们拿拟合曲线举例子：</p><ul><li>如果用<code>scale_x_log10</code>就相当于把x的数据取了对数放进来做回归，拟合出一条直线。</li><li>如果用<code>coord_trans</code>则是先用原有数据进行回归，得到一条拟合直线之后再变换坐标轴，<strong>曲线也会被弯曲</strong>！</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"><span class="keyword">library</span>(scales)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常数据集-左</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p1 &lt;- p1 + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标度变换-中</span></span><br><span class="line">p2 &lt;- p1 + scale_x_log10() + scale_y_log10() + geom_smooth(method = <span class="string">'lm'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 坐标轴变换-右</span></span><br><span class="line">p3 &lt;- p2 + coord_trans(x = exp_trans(<span class="number">10</span>),y=exp_trans(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">grid.arrange(p1,p2,p3,ncol=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><img src="/archives/16cc1f7e/坐标轴变换.png" title="坐标轴变换"><p><strong>坐标系层面的变换发生再统计变换之后，会影响拟合的曲线形状</strong>。</p><ul><li>左图为克拉和价格的散点图</li><li>中图为克拉和价格<strong>对数变换</strong>后的散点图，直线为回归曲线：<code>log(y)=a+blog(x)</code></li><li>右图将前面的图变换回去，标度还原，因此线性趋势变成指数形式，<code>y=k(c^x)</code></li></ul><h2 id="极坐标转换"><a href="#极坐标转换" class="headerlink" title="极坐标转换"></a>极坐标转换</h2><p>极坐标转换可以做出蜘蛛图或饼图的效果。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coord_polar(theta = <span class="string">"x"</span>, start = <span class="number">0</span>, direction = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>theta可以选择x或y，表示外延的坐标</li><li>start是坐标开始的角度，默认起始位置是12点钟</li></ul><p>下面是一个例子：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 柱状图-上图</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = factor(<span class="number">1</span>), fill = cut))</span><br><span class="line">p1 &lt;- p1 + geom_bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 圆环图效果-下图左</span></span><br><span class="line">p2 &lt;- p1 + coord_polar(theta=<span class="string">"x"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 饼图效果-下图右</span></span><br><span class="line">p3 &lt;- p1 + coord_polar(theta=<span class="string">"y"</span>)</span><br><span class="line"></span><br><span class="line">grid.arrange(p2,p3,ncol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><img src="/archives/16cc1f7e/极坐标转换-1.png" title="极坐标转换-1"><ul><li>上图：当使用一个因子变量作为横轴，使用分类变量进行填充时，该柱形图变成了单条堆积柱形图。</li><li>当theta指定为x时，柱形图的x轴会被指定为极坐标的x轴（圆周），而柱形图的y轴则会成为极坐标的y轴（半径）。</li><li>当theta指定为y时，柱形图的y轴为被指定为极坐标的x轴（圆周），而柱形图的x轴则会成为极坐标的y轴（半径）。</li></ul><p>当有多个序列时：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 柱状图-上图</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = cut, fill = cut))</span><br><span class="line">p1 &lt;- p1 + geom_bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 南丁格尔玫瑰图效果-左</span></span><br><span class="line">p2 &lt;- p1 + coord_polar(theta=<span class="string">"x"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 圆环图、圆条图效果-右</span></span><br><span class="line">p3 &lt;- p1 + coord_polar(theta=<span class="string">"y"</span>)</span><br><span class="line"></span><br><span class="line">grid.arrange(p2,p3,ncol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><img src="/archives/16cc1f7e/极坐标转换-2.png" title="极坐标转换-2"><p>当有多个序列时，我们可以通过极坐标转换可以实现圆环图、圆条图效果以及南丁格尔玫瑰图效果。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆叠柱状图-上图</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = color, fill = cut))</span><br><span class="line">p1 &lt;- p1 + geom_bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆叠玫瑰图效果-左</span></span><br><span class="line">p2 &lt;- p1 + coord_polar(theta=<span class="string">"x"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复杂的圆环图效果-右</span></span><br><span class="line">p3 &lt;- p1 + coord_polar(theta=<span class="string">"y"</span>)</span><br><span class="line"></span><br><span class="line">grid.arrange(p2,p3,ncol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><img src="/archives/16cc1f7e/极坐标转换-3.png" title="极坐标转换-3"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/wkslearner/p/5718928.html" rel="external nofollow noopener noreferrer" target="_blank">ggplot2 坐标系相关设置（coord）</a></li><li><a href="https://blog.csdn.net/u011596455/article/details/79574080" rel="external nofollow noopener noreferrer" target="_blank">七、R数据可视化–ggplot2定位之坐标系详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/27262426" rel="external nofollow noopener noreferrer" target="_blank">R语言可视化——极坐标变换与衍生图表类型</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在ggplot2中，为了得到更好的数据可视化效果，我们可能要用到一些坐标转换的操作。&lt;/p&gt;&lt;p&gt;ggplot2包含了6种不同的坐标系：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style=&quot;text-align:center&quot;&gt;名字&lt;/th&gt;&lt;th style=&quot;text-align:center&quot;&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;coord_cartesian&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;笛卡尔坐标系&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;coord_equal&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;同尺度笛卡尔坐标系&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;coord_flip&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;翻转的笛卡尔坐标系&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;coord_trans&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;变换的笛卡尔坐标系&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;coord_map&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;地图射影&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;coord_polar&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;极坐标系&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
  </entry>
  
  <entry>
    <title>R数据可视化-ggplot2的分面</title>
    <link href="https://tding.top/archives/12b79187.html"/>
    <id>https://tding.top/archives/12b79187.html</id>
    <published>2019-12-07T06:30:00.000Z</published>
    <updated>2019-12-07T15:40:04.494Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>分面(facet)是在一个页面上自动摆放多幅图形，这一过程先将数据划分为多个子集，然后将每个子集依次绘制到页面的不同面板中。</p><p>ggplot2提供了两种分面类型：</p><ul><li>网格分面-<code>facet_grid</code>：生成一个2维的面板网格，面板的行与列通过变量来定义。<strong>本质是2维的</strong>。</li><li>封装分面-<code>facet_wrap</code>：首先生成一个1维的面板条块，然后再分装到2维中。<strong>本质是1维的</strong>。</li></ul><a id="more"></a><h2 id="网格分面-facet-grid"><a href="#网格分面-facet-grid" class="headerlink" title="网格分面-facet_grid"></a>网格分面-<code>facet_grid</code></h2><p>网格分面生成的是一个2维的面板网格，面板的行与列通过变量来定义。本质是2维的。</p><h3 id="不进行分面"><a href="#不进行分面" class="headerlink" title="不进行分面"></a>不进行分面</h3><p>不进行分面：即不使用函数<code>facet_grid()</code>或使用<code>facet_null()</code>函数，此时得到的是单独画板。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line">p &lt;- p + facet_null()</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/网格分面-1.png" title="网格分面-1"><h3 id="一行多列"><a href="#一行多列" class="headerlink" title="一行多列"></a>一行多列</h3><p>一行多列：纵坐标相同，用于y位置的比较。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line">p &lt;- p + facet_grid(<span class="string">'. ~ cut'</span>)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/网格分面-2.png" title="网格分面-2"><p><strong>电脑屏幕通常较宽，因此这个方向最合适数据的展示</strong>。</p><h3 id="一列多行"><a href="#一列多行" class="headerlink" title="一列多行"></a>一列多行</h3><p>一列多行：横坐标轴相同，利于x位置的比较，<strong>尤其是对数据分布的比较</strong>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = price))</span><br><span class="line">p &lt;- p + geom_histogram(binwidth = <span class="number">30</span>)</span><br><span class="line">p &lt;- p + facet_grid(<span class="string">'cut ~ .'</span>)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/网格分面-3.png" title="网格分面-3"><h3 id="多列多行"><a href="#多列多行" class="headerlink" title="多列多行"></a>多列多行</h3><p>我们通常都将数目最多的变量按列排放，这样可以充分利用屏幕的宽高比。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line">p &lt;- p + facet_grid(<span class="string">'cut ~ color'</span>)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/网格分面-4.png" title="网格分面-4"><h3 id="facet-grid-函数的参数"><a href="#facet-grid-函数的参数" class="headerlink" title="facet_grid()函数的参数"></a><code>facet_grid()</code>函数的参数</h3><p><code>facet_grid()</code>函数的全部参数如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">facet_grid(facets, margins = <span class="literal">FALSE</span>, scales = <span class="string">"fixed"</span>, space = <span class="string">"fixed"</span>, shrink = <span class="literal">TRUE</span>,</span><br><span class="line">           labeller = <span class="string">"label_value"</span>, as.table = <span class="literal">TRUE</span>, drop = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><ul><li>facets：分面参数</li><li>margins：用于分面的包含每个变量元素所有数据的数据组</li><li>scales：坐标刻度的范围，可以设定四种类型：<ul><li><code>fixed</code>：表示所有小图均使用统一坐标范围</li><li><code>free</code>：表示每个小图按照各自数据范围自由调整坐标刻度范围</li><li><code>free_x</code>：表示可以自由调整x轴刻度范围</li><li><code>free_y</code>：表示可以自由调整y轴刻度范围</li></ul></li><li>space：这个参数要配合scales使用，如果为fixed（默认），所有小图的大小都一样，如果为<code>free/free_x/free_y</code>，小图的大小将按照坐标轴的跨度比例进行设置</li><li>shrinks：这个参数和坐标轴刻度有关，如果为TRUE（默认）则按统计后的数据调整刻度范围，否则按统计前的数据设定坐标</li><li>labeller：这个参数用来设定小图标签</li><li>as.table：小图排列顺序有关的选项。如果为TRUE（默认）则按表格方式排列，即最大值（指分组level值）排在表格最后即右下角，否则排在左上角</li><li>drop：是否丢弃没有数据的分组，如果为TRUE（默认），则空数据组不绘图</li></ul><h4 id="margins"><a href="#margins" class="headerlink" title="margins"></a>margins</h4><p>我们可以用margins来绘制<strong>边际图</strong>。设定<code>margins=TRUE</code>可展示所有的边际图，或者<code>margins=c(&quot;A&quot;,&quot;B&quot;)</code>，列出你要展示的边际图的变量名称。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = price))</span><br><span class="line">p &lt;- p + geom_histogram(binwidth = <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认-左图</span></span><br><span class="line">p + facet_grid(facets = <span class="string">'cut ~ .'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示所有的边际图（margins = TRUE）-右图</span></span><br><span class="line">p + facet_grid(facets = <span class="string">'cut ~ .'</span>, margins = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/网格分面-margins.png" title="网格分面-margins"><h4 id="scales"><a href="#scales" class="headerlink" title="scales"></a>scales</h4><p>固定标度可以让我们在相同的基准上对子集进行比较，观察在哪些地方各子集有相似的总体模式。而自由标度可以帮助我们发现更多细节，它在展示不同量纲的时间序列时非常有用。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = price))</span><br><span class="line">p &lt;- p + geom_histogram(binwidth = <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个分面中固定标度即横纵坐标范围相同-左图</span></span><br><span class="line">p + facet_grid(facets = <span class="string">'cut ~ .'</span>, scales = <span class="string">'fixed'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自由标度即横纵坐标范围可变-右图</span></span><br><span class="line">p + facet_grid(facets = <span class="string">'cut ~ .'</span>, scales = <span class="string">'free'</span>)</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/网格分面-scales.png" title="网格分面-scales"><h4 id="space"><a href="#space" class="headerlink" title="space"></a>space</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = price))</span><br><span class="line">p &lt;- p + geom_histogram(binwidth = <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个分面中固定标度即横纵坐标范围相同-左图</span></span><br><span class="line">p + facet_grid(facets = <span class="string">'cut ~ .'</span>, scales = <span class="string">'fixed'</span>, space = <span class="string">'fixed'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># space设置为free时，每列的宽度与该列的标度范围成比例-右图</span></span><br><span class="line">p + facet_grid(facets = <span class="string">'cut ~ .'</span>, scales = <span class="string">'free'</span>, space = <span class="string">'free'</span>)</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/网格分面-space.png" title="网格分面-space"><h2 id="封装分面-facet-wrap"><a href="#封装分面-facet-wrap" class="headerlink" title="封装分面-facet_wrap"></a>封装分面-<code>facet_wrap</code></h2><p>封装分面首先生成一个1维的面板条块，然后再分装到2维中。<strong>本质是1维的</strong>。</p><h3 id="facet-wrap-函数的参数"><a href="#facet-wrap-函数的参数" class="headerlink" title="facet_wrap()函数的参数"></a><code>facet_wrap()</code>函数的参数</h3><p><code>facet_wrap()</code>函数的全部参数如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">facet_wrap(facets, nrow = <span class="literal">NULL</span>, ncol = <span class="literal">NULL</span>, scales = <span class="string">"fixed"</span>,</span><br><span class="line">           shrink = <span class="literal">TRUE</span>, as.table = <span class="literal">TRUE</span>, drop = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p>前面已经介绍过网格分面的参数，这里的封装分面的参数也是类似的，下面介绍不同的几个参数：</p><ul><li>nrow：绘制图形的行数</li><li>ncol：绘制图形的列数，一般<code>nrow/ncol</code>只设定一个即可</li></ul><h3 id="默认设置"><a href="#默认设置" class="headerlink" title="默认设置"></a>默认设置</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认设置</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line">p &lt;- p + facet_wrap(~ color)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/封装分面-1.png" title="封装分面-1"><h3 id="设置列"><a href="#设置列" class="headerlink" title="设置列"></a>设置列</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过ncol=2设置为两列</span></span><br><span class="line">p &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price))</span><br><span class="line">p &lt;- p + geom_point()</span><br><span class="line">p &lt;- p + facet_wrap(~ color, ncol = <span class="number">2</span>)</span><br><span class="line">p</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/封装分面-2.png" title="封装分面-2"><h2 id="分面与分组对比"><a href="#分面与分组对比" class="headerlink" title="分面与分组对比"></a>分面与分组对比</h2><p>这两种绘图技巧都有相应的优缺点。</p><p>在分面图形中，每个组别都在单独的面板中，相隔较远，组间无重叠。因此组与组之间重叠严重时，分面图形有一定的好处。不过这也会导致组间的细微差别难以被发现。使用图形属性区分各组时，各组将会离得很近甚至可能重叠，不过细微得差别将会容易被发现。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组-左上</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, colour = cut))</span><br><span class="line">p1 &lt;- p1 + geom_point()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分面-右上</span></span><br><span class="line">p2 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, colour = cut))</span><br><span class="line">p2 &lt;- p2 + geom_point()</span><br><span class="line">p2 &lt;- p2 + facet_grid(<span class="string">'. ~ cut'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组-只显示回归线-左下</span></span><br><span class="line">p3 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, colour = cut))</span><br><span class="line">p3 &lt;- p3 + geom_smooth(method = lm, se = <span class="literal">F</span>, fullrange = <span class="literal">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分面-只显示回归线-右下</span></span><br><span class="line">p4 &lt;- ggplot(data = diamonds, mapping = aes(x = carat, y = price, colour = cut))</span><br><span class="line">p4 &lt;- p4 + geom_smooth(method = lm, se = <span class="literal">F</span>, fullrange = <span class="literal">T</span>)</span><br><span class="line">p4 &lt;- p4 + facet_grid(<span class="string">'. ~ cut'</span>)</span><br><span class="line"></span><br><span class="line">p &lt;- grid.arrange(p1,p2,p3,p4,ncol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/分面与分组对比.png" title="分面与分组对比"><p><strong>我们可以使用color或者fill图形属性来为分面条形图上色</strong>。</p><p>在散点图中，仅使用颜色区分各组，我们可能还没注意到图形重叠了，但是回归线却可以让我们看到Ideal、Premium、Good、Very Good被分组在一起，与Fair组相距甚远。</p><h2 id="分面与并列对比"><a href="#分面与并列对比" class="headerlink" title="分面与并列对比"></a>分面与并列对比</h2><p>分面可绘制出与图形并列类似得图形效果。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(gridExtra)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并列-左图</span></span><br><span class="line">p1 &lt;- ggplot(data = diamonds, mapping = aes(x = color, fill = cut))</span><br><span class="line">p1 &lt;- p1 + geom_bar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分面-右图</span></span><br><span class="line">p2 &lt;- ggplot(data = diamonds, mapping = aes(x = color, fill = cut))</span><br><span class="line">p2 &lt;- p2 + geom_bar()</span><br><span class="line">p2 &lt;- p2 + facet_grid(<span class="string">'. ~ cut'</span>)</span><br><span class="line"></span><br><span class="line">grid.arrange(p1,p2,ncol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><img src="/archives/12b79187/分面与并列对比.png" title="分面与并列对比"><p><strong>我们可以使用color或者fill图形属性来为分面条形图上色</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/songzhilian22/article/details/49491281" rel="external nofollow noopener noreferrer" target="_blank">ggplot2学习笔记之分面</a></li><li><a href="https://blog.csdn.net/u011596455/article/details/79574072" rel="external nofollow noopener noreferrer" target="_blank">六、R语言可视化–ggplot2定位之分面</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;分面(facet)是在一个页面上自动摆放多幅图形，这一过程先将数据划分为多个子集，然后将每个子集依次绘制到页面的不同面板中。&lt;/p&gt;&lt;p&gt;ggplot2提供了两种分面类型：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;网格分面-&lt;code&gt;facet_grid&lt;/code&gt;：生成一个2维的面板网格，面板的行与列通过变量来定义。&lt;strong&gt;本质是2维的&lt;/strong&gt;。&lt;/li&gt;&lt;li&gt;封装分面-&lt;code&gt;facet_wrap&lt;/code&gt;：首先生成一个1维的面板条块，然后再分装到2维中。&lt;strong&gt;本质是1维的&lt;/strong&gt;。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
  </entry>
  
  <entry>
    <title>R数据可视化-ggplot2中的qplot函数</title>
    <link href="https://tding.top/archives/8c7eb5d5.html"/>
    <id>https://tding.top/archives/8c7eb5d5.html</id>
    <published>2019-12-06T15:30:00.000Z</published>
    <updated>2019-12-06T15:40:55.920Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p><code>qplot()</code>是ggplot2的一个作图函数，qplot的意思是快速作图（quick plot）。</p><a id="more"></a><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>本文的所有绘图使用的都是ggplot2内置的diamonds数据集，便于我们聚焦于作图的细节。</p><p>diamonds数据集包含了约54000颗钻石的价格和质量的信息。</p><p>数据说明：</p><ul><li>反映钻石质量的四个“C”<ul><li>克拉重量：carat</li><li>切工：cut</li><li>颜色：color</li><li>净度：clarity</li></ul></li><li>五个物理指标<ul><li>深度：depth</li><li>钻面宽度：table</li><li>x</li><li>y</li><li>z</li></ul></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str(diamonds)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Classes &apos;tbl_df&apos;, &apos;tbl&apos; and &apos;data.frame&apos;:53940 obs. of  10 variables:</span><br><span class="line"> $ carat  : num  0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...</span><br><span class="line"> $ cut    : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 ...</span><br><span class="line"> $ color  : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 5 ...</span><br><span class="line"> $ clarity: Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4 5 ...</span><br><span class="line"> $ depth  : num  61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...</span><br><span class="line"> $ table  : num  55 61 65 58 58 57 57 55 61 61 ...</span><br><span class="line"> $ price  : int  326 326 327 334 335 336 336 337 337 338 ...</span><br><span class="line"> $ x      : num  3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...</span><br><span class="line"> $ y      : num  3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...</span><br><span class="line"> $ z      : num  2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(diamonds)</span><br></pre></td></tr></table></figure><table><thead><tr><th>carat</th><th>cut</th><th>color</th><th>clarity</th><th>depth</th><th>table</th><th>price</th><th>x</th><th>y</th><th>z</th></tr></thead><tbody><tr><td>0.23</td><td>Ideal</td><td>E</td><td>SI2</td><td>61.5</td><td>55</td><td>326</td><td>3.95</td><td>3.98</td><td>2.43</td></tr><tr><td>0.21</td><td>Premium</td><td>E</td><td>SI1</td><td>59.8</td><td>61</td><td>326</td><td>3.89</td><td>3.84</td><td>2.31</td></tr><tr><td>0.23</td><td>Good</td><td>E</td><td>VS1</td><td>56.9</td><td>65</td><td>327</td><td>4.05</td><td>4.07</td><td>2.31</td></tr><tr><td>0.29</td><td>Premium</td><td>I</td><td>VS2</td><td>62.4</td><td>58</td><td>334</td><td>4.20</td><td>4.23</td><td>2.63</td></tr><tr><td>0.31</td><td>Good</td><td>J</td><td>SI2</td><td>63.3</td><td>58</td><td>335</td><td>4.34</td><td>4.35</td><td>2.75</td></tr><tr><td>0.24</td><td>Very Good</td><td>J</td><td>VVS2</td><td>62.8</td><td>57</td><td>336</td><td>3.94</td><td>3.96</td><td>2.48</td></tr></tbody></table><p>下面我们从原始数据中随机选出100个样本作为新数据集<code>dsmall</code>，便于小数据的作图展示：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让样本可重复</span></span><br><span class="line">set.seed(<span class="number">1410</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始数据的一个容量为100的随机样本</span></span><br><span class="line">dsmall &lt;- diamonds[sample(nrow(diamonds),<span class="number">100</span>),]</span><br></pre></td></tr></table></figure><h2 id="qplot-基本用法"><a href="#qplot-基本用法" class="headerlink" title="qplot()基本用法"></a>qplot()基本用法</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>下面是钻石的价格和重量之间的关系：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本用法-左图</span></span><br><span class="line">qplot(carat, price, data = diamonds)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种相关关系似乎是指数型的，因此我们应该先对变量进行一些变换。</span></span><br><span class="line"><span class="comment"># 变量的函数作为参数-中图</span></span><br><span class="line">qplot(log(carat), log(price), data = diamonds)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量的某种组合作为参数-右图</span></span><br><span class="line"><span class="comment"># 钻石的体积（`x * y * z`表示）和重量之间的关系</span></span><br><span class="line">qplot(carat, x * y * z, data = diamonds)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/基本用法.png" title="基本用法"><h2 id="颜色、大小、形状和其他图形属性"><a href="#颜色、大小、形状和其他图形属性" class="headerlink" title="颜色、大小、形状和其他图形属性"></a>颜色、大小、形状和其他图形属性</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分组-颜色-左图</span></span><br><span class="line">qplot(carat, price, data = dsmall, colour = color)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组-形状-右图</span></span><br><span class="line">qplot(carat, price, data = dsmall, shape = cut)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/颜色、形状.png" title="颜色、形状"><p>我们可以使用<code>I()</code>来手动设定图形属性。</p><p>例如：<code>colour = I(&quot;red&quot;)</code>或<code>size = I(2)</code>。</p><p>我们可以通过使用alpha图形属性来调整透明度，例如<code>1/10</code>，其分母表示经过多少次重叠之后颜色将变得不透明，这样我们可以看到大部分的点在哪里进行了重叠。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透明度设置为1/10-左图</span></span><br><span class="line">qplot(carat, price, data = diamonds, alpha = I(<span class="number">1</span>/<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透明度设置为1/200-右图</span></span><br><span class="line">qplot(carat, price, data = diamonds, alpha = I(<span class="number">1</span>/<span class="number">200</span>))</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/透明度设置.png" title="透明度设置"><h2 id="几何对象geom"><a href="#几何对象geom" class="headerlink" title="几何对象geom"></a>几何对象geom</h2><p>我们可以通过改变几何对象画出任何一种类型的图形。</p><p>二维变量关系：</p><ul><li><code>geom = &quot;point&quot;</code>：散点图（默认）</li><li><code>geom = &quot;smooth&quot;</code>：拟合一条平滑曲线</li><li><code>geom = &quot;boxplot&quot;</code>：箱线胡须图</li><li><code>geom = &quot;path&quot;</code>和<code>geom = &quot;line&quot;</code>：数据点之间绘制连线</li></ul><p>一维分布：</p><ul><li>连续变量<ul><li><code>geom = &quot;histogram&quot;</code>：直方图（默认）</li><li><code>geom = &quot;freqplot&quot;</code>：频率多边形</li><li><code>geom = &quot;density&quot;</code>：密度曲线</li></ul></li><li>离散变量<ul><li><code>geom = &quot;bar&quot;</code>：条形图</li></ul></li></ul><h3 id="平滑曲线"><a href="#平滑曲线" class="headerlink" title="平滑曲线"></a>平滑曲线</h3><p>如果散点图中有非常多的数据点，那么数据展示的趋势就不太明显了，这时候，我们可以在图中添加一条平滑曲线。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 小数据集-左图</span></span><br><span class="line">qplot(carat, price, data = dsmall, geom = c(<span class="string">"point"</span>, <span class="string">"smooth"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部数据集-右图</span></span><br><span class="line">qplot(carat, price, data = diamonds, geom = c(<span class="string">"point"</span>, <span class="string">"smooth"</span>))</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/平滑曲线-1.png" title="平滑曲线-1"><p>我们可以通过span参数控制曲线的平滑程度。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qplot(carat, price, data = dsmall, geom = c(<span class="string">"point"</span>, <span class="string">"smooth"</span>), span = <span class="number">0.2</span>)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/平滑曲线-2.png" title="平滑曲线-2"><h3 id="箱型图和扰动点图"><a href="#箱型图和扰动点图" class="headerlink" title="箱型图和扰动点图"></a>箱型图和扰动点图</h3><p>当数据集包含了一个分类变量和一个连续变量时，我们可以通过箱型图和扰动点图来看连续变量是如何随着分类变量的变化而变化的。</p><ul><li>扰动点图可以显示所有的点，但是有图形重叠的问题。</li><li>箱型图可以显示出分布的中位数和四分位数，信息更充分。</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 扰动点图-左图</span></span><br><span class="line">qplot(color, price / carat, data = diamonds, geom = <span class="string">"jitter"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 箱型图-右图</span></span><br><span class="line">qplot(color, price / carat, data = diamonds, geom = <span class="string">"boxplot"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/箱型图和扰动点图-1.png" title="箱型图和扰动点图-1"><p>我们可以用半透明度来解决扰动点图的图形重叠问题。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透明度设置为1/5-左图</span></span><br><span class="line">qplot(color, price / carat, data = diamonds, geom = <span class="string">"jitter"</span>, alpha = I(<span class="number">1</span>/<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透明度设置为1/50-中图</span></span><br><span class="line">qplot(color, price / carat, data = diamonds, geom = <span class="string">"jitter"</span>, alpha = I(<span class="number">1</span>/<span class="number">50</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透明度设置为1/200-右图</span></span><br><span class="line">qplot(color, price / carat, data = diamonds, geom = <span class="string">"jitter"</span>, alpha = I(<span class="number">1</span>/<span class="number">200</span>))</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/箱型图和扰动点图-2.png" title="箱型图和扰动点图-2"><h3 id="直方图和密度曲线图"><a href="#直方图和密度曲线图" class="headerlink" title="直方图和密度曲线图"></a>直方图和密度曲线图</h3><p>直方图和密度曲线图可以展示单个变量的分布。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直方图-左图</span></span><br><span class="line">qplot(carat, data = diamonds, geom = <span class="string">"histogram"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 密度曲线图-右图</span></span><br><span class="line">qplot(carat, data = diamonds, geom = <span class="string">"density"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/直方图和密度曲线图.png" title="直方图和密度曲线图"><p><strong>在直方图中，应该尝试多种组距。当组距较大时，图形能反映数据的总体特征，当组距较小时，则能显示出更多的细节</strong>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 组距设置为1-左图</span></span><br><span class="line">qplot(carat, data = diamonds, geom = <span class="string">"histogram"</span>, binwidth = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组距设置为0.1-中图</span></span><br><span class="line">qplot(carat, data = diamonds, geom = <span class="string">"histogram"</span>, binwidth = <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组距设置为0.01-右图</span></span><br><span class="line">qplot(carat, data = diamonds, geom = <span class="string">"histogram"</span>, binwidth = <span class="number">0.01</span>)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/直方图组距对比.png" title="直方图组距对比"><p>如果要对不同组的分布进行对比，只需要再加上一个<strong>图形映射</strong>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 密度图分组对比-左图</span></span><br><span class="line">qplot(carat, data = diamonds, geom = <span class="string">"density"</span>, colour = color)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直方图分组对比-右图</span></span><br><span class="line">qplot(carat, data = diamonds, geom = <span class="string">"histogram"</span>, fill = color)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/直方图和密度图分组对比.png" title="直方图和密度图分组对比"><h3 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h3><p>条形图几何对象会计算每一个水平下观测的数量，因此无需预先对数据进行汇总。</p><p>下面是钻石颜色的条形图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通条形图（钻石颜色）-左图</span></span><br><span class="line">qplot(color, data = diamonds, geom = <span class="string">"bar"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按重量加权的条形图，即得到的是每种颜色的钻石的总重量-右图</span></span><br><span class="line">qplot(color, data = diamonds, geom = <span class="string">"bar"</span>, weight = carat) + scale_y_continuous(<span class="string">"carat"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/条形图.png" title="条形图"><h3 id="时间序列中的线条图和路径图"><a href="#时间序列中的线条图和路径图" class="headerlink" title="时间序列中的线条图和路径图"></a>时间序列中的线条图和路径图</h3><p>线条图和路径图常用于时间序列的可视化。</p><ul><li>线条图：点从左到右进行连接</li><li>路径图：按照点在数据集中的顺序进行连接</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str(economics)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Classes &apos;spec_tbl_df&apos;, &apos;tbl_df&apos;, &apos;tbl&apos; and &apos;data.frame&apos;:574 obs. of  6 variables:</span><br><span class="line"> $ date    : Date, format: &quot;1967-07-01&quot; &quot;1967-08-01&quot; ...</span><br><span class="line"> $ pce     : num  507 510 516 512 517 ...</span><br><span class="line"> $ pop     : num  198712 198911 199113 199311 199498 ...</span><br><span class="line"> $ psavert : num  12.6 12.6 11.9 12.9 12.8 11.8 11.7 12.3 11.7 12.3 ...</span><br><span class="line"> $ uempmed : num  4.5 4.7 4.6 4.9 4.7 4.8 5.1 4.5 4.1 4.6 ...</span><br><span class="line"> $ unemploy: num  2944 2945 2958 3143 3066 ...</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(economics)</span><br></pre></td></tr></table></figure><table><thead><tr><th>date</th><th>pce</th><th>pop</th><th>psavert</th><th>uempmed</th><th>unemploy</th></tr></thead><tbody><tr><td>1967-07-01</td><td>506.7</td><td>198712</td><td>12.6</td><td>4.5</td><td>2944</td></tr><tr><td>1967-08-01</td><td>509.8</td><td>198911</td><td>12.6</td><td>4.7</td><td>2945</td></tr><tr><td>1967-09-01</td><td>515.6</td><td>199113</td><td>11.9</td><td>4.6</td><td>2958</td></tr><tr><td>1967-10-01</td><td>512.2</td><td>199311</td><td>12.9</td><td>4.9</td><td>3143</td></tr><tr><td>1967-11-01</td><td>517.4</td><td>199498</td><td>12.8</td><td>4.7</td><td>3066</td></tr><tr><td>1967-12-01</td><td>525.1</td><td>199657</td><td>11.8</td><td>4.8</td><td>3018</td></tr></tbody></table><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 失业人口的比例-左图</span></span><br><span class="line">qplot(date, unemploy / pop, data = economics, geom = <span class="string">"line"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 失业星期数的中位数-右图</span></span><br><span class="line">qplot(date, uempmed, data = economics, geom = <span class="string">"line"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/时间序列.png" title="时间序列"><h2 id="分面"><a href="#分面" class="headerlink" title="分面"></a>分面</h2><p>比较不同分组可以通过</p><ul><li><strong>图形属性（颜色和形状）</strong>：所有组绘制在同一张图中</li><li><strong>分面</strong>：数据分割成若干子集，然后创建一个图形的矩阵，将每个子集绘制到图形矩阵中</li></ul><p>下面第一张图展示的是频数，第二张图展示的是频率，频率图可以使得比较不同组的分布时不受到该组样本量大小的影响：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 钻石重量的频数（按照颜色分组）-左图</span></span><br><span class="line">qplot(carat, data = diamonds, facets = color ~ ., </span><br><span class="line">      geom = <span class="string">"histogram"</span>, binwidth = <span class="number">0.1</span>, xlim = c(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 钻石重量的频率（按照颜色分组）-右图</span></span><br><span class="line">qplot(carat, ..density.., data = diamonds, facets = color ~ ., </span><br><span class="line">      geom = <span class="string">"histogram"</span>, binwidth = <span class="number">0.1</span>, xlim = c(<span class="number">0</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/分面.png" title="分面"><p>语法说明：</p><ul><li>我们可以通过<code>row_var ~ col_var</code>的表达式进行指定窗格数。如果想指定一行或一列，可以使用<code>.</code>作为占位符</li><li><code>..density..</code>：这是一个新的语法，告诉ggplot2将密度而不是频数映射到y轴</li></ul><h2 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h2><p>qplot中还有以下选项用于控制图形的外观：</p><ul><li>xlim、ylim：设置x轴和y轴的显示区间。例如：<code>xlim = c(0, 20)</code></li><li>log：一个字符型向量，说明哪个坐标轴应该取对数。例如：<code>log = &quot;xy&quot;</code></li><li>main：图形的主标题，可以是字符串或表达式。例如：<code>main = &quot;plot title&quot;</code>或<code>main = expression(beta[1] == 1)</code></li><li>xlab、ylab：设置x轴和y轴的标签文字，可以是字符串或表达式。</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标题、坐标轴标签设置-左图</span></span><br><span class="line">qplot(</span><br><span class="line">    carat, price, data = dsmall, </span><br><span class="line">    xlab = <span class="string">"Price ($)"</span>, ylab = <span class="string">"Weight (carats)"</span>, </span><br><span class="line">    main = <span class="string">"Price-weight relationship"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 坐标轴设置为对数-右图</span></span><br><span class="line">qplot(carat, price, data = dsmall, log = <span class="string">"xy"</span>)</span><br></pre></td></tr></table></figure><img src="/archives/8c7eb5d5/其他选项.png" title="其他选项"><blockquote><p>本文是《ggplot2-数据分析与图形艺术》的笔记</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;code&gt;qplot()&lt;/code&gt;是ggplot2的一个作图函数，qplot的意思是快速作图（quick plot）。&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/categories/R/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="数据可视化" scheme="https://tding.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ggplot2" scheme="https://tding.top/tags/ggplot2/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter Notebook中使用R语言</title>
    <link href="https://tding.top/archives/3aa9fd39.html"/>
    <id>https://tding.top/archives/3aa9fd39.html</id>
    <published>2019-12-04T06:40:15.000Z</published>
    <updated>2019-12-04T16:09:41.061Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>既然我们是用R语言来做数据分析，那么就不得不提到Jupyter Notebook。</p><p>Jupyter Notebook是以网页的形式打开，这样我们可以在网页中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示，非常方便直观。如果在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。</p><ul><li>R版本：3.6.1</li><li>Jupyter Notebook版本：1.0.0</li></ul><a id="more"></a><h2 id="Jupyter-Notebook安装"><a href="#Jupyter-Notebook安装" class="headerlink" title="Jupyter Notebook安装"></a>Jupyter Notebook安装</h2><p>安装Jupyter Notebook的前提是需要安装了Python。然后可以通过pip进行安装，cmd中输入：</p><ol><li>升级pip到最新版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure><p>注意：老版本的pip在安装Jupyter Notebook过程中或面临依赖项无法同步安装的问题。因此强烈建议先把pip升级到最新版本。</p><ol start="2"><li>安装Jupyter Notebook</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure><h2 id="运行Jupyter-Notebook"><a href="#运行Jupyter-Notebook" class="headerlink" title="运行Jupyter Notebook"></a>运行Jupyter Notebook</h2><p>直接在终端中输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>执行命令之后，在终端中将会显示一系列notebook的服务器信息，同时浏览器将会自动启动Jupyter Notebook。</p><p>注意：之后在Jupyter Notebook的所有操作，都请保持终端不要关闭，因为一旦关闭终端，就会断开与本地服务器的链接。</p><h2 id="Jupyter-Notebook里添加R核"><a href="#Jupyter-Notebook里添加R核" class="headerlink" title="Jupyter Notebook里添加R核"></a>Jupyter Notebook里添加R核</h2><p>这里需要提前安装好R。</p><ol><li>在R Console中输入</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(c(<span class="string">'repr'</span>, <span class="string">'IRdisplay'</span>, <span class="string">'evaluate'</span>, <span class="string">'crayon'</span>, <span class="string">'pbdZMQ'</span>, <span class="string">'devtools'</span>, <span class="string">'uuid'</span>, <span class="string">'digest'</span>))</span><br></pre></td></tr></table></figure><ol start="2"><li>安装IRkernel包，在R Console中输入</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtools::install_github(<span class="string">'IRkernel/IRkernel'</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>使R在Jupyter Notebook中可以被探测到，在R Console中输入</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IRkernel::installspec(user = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p>通过设置<code>user=FALSE</code>安装在系统中，如果缺省，即<code>IRkernel::installspec()</code>，则只在当前用户下安装。</p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[InstallKernelSpec] Installed kernelspec ir in C:\ProgramData\jupyter\kernels\ir</span><br></pre></td></tr></table></figure><p>至此，安装完成。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试一下是否安装成功。再次打开jupyter notebook，在<strong>右侧新建的下拉选择</strong>里面出现R，就代表安装成功了。</p><p>至此，Jupyter Notebook里已正确添加R核。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/91365f343585" rel="external nofollow noopener noreferrer" target="_blank">Jupyter Notebook介绍、安装及使用教程</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;既然我们是用R语言来做数据分析，那么就不得不提到Jupyter Notebook。&lt;/p&gt;&lt;p&gt;Jupyter Notebook是以网页的形式打开，这样我们可以在网页中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示，非常方便直观。如果在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;R版本：3.6.1&lt;/li&gt;&lt;li&gt;Jupyter Notebook版本：1.0.0&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="环境" scheme="https://tding.top/categories/R/%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="Jupyter Notebook" scheme="https://tding.top/tags/Jupyter-Notebook/"/>
    
  </entry>
  
  <entry>
    <title>VSCode中配置R语言运行环境</title>
    <link href="https://tding.top/archives/eb2dec05.html"/>
    <id>https://tding.top/archives/eb2dec05.html</id>
    <published>2019-12-04T03:30:00.000Z</published>
    <updated>2019-12-05T02:50:16.394Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --><p>在使用R语言的大部分用户中，RStudio都是首选的IDE。凭借其完善的功能和特性，RStudio似乎成了R语言理所当然的选择。不过一些时候，我们可能并不需要特别多的复杂功能，因此，我尝试在VSCode这个轻量级的通用代码编辑器中配置R语言运行环境。</p><a id="more"></a><h2 id="安装R"><a href="#安装R" class="headerlink" title="安装R"></a>安装R</h2><p>首先我们需要安装<a href="https://www.r-project.org/" rel="external nofollow noopener noreferrer" target="_blank">R 核心程序</a>。</p><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>如果你曾经在VSCode中使用过Python插件，实际上只需要微软出品的这一个插件就差不多可以开始工作了。但作为小众语言，R的插件并不是官方开发，而是由第三方开发者贡献的。这也导致配置一个尚可的R环境需要从四处安装不同的东西，才能开始工作。</p><h3 id="R"><a href="#R" class="headerlink" title="R"></a><a href="https://marketplace.visualstudio.com/items?itemName=Ikuyadeu.r" rel="external nofollow noopener noreferrer" target="_blank">R</a></h3><p>首先，在Visual Studio Code的应用商店中搜索扩展R，然后我们可以按照扩展说明进行配置：</p><blockquote><ul><li>For Windows, set config r.rterm.windows to your R.exe Path like “C:\Program Files\R\R-3.3.4\bin\x64\R.exe”;</li><li>For Radian console, enable config r.bracketedPaste</li><li>Open your folder that has R source file (Can’t work if you open only file)</li><li>Use F1 key and R: command or Ctrl+Enter(Mac: ⌘+Enter)</li></ul></blockquote><p>首先配置R语言的可执行文件位置，也就是<code>R.exe</code>的位置</p><img src="/archives/eb2dec05/配置R语言的可执行文件位置.png" title="配置r语言的可执行文件位置"><p>配置好之后需要重新加载。新建窗口，打开自己编写的 r 文件。</p><ul><li>选中执行是 <code>ctrl + Enter</code></li><li>执行文件是 <code>ctrl + Shift + s</code> 或者 点击右上角的小图标</li></ul><h3 id="R-LSP-Client"><a href="#R-LSP-Client" class="headerlink" title="R LSP Client"></a><a href="https://marketplace.visualstudio.com/items?itemName=REditorSupport.r-lsp" rel="external nofollow noopener noreferrer" target="_blank">R LSP Client</a></h3><p>如果只安装上面这个R插件，很多代码不能自动补全，尤其是来自第三方包的命令。这对强烈依赖第三方包的R简直是致命的。这时就需要安装另外的一个插件：R LSP Client。</p><blockquote><p>LSP 是Language Server Protocol 的缩写。简单来说，LSP 为不同语言在不同编辑器或IDE 中的自动补全、查找定义、悬停查看函数文档等功能搭建了桥梁，使得开发者可以减少针对不同语言和不同编辑器的重复开发。对用户来说，使用这一功能意味着可以获得更好的自动补全、查看帮助文档等特性。</p></blockquote><p><strong>注意：安装了这个插件后，你会发现自动补全依然没有出现。实际上，插件只是在编辑器一侧提供了实现LSP的条件，而在R语言一侧还需要另外的包languageserver来完成搭接</strong>。</p><p>在R环境中运行如下安装指令：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(<span class="string">"languageserver"</span>)</span><br></pre></td></tr></table></figure><p>然后重启一下VSCode，整个LSP的功能就可以实现了。</p><h3 id="radian"><a href="#radian" class="headerlink" title="radian"></a><a href="https://github.com/randy3k/radian" rel="external nofollow noopener noreferrer" target="_blank">radian</a></h3><p>使用R语言很多时候是把编辑器中的代码发送到Console中运行，一些时候也需要直接在Console中运行一些代码进行快速交互。RStudio为Console提供了语法高亮、自动补全等功能的加持，使得在Console中也可以有比较方便的输入输出体验。然而R for VSCode插件默认在Terminal中调用R进程，只会返回朴素的R Console界面，高亮、补全通通不在考虑范围之内。</p><p>radian为这件事提供了新的可能。它给“性冷淡”的R Console 穿上一身华丽的新衣，也增加了自动补全、多行输入等等特殊能力。我们可以把它加入到VSCode中，或是直接在终端中使用它运行R代码。</p><p>radian本身是一个Python项目，所以你需要安装有一个Python环境，然后使用pip安装这个包，直接在终端中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U radian</span><br></pre></td></tr></table></figure><p>安装完成后，就可以在终端中直接使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">radian</span><br></pre></td></tr></table></figure><p>由于radian并不是VSCode插件，它可以独立在终端中运行，但带来的问题就是无法在VSCode中默认调用它。好在R for VSCode插件提供了更换R Console 路径的设置。</p><p>打开VSCode的设置项，找到r的设置。这里有三项相似的设置分别为<code>r.rterm.linux</code>、<code>r.rterm.mac</code>、<code>r.rterm.windows</code>，根据你的系统，找到需要更改的其中一个设置项。但在更改之前，需要知道radian在哪里。比较快捷的方式是在终端中运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">where</span> radian</span><br></pre></td></tr></table></figure><p>然后我们将返回的路径粘贴在相应设置的值中。</p><p>但重启VSCode并运行一个R命令会发现VSCode返回一个类似的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">终端进程命令“/Users/caoyue/anaconda3/bin/rtichoke --no-save --no-restore --no-site-file”无法启动 (退出代码: 2)</span><br></pre></td></tr></table></figure><p>因为R for VSCode插件在开启一个R 进程时，默认带入了三个选项<code>--no-save</code>、<code>--no-restore</code>、<code>--no-site-file</code>。然而根据radian作者的说法，radian的<code>--no-save</code>和<code>--no-restore</code>已经作为默认选项故而无法再传入。因此，在设置中关闭<code>--no-save</code>和<code>no-restore</code>两个选项即可。在VSCode 的设置中，找到r设置下的<code>r.rterm.option</code>，将后面不需要的两项注释掉或删掉即可。当然，你也可以在这里使用自定义的选项。</p><p>另外的一个问题是，你可能发现更换掉R Console路径后，LSP 带来的效果不见了。这是因为Lanuage Server指向的路径默认随着R Console 变动，而它无法识别radian。我们通过将选项<code>r.rpath.lsp</code>更改为<code>R.exe</code>的默认路径即可修复该问题。</p><p>到此为止，radian的配置工作结束。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://neusncp.com/user/blog?id=191" rel="external nofollow noopener noreferrer" target="_blank">VS Code中使用R语言扩展的相关配置</a></li><li><a href="https://sspai.com/post/47386" rel="external nofollow noopener noreferrer" target="_blank">在VSCode 中配置R 语言运行环境</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Dec 26 2019 23:32:13 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在使用R语言的大部分用户中，RStudio都是首选的IDE。凭借其完善的功能和特性，RStudio似乎成了R语言理所当然的选择。不过一些时候，我们可能并不需要特别多的复杂功能，因此，我尝试在VSCode这个轻量级的通用代码编辑器中配置R语言运行环境。&lt;/p&gt;
    
    </summary>
    
      <category term="R" scheme="https://tding.top/categories/R/"/>
    
      <category term="环境" scheme="https://tding.top/categories/R/%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="R" scheme="https://tding.top/tags/R/"/>
    
      <category term="VSCode" scheme="https://tding.top/tags/VSCode/"/>
    
  </entry>
  
</feed>
